
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, v as validate_slots, e as element, c as attr_dev, f as add_location, g as set_style, h as insert_dev, j as append_dev, n as noop, p as detach_dev, u as validate_each_argument, o as onMount, t as text, a as space, Y as toggle_class, m as set_data_dev, E as destroy_each, b as svg_element, l as listen_dev, r as run_all, Z as createEventDispatcher, V as set_input_value, y as currentLang, _ as afterUpdate, K as globals, F as binding_callbacks, $ as bind, G as create_component, O as add_render_callback, a0 as select_option, H as mount_component, W as prevent_default, a1 as to_number, a2 as add_flush_callback, X as prop_dev, A as transition_in, D as transition_out, I as destroy_component, a3 as select_value, R as validate_each_keys, T as update_keyed_each, U as destroy_block, B as group_outros, C as check_outros, a4 as init_binding_group, k as is_function, P as create_bidirectional_transition, L as empty } from './main-00d1c1b7.js';
import { g as gsapWithCSS } from './index-171583ae.js';
import { f as fade } from './index-2fedee7d.js';

/* src/components/LoadingSpinner.svelte generated by Svelte v3.59.2 */

const file$a = "src/components/LoadingSpinner.svelte";

function create_fragment$a(ctx) {
	let div2;
	let div1;
	let div0;

	const block = {
		c: function create() {
			div2 = element("div");
			div1 = element("div");
			div0 = element("div");
			attr_dev(div0, "class", "spinner-inner svelte-8cxzyj");
			add_location(div0, file$a, 7, 4, 211);
			attr_dev(div1, "class", "spinner svelte-8cxzyj");
			set_style(div1, "width", /*size*/ ctx[0]);
			set_style(div1, "height", /*size*/ ctx[0]);
			set_style(div1, "border-color", /*color*/ ctx[1]);
			add_location(div1, file$a, 6, 2, 123);
			attr_dev(div2, "class", "spinner-container svelte-8cxzyj");
			add_location(div2, file$a, 5, 0, 89);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div2, anchor);
			append_dev(div2, div1);
			append_dev(div1, div0);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size*/ 1) {
				set_style(div1, "width", /*size*/ ctx[0]);
			}

			if (dirty & /*size*/ 1) {
				set_style(div1, "height", /*size*/ ctx[0]);
			}

			if (dirty & /*color*/ 2) {
				set_style(div1, "border-color", /*color*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div2);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$a.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$a($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('LoadingSpinner', slots, []);
	let { size = '1.5rem' } = $$props;
	let { color = 'var(--primary)' } = $$props;
	const writable_props = ['size', 'color'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<LoadingSpinner> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('size' in $$props) $$invalidate(0, size = $$props.size);
		if ('color' in $$props) $$invalidate(1, color = $$props.color);
	};

	$$self.$capture_state = () => ({ size, color });

	$$self.$inject_state = $$props => {
		if ('size' in $$props) $$invalidate(0, size = $$props.size);
		if ('color' in $$props) $$invalidate(1, color = $$props.color);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [size, color];
}

class LoadingSpinner extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$a, create_fragment$a, safe_not_equal, { size: 0, color: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "LoadingSpinner",
			options,
			id: create_fragment$a.name
		});
	}

	get size() {
		throw new Error("<LoadingSpinner>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<LoadingSpinner>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<LoadingSpinner>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<LoadingSpinner>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/ServiceSelection.svelte generated by Svelte v3.59.2 */
const file$9 = "src/components/ServiceSelection.svelte";

function get_each_context$3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[8] = list[i];
	child_ctx[10] = i;
	return child_ctx;
}

// (52:8) {#each services as service, i}
function create_each_block$3(ctx) {
	let div2;
	let div0;
	let raw_value = /*service*/ ctx[8].svgIcon + "";
	let t0;
	let h3;
	let t1_value = /*content*/ ctx[0][/*currentLang*/ ctx[1]].services[/*service*/ ctx[8].id].title + "";
	let t1;
	let t2;
	let p;
	let t3_value = /*content*/ ctx[0][/*currentLang*/ ctx[1]].services[/*service*/ ctx[8].id].description + "";
	let t3;
	let t4;
	let div1;
	let span;

	let t5_value = (/*currentLang*/ ctx[1] === 'hu'
	? 'Foglalás'
	: 'Book Now') + "";

	let t5;
	let t6;
	let svg;
	let path;
	let t7;
	let mounted;
	let dispose;

	function click_handler() {
		return /*click_handler*/ ctx[6](/*service*/ ctx[8]);
	}

	function keydown_handler(...args) {
		return /*keydown_handler*/ ctx[7](/*service*/ ctx[8], ...args);
	}

	const block = {
		c: function create() {
			div2 = element("div");
			div0 = element("div");
			t0 = space();
			h3 = element("h3");
			t1 = text(t1_value);
			t2 = space();
			p = element("p");
			t3 = text(t3_value);
			t4 = space();
			div1 = element("div");
			span = element("span");
			t5 = text(t5_value);
			t6 = space();
			svg = svg_element("svg");
			path = svg_element("path");
			t7 = space();
			attr_dev(div0, "class", "service-icon svelte-ppy20d");
			add_location(div0, file$9, 59, 12, 15113);
			attr_dev(h3, "class", "svelte-ppy20d");
			add_location(h3, file$9, 62, 12, 15209);
			attr_dev(p, "class", "svelte-ppy20d");
			add_location(p, file$9, 63, 12, 15280);
			add_location(span, file$9, 65, 14, 15398);
			attr_dev(path, "d", "M5 12H19M19 12L12 5M19 12L12 19");
			attr_dev(path, "stroke", "currentColor");
			attr_dev(path, "stroke-width", "2");
			attr_dev(path, "stroke-linecap", "round");
			attr_dev(path, "stroke-linejoin", "round");
			add_location(path, file$9, 67, 16, 15586);
			attr_dev(svg, "width", "16");
			attr_dev(svg, "height", "16");
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", "none");
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			add_location(svg, file$9, 66, 14, 15474);
			attr_dev(div1, "class", "service-action svelte-ppy20d");
			add_location(div1, file$9, 64, 12, 15355);
			attr_dev(div2, "class", "service-card svelte-ppy20d");
			attr_dev(div2, "tabindex", "0");
			attr_dev(div2, "role", "button");
			add_location(div2, file$9, 52, 10, 14861);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div2, anchor);
			append_dev(div2, div0);
			div0.innerHTML = raw_value;
			append_dev(div2, t0);
			append_dev(div2, h3);
			append_dev(h3, t1);
			append_dev(div2, t2);
			append_dev(div2, p);
			append_dev(p, t3);
			append_dev(div2, t4);
			append_dev(div2, div1);
			append_dev(div1, span);
			append_dev(span, t5);
			append_dev(div1, t6);
			append_dev(div1, svg);
			append_dev(svg, path);
			append_dev(div2, t7);

			if (!mounted) {
				dispose = [
					listen_dev(div2, "click", click_handler, false, false, false, false),
					listen_dev(div2, "keydown", keydown_handler, false, false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*content, currentLang*/ 3 && t1_value !== (t1_value = /*content*/ ctx[0][/*currentLang*/ ctx[1]].services[/*service*/ ctx[8].id].title + "")) set_data_dev(t1, t1_value);
			if (dirty & /*content, currentLang*/ 3 && t3_value !== (t3_value = /*content*/ ctx[0][/*currentLang*/ ctx[1]].services[/*service*/ ctx[8].id].description + "")) set_data_dev(t3, t3_value);

			if (dirty & /*currentLang*/ 2 && t5_value !== (t5_value = (/*currentLang*/ ctx[1] === 'hu'
			? 'Foglalás'
			: 'Book Now') + "")) set_data_dev(t5, t5_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div2);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$3.name,
		type: "each",
		source: "(52:8) {#each services as service, i}",
		ctx
	});

	return block;
}

function create_fragment$9(ctx) {
	let section;
	let div1;
	let h2;
	let t0_value = /*content*/ ctx[0][/*currentLang*/ ctx[1]].serviceSelection.title + "";
	let t0;
	let t1;
	let p;
	let t2_value = /*content*/ ctx[0][/*currentLang*/ ctx[1]].serviceSelection.description + "";
	let t2;
	let t3;
	let div0;
	let each_value = /*services*/ ctx[2];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			section = element("section");
			div1 = element("div");
			h2 = element("h2");
			t0 = text(t0_value);
			t1 = space();
			p = element("p");
			t2 = text(t2_value);
			t3 = space();
			div0 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr_dev(h2, "class", "section-title svelte-ppy20d");
			add_location(h2, file$9, 47, 6, 14577);
			attr_dev(p, "class", "section-subtitle svelte-ppy20d");
			add_location(p, file$9, 48, 6, 14660);
			attr_dev(div0, "class", "services-grid svelte-ppy20d");
			toggle_class(div0, "visible", /*servicesLoaded*/ ctx[3]);
			add_location(div0, file$9, 50, 6, 14753);
			attr_dev(div1, "class", "container");
			add_location(div1, file$9, 46, 4, 14547);
			attr_dev(section, "class", "service-selection-section svelte-ppy20d");
			add_location(section, file$9, 45, 2, 14499);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);
			append_dev(section, div1);
			append_dev(div1, h2);
			append_dev(h2, t0);
			append_dev(div1, t1);
			append_dev(div1, p);
			append_dev(p, t2);
			append_dev(div1, t3);
			append_dev(div1, div0);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(div0, null);
				}
			}
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*content, currentLang*/ 3 && t0_value !== (t0_value = /*content*/ ctx[0][/*currentLang*/ ctx[1]].serviceSelection.title + "")) set_data_dev(t0, t0_value);
			if (dirty & /*content, currentLang*/ 3 && t2_value !== (t2_value = /*content*/ ctx[0][/*currentLang*/ ctx[1]].serviceSelection.description + "")) set_data_dev(t2, t2_value);

			if (dirty & /*selectService, services, currentLang, content*/ 23) {
				each_value = /*services*/ ctx[2];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$3(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$3(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div0, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$9.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$9($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('ServiceSelection', slots, []);
	let { content = {} } = $$props;
	let { currentLang = 'hu' } = $$props;
	let { onSelectService } = $$props;

	// Define service data
	const services = [
		{
			id: 'airportParking',
			svgIcon: `<svg fill="#ffffff" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier"><path d="M12,6H9A1,1,0,0,0,8,7V17a1,1,0,0,0,2,0V14h2a4,4,0,0,0,0-8ZM12,12H10V8h2a2,2,0,0,1,0,4ZM19,2H5A3,3,0,0,0,2,5V19a3,3,0,0,0,3,3H19a3,3,0,0,0,3-3V5A3,3,0,0,0,19,2Zm1,17a1,1,0,0,1-1,1H5a1,1,0,0,1-1-1V5A1,1,0,0,1,5,4H19a1,1,0,0,1,1,1Z"></path></g></svg>`
		},
		{
			id: 'carWash',
			svgIcon: `<svg fill="#ffffff" version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 512 512" style="enable-background:new 0 0 512 512;" xml:space="preserve"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier"> <g> <g> <path d="M142.25,206.819c-11.982,0.247-23.234-6.299-28.755-17.521l-2.751-5.591H62.71l1.296-5.894 c-5.764-0.319-11.242-2.802-15.533-7.128c-4.972-5.008-8.189-12.11-9.732-21.491l-14.374,65.334l0.249,60.473 C10.504,278.339,0,291.007,0,306.138c0,17.674,14.326,32,32,32h22.252c0-39.307,31.979-71.286,71.286-71.286 c12.595,0,24.428,3.297,34.707,9.052v-69.417L142.25,206.819z"></path> </g> </g> <g> <g> <path d="M301.995,74.561c-4.888-8.729-14.137-14.15-24.14-14.15H136.613c5.117,8.867,4.418,20.507,2.632,30.824h39.416 c8.615-10.736,21.831-17.628,36.636-17.628c14.804,0,28.021,6.892,36.636,17.628h24.074l50.407,90.015 c-0.493-4.596,0.054-9.945,2.447-16.113c2.611-6.727,8.117-12.181,14.736-16.29L301.995,74.561z"></path> </g> </g> <g> <g> <path d="M352.07,260.154c-3.421-4.743-6.068-9.242-8.122-13.501l-40.47,13.681c-11.896,4.025-24.553,0.473-32.751-8.072 c0,67.969,0.052,26.197,0.052,85.876h55.885c0-27.503,15.665-51.4,38.532-63.283C360.825,271.131,356.463,266.245,352.07,260.154z "></path> </g> </g> <g> <g> <path d="M490.667,275.966c0-4.949,0-10.028,0-15.137h-23.202c-11.436,0-20.706-9.27-20.706-20.706 c0-11.436,9.27-20.706,20.706-20.706h20.006c-7.529-20.927-27.547-35.896-51.066-35.896h-20.637 c3.383,11.767,5.348,26.998-1.26,39.26c-5.568,10.331-4.45,31.472-4.45,36.857c0,2.834-0.471,5.526-1.302,8.034 c34.198,5.222,60.48,34.833,60.48,70.468c3.943,0,6.995,0,10.765,0c17.672,0,32-14.328,32-32 C512,292.206,503.094,280.36,490.667,275.966z"></path> </g> </g> <g> <g> <path d="M125.539,289.327c-26.957,0.001-48.81,21.854-48.81,48.811s21.853,48.81,48.81,48.81c13.359,0,25.459-5.371,34.272-14.066 v-69.488C150.997,294.698,138.897,289.327,125.539,289.327z M125.539,357.908c-10.919,0-19.77-8.851-19.77-19.77 s8.851-19.77,19.77-19.77c10.919,0,19.77,8.851,19.77,19.77S136.458,357.908,125.539,357.908z"></path> </g> </g> <g> <g> <path d="M397.949,289.328c-26.957,0-48.81,21.853-48.81,48.81c0,26.957,21.852,48.81,48.81,48.81 c26.957,0,48.81-21.853,48.81-48.81C446.758,311.181,424.906,289.328,397.949,289.328z M397.949,357.908 c-10.919,0-19.77-8.851-19.77-19.77s8.851-19.77,19.77-19.77s19.77,8.851,19.77,19.77S408.868,357.908,397.949,357.908z"></path> </g> </g> <g> <g> <path d="M384.574,159.738c-2.448-2.26-6.1-3.212-10.227-3.212c-11.621,0-26.995,7.553-29.773,14.712 c-1.873,4.827-1.758,8.322-0.671,11.21c13.144,0.327,24.716,8.792,28.945,21.305c4.753,14.058-1.07,29.178-13.161,36.697 c1.569,3.091,3.544,6.362,6.055,9.844c8.994,12.472,16.122,16.696,20.858,16.696c4.271,0,6.597-3.434,6.597-7.353 c0-6.78-1.437-30.186,6.469-44.854C407.572,200.115,393.916,168.361,384.574,159.738z"></path> </g> </g> <g> <g> <path d="M123.24,72.004C120.8,59.525,92.948,52.038,84.177,57.639c-13.97,8.921-3.438,18.865-9.36,29.381 c-5.923,10.516-20.068,17.661-20.289,46.903c-0.154,20.329,5.579,27.099,10.73,27.099c2.259,0,4.406-1.303,5.895-3.335 c2.548-3.478,8.601-12.716,16.538-20.826l-1.148-2.332c-7.641-15.526-1.226-34.374,14.301-42.016 c6.617-3.257,14.104-4.104,21.46-2.291C123.718,82.948,124.069,76.249,123.24,72.004z"></path> </g> </g> <g> <g> <path d="M356.879,209.151c-0.001-0.003-0.002-0.007-0.003-0.01c-2.563-7.571-10.85-11.669-18.409-9.099 c-14.502,4.902-23.759,8.033-38.712,13.087c-4.507-7.356-15.44-25.202-20.63-33.671c-7.251-11.835-20.379-19.185-34.258-19.185 c-83.287,0-60.216-0.155-94.254,0.474c-4.401-8.943-18.447-37.486-22.879-46.493c-3.565-7.248-12.34-10.118-19.448-6.62 c-7.199,3.543-10.163,12.249-6.621,19.447c16.505,33.54,11.631,23.638,26.954,54.773c2.49,5.06,7.758,8.245,13.302,8.11 c37.258-0.689,34.271-0.64,35.182-0.64c0,0.256-0.435,84.692-0.435,249.492c0,9.627,7.805,17.431,17.431,17.431 c9.625,0,17.431-7.804,17.431-17.431c0-14.798,0-110.297,0-125.829h7.526c0,15.538,0,110.994,0,125.829 c0,9.627,7.805,17.431,17.431,17.431c9.627,0,17.431-7.804,17.431-17.431c0-54.87-0.049-180.103-0.051-239.359 c0-0.709,0.471-1.331,1.153-1.524c0.682-0.193,1.41,0.09,1.781,0.694c3.083,5.025,9.717,15.869,24.234,39.564 c3.537,5.771,10.603,8.352,17.041,6.174c31.192-10.545,16.238-5.49,49.694-16.801 C355.383,224.992,359.442,216.736,356.879,209.151z"></path> </g> </g> <g> <g> <circle cx="215.299" cy="120.568" r="30.709"></circle> </g> </g> </g></svg>`
		},
		{
			id: 'autoService',
			svgIcon: `<svg width="35" height="35" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
        </svg>`
		},
		{
			id: 'tireService',
			svgIcon: `<svg fill="#ffffff" height="238px" width="238px" version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 512 512" xml:space="preserve"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier"> <g> <g> <g> <path d="M494.916,254.43C494.336,119.185,419.934,7.603,325.521,0.384l-0.008-0.008C322.278,0.128,319.019,0,315.742,0H196.275 C152.226,0,111.872,22.852,80.64,60.646l2.628-0.657l59.46-16.998c2.406-0.674,4.992-0.282,7.074,1.109l20.872,13.901 L191.539,44.1c2.543-1.707,5.811-1.903,8.55-0.538l29.739,14.865c-3.456,4.497-6.801,9.173-10.001,14.089l-22.946-11.469 l-21.478,14.319c-2.867,1.911-6.596,1.911-9.463,0l-22.315-14.882L87.689,76.467L64.87,82.176 c-3.072,4.736-6.007,9.643-8.823,14.703l9.097,7.441l20.19,13.423l20.873-13.909c2.867-1.92,6.596-1.92,9.463,0l20.873,13.901 l20.864-13.901c2.543-1.707,5.811-1.903,8.55-0.538l30.174,15.087c-2.116,5.231-4.105,10.615-5.982,16.094l-27.401-13.696 L141.269,135.1c-2.867,1.911-6.596,1.911-9.464,0l-20.864-13.909L90.069,135.1c-2.867,1.911-6.596,1.911-9.464,0l-25.6-17.067 l-6.972-5.7c-12.066,25.318-20.992,53.896-26.095,84.582l6.784-6.716l24.909-25.506c1.596-1.621,3.78-2.552,6.059-2.56 c2.185,0.068,4.471,0.887,6.084,2.5l19.567,19.558l19.567-19.558c3.328-3.337,8.73-3.337,12.066,0l19.567,19.558l19.567-19.558 c3.328-3.337,8.73-3.337,12.066,0l10.761,10.761c-1.365,6.494-2.594,13.073-3.635,19.78c-0.742-0.393-1.502-0.785-2.125-1.408 l-11.034-11.034L142.575,202.3c-3.337,3.328-8.738,3.328-12.066,0l-19.567-19.567L91.375,202.3 c-3.337,3.328-8.738,3.328-12.066,0L59.81,182.801l-18.978,19.43l-22.34,22.127c-0.247,2.816-0.469,5.641-0.648,8.491 l12.151,7.296l28.058,14.003L79.309,232.9c3.328-3.337,8.73-3.337,12.066,0l19.567,19.558l19.567-19.558 c2.765-2.765,7.066-3.294,10.419-1.289l29.841,17.903c-0.034,2.159-0.094,4.309-0.094,6.485c0,4.531,0.085,9.028,0.23,13.5 l-33.05-19.831l-20.881,20.898c-3.337,3.328-8.738,3.328-12.066,0l-19.567-19.567l-19.567,19.567 c-2.594,2.594-6.554,3.251-9.856,1.596l-34.133-17.067l-4.651-2.79c-0.009,1.237-0.06,2.458-0.06,3.695 c0,29.653,3.584,58.129,10.112,84.642l25.455-38.178c1.417-2.125,3.712-3.507,6.255-3.763c2.56-0.239,5.069,0.657,6.878,2.466 l19.567,19.558l19.567-19.558c3.328-3.337,8.73-3.337,12.066,0l19.567,19.558l19.567-19.558c3.328-3.337,8.73-3.337,12.066,0 l5.717,5.709c1.109,8.738,2.526,17.306,4.19,25.702c-1.792-0.239-3.533-0.905-4.907-2.278l-11.034-11.034l-19.567,19.567 c-3.337,3.328-8.738,3.328-12.066,0l-19.567-19.567l-19.567,19.567c-3.337,3.328-8.738,3.328-12.066,0l-18.244-18.244 L33.297,362.24c3.499,10.906,7.518,21.402,12.015,31.42l8.875-7.603l16.589-16.623c3.328-3.336,8.73-3.336,12.066,0 l19.567,19.558l19.567-19.558c3.328-3.336,8.73-3.336,12.066,0l18.236,18.236l11.298-16.939 c2.381-3.575,7.066-4.821,10.914-2.901l14.797,7.398c2.705,8.124,5.709,15.966,8.934,23.552l-24.627-12.314l-12.885,19.328 c-1.417,2.125-3.721,3.507-6.263,3.763c-2.586,0.222-5.069-0.657-6.869-2.458l-19.567-19.567L108.442,407.1 c-3.337,3.328-8.738,3.328-12.066,0l-19.567-19.567l-11.034,11.034l-12.8,10.974c9.779,18.577,21.308,35.157,34.193,49.34 l10.948-5.478l25.156-16.768c2.867-1.92,6.596-1.92,9.463,0l20.873,13.901l20.864-13.901c2.867-1.92,6.596-1.92,9.463,0 l20.873,13.901l15.386-10.249c3.174,4.847,6.502,9.464,9.924,13.892L209.536,467.9c-2.867,1.911-6.596,1.911-9.464,0 l-20.864-13.909L158.336,467.9c-2.867,1.911-6.596,1.911-9.464,0l-20.864-13.909L107.136,467.9 c-0.29,0.196-0.597,0.375-0.913,0.529l-6.366,3.183C127.718,497.126,160.794,512,196.275,512h119.467 c2.944,0,5.939-0.119,8.969-0.35h0.009c0.213,0,0.435,0,0.649-0.017c4.198-0.324,8.644-0.939,13.508-1.835 c75.699-13.892,137.464-95.036,152.576-203.315c2.159-16.521,3.328-33.485,3.473-50.483 C494.925,255.991,494.916,254.438,494.916,254.43z M474.547,304.188c-14.319,102.519-72.149,178.671-142.14,189.278 c-2.611,0.401-5.239,0.853-7.799,1.075c-0.179-0.017-0.35-0.051-0.529-0.068c-2.492-0.247-4.966-0.597-7.424-1.05 c-0.862-0.162-1.707-0.367-2.568-0.546c-1.801-0.384-3.593-0.802-5.367-1.289c-0.939-0.265-1.877-0.538-2.807-0.828 c-1.724-0.538-3.439-1.118-5.146-1.758c-0.87-0.316-1.749-0.631-2.611-0.981c-1.963-0.794-3.9-1.656-5.828-2.577 c-0.555-0.265-1.126-0.503-1.681-0.776c-2.517-1.254-5.018-2.62-7.475-4.088c-0.299-0.179-0.58-0.384-0.879-0.563 c-2.142-1.314-4.258-2.697-6.349-4.164c-0.623-0.435-1.246-0.905-1.86-1.357c-1.792-1.306-3.567-2.662-5.316-4.079 c-0.614-0.495-1.229-0.998-1.835-1.51c-1.852-1.553-3.678-3.174-5.478-4.855c-0.427-0.393-0.853-0.776-1.28-1.178 c-6.886-6.571-13.406-14.037-19.507-22.315c-0.205-0.282-0.41-0.572-0.623-0.853c-1.852-2.551-3.678-5.171-5.453-7.868 c-0.179-0.273-0.35-0.538-0.529-0.802c-7.859-12.049-14.908-25.506-20.992-40.132c-0.401-0.973-0.802-1.937-1.195-2.918 c-1.903-4.71-3.703-9.54-5.393-14.472c-0.017-0.034-0.026-0.068-0.034-0.102c-1.69-4.915-3.268-9.933-4.745-15.053 c-0.017-0.043-0.026-0.085-0.043-0.128c-1.434-4.984-2.756-10.078-3.985-15.249c-0.111-0.461-0.213-0.939-0.324-1.399 c-1.152-4.949-2.219-9.975-3.174-15.078c-0.034-0.196-0.077-0.384-0.111-0.58c-0.947-5.103-1.775-10.3-2.517-15.539 c-0.137-0.93-0.256-1.86-0.375-2.79c-0.666-4.966-1.254-9.975-1.732-15.053c-0.026-0.29-0.06-0.58-0.085-0.879 c-0.478-5.205-0.819-10.479-1.084-15.795c-0.06-1.229-0.111-2.466-0.162-3.703c-0.222-5.35-0.367-10.726-0.367-16.162 c0-3.968,0.06-7.919,0.171-11.836c0.043-1.254,0.119-2.483,0.171-3.729c0.102-2.662,0.196-5.325,0.35-7.97 c0.102-1.647,0.247-3.268,0.367-4.907c0.162-2.202,0.299-4.42,0.495-6.613c0.179-1.963,0.41-3.9,0.614-5.854 c0.188-1.835,0.358-3.686,0.572-5.504c0.23-1.92,0.512-3.806,0.776-5.717c0.247-1.818,0.469-3.652,0.734-5.461 c0.282-1.852,0.614-3.678,0.922-5.513c0.299-1.818,0.58-3.661,0.904-5.461c0.341-1.869,0.734-3.703,1.101-5.555 c0.341-1.732,0.666-3.482,1.033-5.197c0.41-1.937,0.87-3.823,1.314-5.734c0.375-1.596,0.717-3.217,1.109-4.796 c0.478-1.946,1.007-3.857,1.519-5.777c0.401-1.502,0.777-3.029,1.195-4.514c0.538-1.903,1.118-3.763,1.681-5.632 c0.444-1.468,0.862-2.953,1.323-4.403c0.58-1.843,1.212-3.635,1.818-5.453c0.486-1.434,0.947-2.901,1.451-4.318 c0.674-1.911,1.399-3.763,2.099-5.641c0.486-1.271,0.939-2.569,1.434-3.823c0.776-1.971,1.596-3.891,2.398-5.82 c0.469-1.118,0.913-2.261,1.391-3.362c0.828-1.903,1.698-3.746,2.552-5.606c0.503-1.084,0.981-2.202,1.502-3.277 c0.862-1.818,1.775-3.575,2.671-5.35c0.546-1.067,1.058-2.159,1.613-3.208c0.922-1.749,1.877-3.448,2.833-5.154 c0.563-1.015,1.109-2.057,1.69-3.063c0.956-1.655,1.946-3.26,2.935-4.872c0.606-0.998,1.195-2.022,1.809-2.995 c1.007-1.587,2.048-3.115,3.081-4.659c0.631-0.947,1.246-1.911,1.886-2.842c1.067-1.536,2.167-3.012,3.26-4.497 c0.64-0.87,1.263-1.766,1.911-2.62c1.118-1.468,2.27-2.876,3.422-4.292c0.648-0.811,1.289-1.647,1.946-2.432 c1.178-1.399,2.381-2.731,3.584-4.079c0.666-0.742,1.314-1.519,1.988-2.244c1.203-1.297,2.44-2.534,3.678-3.78 c0.691-0.7,1.374-1.442,2.082-2.125c1.229-1.195,2.492-2.321,3.746-3.465c0.734-0.666,1.451-1.357,2.185-2.005 c1.28-1.109,2.586-2.15,3.883-3.2c0.742-0.606,1.468-1.237,2.219-1.818c1.323-1.024,2.679-1.971,4.028-2.935 c0.742-0.538,1.485-1.109,2.236-1.621c1.331-0.913,2.697-1.741,4.053-2.586c0.794-0.495,1.579-1.033,2.372-1.502 c1.357-0.802,2.739-1.527,4.113-2.261c0.819-0.444,1.63-0.913,2.449-1.331c1.391-0.7,2.807-1.314,4.216-1.954 c0.828-0.375,1.655-0.785,2.492-1.135c1.408-0.589,2.842-1.101,4.267-1.621c0.853-0.316,1.707-0.666,2.569-0.956 c1.417-0.478,2.859-0.862,4.284-1.271c0.896-0.256,1.783-0.546,2.679-0.776c1.417-0.358,2.859-0.623,4.284-0.913 c0.93-0.196,1.86-0.418,2.79-0.58c1.425-0.247,2.867-0.401,4.301-0.58c0.905-0.111,1.792-0.256,2.697-0.333 c85.248,7.1,152.329,110.993,152.866,236.851l0.009,1.604C477.722,272.171,476.604,288.427,474.547,304.188z"></path> <path d="M252.855,151.971c-0.282-0.273-0.538-0.572-0.785-0.887l-3.081-4.019c-11.708,30.541-18.586,67.959-18.586,108.928 c0,40.747,6.801,77.995,18.389,108.442l3.763-4.105c17.493-17.263,29.047-59.076,29.047-104.337 C281.604,210.74,270.05,168.927,252.855,151.971z"></path> <path d="M332.806,68.262c-30.49,0-57.378,23.39-75.981,60.954l8.448,11.042c20.309,20.48,33.399,65.784,33.399,115.738 c0,50.313-13.278,95.906-33.835,116.173l-8.61,9.404c18.62,38.272,45.764,62.157,76.578,62.157 c57.421,0,102.4-82.458,102.4-187.733S390.227,68.262,332.806,68.262z"></path> </g> </g> </g> </g></svg>`
		}
	];

	// Animation state
	let servicesLoaded = false;

	// Function to select a service
	function selectService(serviceId) {
		// Call the parent component's function with the selected service ID
		onSelectService(serviceId);
	}

	$$self.$$.on_mount.push(function () {
		if (onSelectService === undefined && !('onSelectService' in $$props || $$self.$$.bound[$$self.$$.props['onSelectService']])) {
			console.warn("<ServiceSelection> was created without expected prop 'onSelectService'");
		}
	});

	const writable_props = ['content', 'currentLang', 'onSelectService'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ServiceSelection> was created with unknown prop '${key}'`);
	});

	const click_handler = service => selectService(service.id);
	const keydown_handler = (service, e) => e.key === 'Enter' && selectService(service.id);

	$$self.$$set = $$props => {
		if ('content' in $$props) $$invalidate(0, content = $$props.content);
		if ('currentLang' in $$props) $$invalidate(1, currentLang = $$props.currentLang);
		if ('onSelectService' in $$props) $$invalidate(5, onSelectService = $$props.onSelectService);
	};

	$$self.$capture_state = () => ({
		onMount,
		gsap: gsapWithCSS,
		content,
		currentLang,
		onSelectService,
		services,
		servicesLoaded,
		selectService
	});

	$$self.$inject_state = $$props => {
		if ('content' in $$props) $$invalidate(0, content = $$props.content);
		if ('currentLang' in $$props) $$invalidate(1, currentLang = $$props.currentLang);
		if ('onSelectService' in $$props) $$invalidate(5, onSelectService = $$props.onSelectService);
		if ('servicesLoaded' in $$props) $$invalidate(3, servicesLoaded = $$props.servicesLoaded);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		content,
		currentLang,
		services,
		servicesLoaded,
		selectService,
		onSelectService,
		click_handler,
		keydown_handler
	];
}

class ServiceSelection extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$9, create_fragment$9, safe_not_equal, {
			content: 0,
			currentLang: 1,
			onSelectService: 5
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ServiceSelection",
			options,
			id: create_fragment$9.name
		});
	}

	get content() {
		throw new Error("<ServiceSelection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set content(value) {
		throw new Error("<ServiceSelection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get currentLang() {
		throw new Error("<ServiceSelection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set currentLang(value) {
		throw new Error("<ServiceSelection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get onSelectService() {
		throw new Error("<ServiceSelection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set onSelectService(value) {
		throw new Error("<ServiceSelection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/PersonalInfoForm.svelte generated by Svelte v3.59.2 */
const file$8 = "src/components/PersonalInfoForm.svelte";

// (38:6) {#if formErrors.lastName}
function create_if_block_3$5(ctx) {
	let p;
	let t_value = /*formErrors*/ ctx[1].lastName + "";
	let t;

	const block = {
		c: function create() {
			p = element("p");
			t = text(t_value);
			attr_dev(p, "class", "error-message svelte-nvslk4");
			add_location(p, file$8, 38, 8, 983);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*formErrors*/ 2 && t_value !== (t_value = /*formErrors*/ ctx[1].lastName + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3$5.name,
		type: "if",
		source: "(38:6) {#if formErrors.lastName}",
		ctx
	});

	return block;
}

// (52:6) {#if formErrors.firstName}
function create_if_block_2$7(ctx) {
	let p;
	let t_value = /*formErrors*/ ctx[1].firstName + "";
	let t;

	const block = {
		c: function create() {
			p = element("p");
			t = text(t_value);
			attr_dev(p, "class", "error-message svelte-nvslk4");
			add_location(p, file$8, 52, 8, 1440);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*formErrors*/ 2 && t_value !== (t_value = /*formErrors*/ ctx[1].firstName + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$7.name,
		type: "if",
		source: "(52:6) {#if formErrors.firstName}",
		ctx
	});

	return block;
}

// (67:6) {#if formErrors.email}
function create_if_block_1$8(ctx) {
	let p;
	let t_value = /*formErrors*/ ctx[1].email + "";
	let t;

	const block = {
		c: function create() {
			p = element("p");
			t = text(t_value);
			attr_dev(p, "class", "error-message svelte-nvslk4");
			add_location(p, file$8, 67, 8, 1898);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*formErrors*/ 2 && t_value !== (t_value = /*formErrors*/ ctx[1].email + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$8.name,
		type: "if",
		source: "(67:6) {#if formErrors.email}",
		ctx
	});

	return block;
}

// (81:6) {#if formErrors.phone}
function create_if_block$8(ctx) {
	let p;
	let t_value = /*formErrors*/ ctx[1].phone + "";
	let t;

	const block = {
		c: function create() {
			p = element("p");
			t = text(t_value);
			attr_dev(p, "class", "error-message svelte-nvslk4");
			add_location(p, file$8, 81, 8, 2334);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*formErrors*/ 2 && t_value !== (t_value = /*formErrors*/ ctx[1].phone + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$8.name,
		type: "if",
		source: "(81:6) {#if formErrors.phone}",
		ctx
	});

	return block;
}

function create_fragment$8(ctx) {
	let div6;
	let h3;
	let t0_value = /*content*/ ctx[2][/*currentLang*/ ctx[3]].bookingForm.personalInfo.title + "";
	let t0;
	let t1;
	let div2;
	let div0;
	let label0;
	let t2_value = /*content*/ ctx[2][/*currentLang*/ ctx[3]].bookingForm.personalInfo.lastName + "";
	let t2;
	let t3;
	let input0;
	let input0_placeholder_value;
	let t4;
	let t5;
	let div1;
	let label1;
	let t6_value = /*content*/ ctx[2][/*currentLang*/ ctx[3]].bookingForm.personalInfo.firstName + "";
	let t6;
	let t7;
	let input1;
	let input1_placeholder_value;
	let t8;
	let t9;
	let div5;
	let div3;
	let label2;
	let t10_value = /*content*/ ctx[2][/*currentLang*/ ctx[3]].bookingForm.personalInfo.email + "";
	let t10;
	let t11;
	let input2;
	let input2_placeholder_value;
	let t12;
	let t13;
	let div4;
	let label3;
	let t14_value = /*content*/ ctx[2][/*currentLang*/ ctx[3]].bookingForm.personalInfo.phone + "";
	let t14;
	let t15;
	let input3;
	let input3_placeholder_value;
	let t16;
	let mounted;
	let dispose;
	let if_block0 = /*formErrors*/ ctx[1].lastName && create_if_block_3$5(ctx);
	let if_block1 = /*formErrors*/ ctx[1].firstName && create_if_block_2$7(ctx);
	let if_block2 = /*formErrors*/ ctx[1].email && create_if_block_1$8(ctx);
	let if_block3 = /*formErrors*/ ctx[1].phone && create_if_block$8(ctx);

	const block = {
		c: function create() {
			div6 = element("div");
			h3 = element("h3");
			t0 = text(t0_value);
			t1 = space();
			div2 = element("div");
			div0 = element("div");
			label0 = element("label");
			t2 = text(t2_value);
			t3 = space();
			input0 = element("input");
			t4 = space();
			if (if_block0) if_block0.c();
			t5 = space();
			div1 = element("div");
			label1 = element("label");
			t6 = text(t6_value);
			t7 = space();
			input1 = element("input");
			t8 = space();
			if (if_block1) if_block1.c();
			t9 = space();
			div5 = element("div");
			div3 = element("div");
			label2 = element("label");
			t10 = text(t10_value);
			t11 = space();
			input2 = element("input");
			t12 = space();
			if (if_block2) if_block2.c();
			t13 = space();
			div4 = element("div");
			label3 = element("label");
			t14 = text(t14_value);
			t15 = space();
			input3 = element("input");
			t16 = space();
			if (if_block3) if_block3.c();
			attr_dev(h3, "class", "svelte-nvslk4");
			add_location(h3, file$8, 25, 2, 518);
			attr_dev(label0, "for", "lastName");
			attr_dev(label0, "class", "svelte-nvslk4");
			add_location(label0, file$8, 29, 6, 642);
			attr_dev(input0, "type", "text");
			attr_dev(input0, "id", "lastName");
			input0.required = true;

			attr_dev(input0, "placeholder", input0_placeholder_value = /*currentLang*/ ctx[3] === 'hu'
			? 'Adja meg vezetéknevét'
			: 'Enter your last name');

			attr_dev(input0, "class", "svelte-nvslk4");
			add_location(input0, file$8, 30, 6, 735);
			attr_dev(div0, "class", "form-group svelte-nvslk4");
			add_location(div0, file$8, 28, 4, 611);
			attr_dev(label1, "for", "firstName");
			attr_dev(label1, "class", "svelte-nvslk4");
			add_location(label1, file$8, 43, 6, 1093);
			attr_dev(input1, "type", "text");
			attr_dev(input1, "id", "firstName");
			input1.required = true;

			attr_dev(input1, "placeholder", input1_placeholder_value = /*currentLang*/ ctx[3] === 'hu'
			? 'Adja meg keresztnevét'
			: 'Enter your first name');

			attr_dev(input1, "class", "svelte-nvslk4");
			add_location(input1, file$8, 44, 6, 1188);
			attr_dev(div1, "class", "form-group svelte-nvslk4");
			add_location(div1, file$8, 42, 4, 1062);
			attr_dev(div2, "class", "form-row svelte-nvslk4");
			add_location(div2, file$8, 27, 2, 584);
			attr_dev(label2, "for", "email");
			attr_dev(label2, "class", "svelte-nvslk4");
			add_location(label2, file$8, 59, 6, 1585);
			attr_dev(input2, "type", "email");
			attr_dev(input2, "id", "email");

			attr_dev(input2, "placeholder", input2_placeholder_value = /*currentLang*/ ctx[3] === 'hu'
			? 'Adja meg email címét'
			: 'Enter your email address');

			attr_dev(input2, "class", "svelte-nvslk4");
			add_location(input2, file$8, 60, 6, 1672);
			attr_dev(div3, "class", "form-group svelte-nvslk4");
			add_location(div3, file$8, 58, 4, 1554);
			attr_dev(label3, "for", "phone");
			attr_dev(label3, "class", "svelte-nvslk4");
			add_location(label3, file$8, 72, 6, 2005);
			attr_dev(input3, "type", "tel");
			attr_dev(input3, "id", "phone");
			input3.required = true;

			attr_dev(input3, "placeholder", input3_placeholder_value = /*currentLang*/ ctx[3] === 'hu'
			? 'Adja meg telefonszámát'
			: 'Enter your phone number');

			attr_dev(input3, "class", "svelte-nvslk4");
			add_location(input3, file$8, 73, 6, 2092);
			attr_dev(div4, "class", "form-group svelte-nvslk4");
			add_location(div4, file$8, 71, 4, 1974);
			attr_dev(div5, "class", "form-row svelte-nvslk4");
			add_location(div5, file$8, 57, 2, 1527);
			attr_dev(div6, "class", "form-section svelte-nvslk4");
			add_location(div6, file$8, 24, 0, 489);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div6, anchor);
			append_dev(div6, h3);
			append_dev(h3, t0);
			append_dev(div6, t1);
			append_dev(div6, div2);
			append_dev(div2, div0);
			append_dev(div0, label0);
			append_dev(label0, t2);
			append_dev(div0, t3);
			append_dev(div0, input0);
			set_input_value(input0, /*formData*/ ctx[0].lastName);
			append_dev(div0, t4);
			if (if_block0) if_block0.m(div0, null);
			append_dev(div2, t5);
			append_dev(div2, div1);
			append_dev(div1, label1);
			append_dev(label1, t6);
			append_dev(div1, t7);
			append_dev(div1, input1);
			set_input_value(input1, /*formData*/ ctx[0].firstName);
			append_dev(div1, t8);
			if (if_block1) if_block1.m(div1, null);
			append_dev(div6, t9);
			append_dev(div6, div5);
			append_dev(div5, div3);
			append_dev(div3, label2);
			append_dev(label2, t10);
			append_dev(div3, t11);
			append_dev(div3, input2);
			set_input_value(input2, /*formData*/ ctx[0].email);
			append_dev(div3, t12);
			if (if_block2) if_block2.m(div3, null);
			append_dev(div5, t13);
			append_dev(div5, div4);
			append_dev(div4, label3);
			append_dev(label3, t14);
			append_dev(div4, t15);
			append_dev(div4, input3);
			set_input_value(input3, /*formData*/ ctx[0].phone);
			append_dev(div4, t16);
			if (if_block3) if_block3.m(div4, null);

			if (!mounted) {
				dispose = [
					listen_dev(input0, "input", /*input0_input_handler*/ ctx[5]),
					listen_dev(input1, "input", /*input1_input_handler*/ ctx[6]),
					listen_dev(input2, "input", /*input2_input_handler*/ ctx[7]),
					listen_dev(input3, "input", /*input3_input_handler*/ ctx[8])
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*content, currentLang*/ 12 && t0_value !== (t0_value = /*content*/ ctx[2][/*currentLang*/ ctx[3]].bookingForm.personalInfo.title + "")) set_data_dev(t0, t0_value);
			if (dirty & /*content, currentLang*/ 12 && t2_value !== (t2_value = /*content*/ ctx[2][/*currentLang*/ ctx[3]].bookingForm.personalInfo.lastName + "")) set_data_dev(t2, t2_value);

			if (dirty & /*currentLang*/ 8 && input0_placeholder_value !== (input0_placeholder_value = /*currentLang*/ ctx[3] === 'hu'
			? 'Adja meg vezetéknevét'
			: 'Enter your last name')) {
				attr_dev(input0, "placeholder", input0_placeholder_value);
			}

			if (dirty & /*formData*/ 1 && input0.value !== /*formData*/ ctx[0].lastName) {
				set_input_value(input0, /*formData*/ ctx[0].lastName);
			}

			if (/*formErrors*/ ctx[1].lastName) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_3$5(ctx);
					if_block0.c();
					if_block0.m(div0, null);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (dirty & /*content, currentLang*/ 12 && t6_value !== (t6_value = /*content*/ ctx[2][/*currentLang*/ ctx[3]].bookingForm.personalInfo.firstName + "")) set_data_dev(t6, t6_value);

			if (dirty & /*currentLang*/ 8 && input1_placeholder_value !== (input1_placeholder_value = /*currentLang*/ ctx[3] === 'hu'
			? 'Adja meg keresztnevét'
			: 'Enter your first name')) {
				attr_dev(input1, "placeholder", input1_placeholder_value);
			}

			if (dirty & /*formData*/ 1 && input1.value !== /*formData*/ ctx[0].firstName) {
				set_input_value(input1, /*formData*/ ctx[0].firstName);
			}

			if (/*formErrors*/ ctx[1].firstName) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_2$7(ctx);
					if_block1.c();
					if_block1.m(div1, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (dirty & /*content, currentLang*/ 12 && t10_value !== (t10_value = /*content*/ ctx[2][/*currentLang*/ ctx[3]].bookingForm.personalInfo.email + "")) set_data_dev(t10, t10_value);

			if (dirty & /*currentLang*/ 8 && input2_placeholder_value !== (input2_placeholder_value = /*currentLang*/ ctx[3] === 'hu'
			? 'Adja meg email címét'
			: 'Enter your email address')) {
				attr_dev(input2, "placeholder", input2_placeholder_value);
			}

			if (dirty & /*formData*/ 1 && input2.value !== /*formData*/ ctx[0].email) {
				set_input_value(input2, /*formData*/ ctx[0].email);
			}

			if (/*formErrors*/ ctx[1].email) {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block_1$8(ctx);
					if_block2.c();
					if_block2.m(div3, null);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			if (dirty & /*content, currentLang*/ 12 && t14_value !== (t14_value = /*content*/ ctx[2][/*currentLang*/ ctx[3]].bookingForm.personalInfo.phone + "")) set_data_dev(t14, t14_value);

			if (dirty & /*currentLang*/ 8 && input3_placeholder_value !== (input3_placeholder_value = /*currentLang*/ ctx[3] === 'hu'
			? 'Adja meg telefonszámát'
			: 'Enter your phone number')) {
				attr_dev(input3, "placeholder", input3_placeholder_value);
			}

			if (dirty & /*formData*/ 1) {
				set_input_value(input3, /*formData*/ ctx[0].phone);
			}

			if (/*formErrors*/ ctx[1].phone) {
				if (if_block3) {
					if_block3.p(ctx, dirty);
				} else {
					if_block3 = create_if_block$8(ctx);
					if_block3.c();
					if_block3.m(div4, null);
				}
			} else if (if_block3) {
				if_block3.d(1);
				if_block3 = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div6);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			if (if_block3) if_block3.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$8.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$8($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('PersonalInfoForm', slots, []);

	let { formData = {
		firstName: '',
		lastName: '',
		email: '',
		phone: ''
	} } = $$props;

	let { formErrors = {
		firstName: '',
		lastName: '',
		email: '',
		phone: ''
	} } = $$props;

	let { content = {} } = $$props;
	let { currentLang = 'hu' } = $$props;
	const isSubmitting = false;
	const writable_props = ['formData', 'formErrors', 'content', 'currentLang'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<PersonalInfoForm> was created with unknown prop '${key}'`);
	});

	function input0_input_handler() {
		formData.lastName = this.value;
		$$invalidate(0, formData);
	}

	function input1_input_handler() {
		formData.firstName = this.value;
		$$invalidate(0, formData);
	}

	function input2_input_handler() {
		formData.email = this.value;
		$$invalidate(0, formData);
	}

	function input3_input_handler() {
		formData.phone = this.value;
		$$invalidate(0, formData);
	}

	$$self.$$set = $$props => {
		if ('formData' in $$props) $$invalidate(0, formData = $$props.formData);
		if ('formErrors' in $$props) $$invalidate(1, formErrors = $$props.formErrors);
		if ('content' in $$props) $$invalidate(2, content = $$props.content);
		if ('currentLang' in $$props) $$invalidate(3, currentLang = $$props.currentLang);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		LoadingSpinner,
		formData,
		formErrors,
		content,
		currentLang,
		isSubmitting
	});

	$$self.$inject_state = $$props => {
		if ('formData' in $$props) $$invalidate(0, formData = $$props.formData);
		if ('formErrors' in $$props) $$invalidate(1, formErrors = $$props.formErrors);
		if ('content' in $$props) $$invalidate(2, content = $$props.content);
		if ('currentLang' in $$props) $$invalidate(3, currentLang = $$props.currentLang);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		formData,
		formErrors,
		content,
		currentLang,
		isSubmitting,
		input0_input_handler,
		input1_input_handler,
		input2_input_handler,
		input3_input_handler
	];
}

class PersonalInfoForm extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$8, create_fragment$8, safe_not_equal, {
			formData: 0,
			formErrors: 1,
			content: 2,
			currentLang: 3,
			isSubmitting: 4
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "PersonalInfoForm",
			options,
			id: create_fragment$8.name
		});
	}

	get formData() {
		throw new Error("<PersonalInfoForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set formData(value) {
		throw new Error("<PersonalInfoForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get formErrors() {
		throw new Error("<PersonalInfoForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set formErrors(value) {
		throw new Error("<PersonalInfoForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get content() {
		throw new Error("<PersonalInfoForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set content(value) {
		throw new Error("<PersonalInfoForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get currentLang() {
		throw new Error("<PersonalInfoForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set currentLang(value) {
		throw new Error("<PersonalInfoForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isSubmitting() {
		return this.$$.ctx[4];
	}

	set isSubmitting(value) {
		throw new Error("<PersonalInfoForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/PriceCalculator.svelte generated by Svelte v3.59.2 */

const { console: console_1$4 } = globals;

const file$7 = "src/components/PriceCalculator.svelte";

// (166:4) {#if formData.carWashPackage !== 'none' && carWashStandardPrice > 0}
function create_if_block_1$7(ctx) {
	let p0;
	let span0;

	let t0_value = (/*currentLanguage*/ ctx[1] === 'hu'
	? 'Autómosó díj (alap)'
	: 'Car Wash Fee (Standard)') + "";

	let t0;
	let t1;
	let t2;
	let span1;
	let t3_value = /*formatCurrency*/ ctx[9](/*carWashStandardPrice*/ ctx[4]) + "";
	let t3;
	let t4;
	let t5;
	let p1;
	let span2;

	let t6_value = (/*currentLanguage*/ ctx[1] === 'hu'
	? 'Autómosó díj (kedvezményes)'
	: 'Car Wash Fee (Discounted)') + "";

	let t6;
	let t7;
	let t8;
	let span3;
	let t9_value = /*formatCurrency*/ ctx[9](/*carWashDiscountedPrice*/ ctx[6]) + "";
	let t9;
	let if_block = /*carWashDiscountAmount*/ ctx[5] > 0 && create_if_block_2$6(ctx);

	const block = {
		c: function create() {
			p0 = element("p");
			span0 = element("span");
			t0 = text(t0_value);
			t1 = text(":");
			t2 = space();
			span1 = element("span");
			t3 = text(t3_value);
			t4 = space();
			if (if_block) if_block.c();
			t5 = space();
			p1 = element("p");
			span2 = element("span");
			t6 = text(t6_value);
			t7 = text(":");
			t8 = space();
			span3 = element("span");
			t9 = text(t9_value);
			attr_dev(span0, "class", "svelte-7wej0u");
			add_location(span0, file$7, 167, 8, 6582);
			attr_dev(span1, "class", "svelte-7wej0u");
			add_location(span1, file$7, 168, 8, 6683);
			attr_dev(p0, "class", "car-wash-price svelte-7wej0u");
			add_location(p0, file$7, 166, 6, 6547);
			attr_dev(span2, "class", "svelte-7wej0u");
			add_location(span2, file$7, 177, 8, 7037);
			attr_dev(span3, "class", "svelte-7wej0u");
			add_location(span3, file$7, 178, 8, 7148);
			attr_dev(p1, "class", "svelte-7wej0u");
			add_location(p1, file$7, 176, 6, 7025);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p0, anchor);
			append_dev(p0, span0);
			append_dev(span0, t0);
			append_dev(span0, t1);
			append_dev(p0, t2);
			append_dev(p0, span1);
			append_dev(span1, t3);
			insert_dev(target, t4, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, t5, anchor);
			insert_dev(target, p1, anchor);
			append_dev(p1, span2);
			append_dev(span2, t6);
			append_dev(span2, t7);
			append_dev(p1, t8);
			append_dev(p1, span3);
			append_dev(span3, t9);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*currentLanguage*/ 2 && t0_value !== (t0_value = (/*currentLanguage*/ ctx[1] === 'hu'
			? 'Autómosó díj (alap)'
			: 'Car Wash Fee (Standard)') + "")) set_data_dev(t0, t0_value);

			if (dirty & /*carWashStandardPrice*/ 16 && t3_value !== (t3_value = /*formatCurrency*/ ctx[9](/*carWashStandardPrice*/ ctx[4]) + "")) set_data_dev(t3, t3_value);

			if (/*carWashDiscountAmount*/ ctx[5] > 0) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_2$6(ctx);
					if_block.c();
					if_block.m(t5.parentNode, t5);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*currentLanguage*/ 2 && t6_value !== (t6_value = (/*currentLanguage*/ ctx[1] === 'hu'
			? 'Autómosó díj (kedvezményes)'
			: 'Car Wash Fee (Discounted)') + "")) set_data_dev(t6, t6_value);

			if (dirty & /*carWashDiscountedPrice*/ 64 && t9_value !== (t9_value = /*formatCurrency*/ ctx[9](/*carWashDiscountedPrice*/ ctx[6]) + "")) set_data_dev(t9, t9_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(p0);
			if (detaching) detach_dev(t4);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(t5);
			if (detaching) detach_dev(p1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$7.name,
		type: "if",
		source: "(166:4) {#if formData.carWashPackage !== 'none' && carWashStandardPrice > 0}",
		ctx
	});

	return block;
}

// (171:6) {#if carWashDiscountAmount > 0}
function create_if_block_2$6(ctx) {
	let p;
	let span0;

	let t0_value = (/*currentLanguage*/ ctx[1] === 'hu'
	? 'Autómosó kedvezmény (20%)'
	: 'Car Wash Discount (20%)') + "";

	let t0;
	let t1;
	let t2;
	let span1;
	let t3;
	let t4_value = /*formatCurrency*/ ctx[9](/*carWashDiscountAmount*/ ctx[5]) + "";
	let t4;

	const block = {
		c: function create() {
			p = element("p");
			span0 = element("span");
			t0 = text(t0_value);
			t1 = text(":");
			t2 = space();
			span1 = element("span");
			t3 = text("- ");
			t4 = text(t4_value);
			attr_dev(span0, "class", "svelte-7wej0u");
			add_location(span0, file$7, 172, 10, 6806);
			set_style(span1, "color", "#e53e3e");
			attr_dev(span1, "class", "svelte-7wej0u");
			add_location(span1, file$7, 173, 10, 6915);
			attr_dev(p, "class", "svelte-7wej0u");
			add_location(p, file$7, 171, 8, 6792);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, span0);
			append_dev(span0, t0);
			append_dev(span0, t1);
			append_dev(p, t2);
			append_dev(p, span1);
			append_dev(span1, t3);
			append_dev(span1, t4);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*currentLanguage*/ 2 && t0_value !== (t0_value = (/*currentLanguage*/ ctx[1] === 'hu'
			? 'Autómosó kedvezmény (20%)'
			: 'Car Wash Discount (20%)') + "")) set_data_dev(t0, t0_value);

			if (dirty & /*carWashDiscountAmount*/ 32 && t4_value !== (t4_value = /*formatCurrency*/ ctx[9](/*carWashDiscountAmount*/ ctx[5]) + "")) set_data_dev(t4, t4_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$6.name,
		type: "if",
		source: "(171:6) {#if carWashDiscountAmount > 0}",
		ctx
	});

	return block;
}

// (188:4) {#if hasValidDates && currentDays <= 0}
function create_if_block$7(ctx) {
	let p;

	let t_value = (/*currentLanguage*/ ctx[1] === 'hu'
	? 'Érvénytelen dátum vagy időtartam. Kérjük, ellenőrizze az érkezési és távozási időpontokat.'
	: 'Invalid date or duration. Please check arrival and departure dates/times.') + "";

	let t;

	const block = {
		c: function create() {
			p = element("p");
			t = text(t_value);
			attr_dev(p, "class", "error-message svelte-7wej0u");
			set_style(p, "text-align", "center");
			set_style(p, "margin-top", "1rem");
			add_location(p, file$7, 188, 6, 7456);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*currentLanguage*/ 2 && t_value !== (t_value = (/*currentLanguage*/ ctx[1] === 'hu'
			? 'Érvénytelen dátum vagy időtartam. Kérjük, ellenőrizze az érkezési és távozási időpontokat.'
			: 'Invalid date or duration. Please check arrival and departure dates/times.') + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$7.name,
		type: "if",
		source: "(188:4) {#if hasValidDates && currentDays <= 0}",
		ctx
	});

	return block;
}

function create_fragment$7(ctx) {
	let div1;
	let div0;
	let p0;
	let span0;

	let t0_value = (/*currentLanguage*/ ctx[1] === 'hu'
	? 'Időtartam'
	: 'Duration') + "";

	let t0;
	let t1;
	let t2;
	let span1;
	let t3;
	let t4;
	let t5_value = (/*currentLanguage*/ ctx[1] === 'hu' ? 'nap' : 'days') + "";
	let t5;
	let t6;
	let p1;
	let span2;

	let t7_value = (/*currentLanguage*/ ctx[1] === 'hu'
	? 'Parkolás díj'
	: 'Parking Total') + "";

	let t7;
	let t8;
	let t9;
	let span3;
	let t10_value = /*formatCurrency*/ ctx[9](/*parkingTotal*/ ctx[3]) + "";
	let t10;
	let t11;
	let t12;
	let p2;
	let span4;

	let t13_value = (/*currentLanguage*/ ctx[1] === 'hu'
	? 'Végösszeg'
	: 'Total') + "";

	let t13;
	let t14;
	let t15;
	let span5;
	let t16_value = /*formatCurrency*/ ctx[9](/*totalPrice*/ ctx[7]) + "";
	let t16;
	let t17;
	let if_block0 = /*formData*/ ctx[0].carWashPackage !== 'none' && /*carWashStandardPrice*/ ctx[4] > 0 && create_if_block_1$7(ctx);
	let if_block1 = /*hasValidDates*/ ctx[8] && /*currentDays*/ ctx[2] <= 0 && create_if_block$7(ctx);

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			p0 = element("p");
			span0 = element("span");
			t0 = text(t0_value);
			t1 = text(":");
			t2 = space();
			span1 = element("span");
			t3 = text(/*currentDays*/ ctx[2]);
			t4 = space();
			t5 = text(t5_value);
			t6 = space();
			p1 = element("p");
			span2 = element("span");
			t7 = text(t7_value);
			t8 = text(":");
			t9 = space();
			span3 = element("span");
			t10 = text(t10_value);
			t11 = space();
			if (if_block0) if_block0.c();
			t12 = space();
			p2 = element("p");
			span4 = element("span");
			t13 = text(t13_value);
			t14 = text(":");
			t15 = space();
			span5 = element("span");
			t16 = text(t16_value);
			t17 = space();
			if (if_block1) if_block1.c();
			attr_dev(span0, "class", "svelte-7wej0u");
			add_location(span0, file$7, 156, 6, 6163);
			attr_dev(span1, "class", "svelte-7wej0u");
			add_location(span1, file$7, 157, 6, 6237);
			attr_dev(p0, "class", "svelte-7wej0u");
			add_location(p0, file$7, 155, 4, 6153);
			attr_dev(span2, "class", "svelte-7wej0u");
			add_location(span2, file$7, 161, 6, 6332);
			attr_dev(span3, "class", "svelte-7wej0u");
			add_location(span3, file$7, 162, 6, 6414);
			attr_dev(p1, "class", "svelte-7wej0u");
			add_location(p1, file$7, 160, 4, 6322);
			attr_dev(span4, "class", "svelte-7wej0u");
			add_location(span4, file$7, 183, 6, 7263);
			attr_dev(span5, "class", "total-price svelte-7wej0u");
			add_location(span5, file$7, 184, 6, 7334);
			attr_dev(p2, "class", "total-price-line svelte-7wej0u");
			add_location(p2, file$7, 182, 4, 7228);
			attr_dev(div0, "class", "price-calculation svelte-7wej0u");
			add_location(div0, file$7, 154, 2, 6117);
			attr_dev(div1, "class", "price-summary svelte-7wej0u");
			add_location(div1, file$7, 153, 0, 6087);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			append_dev(div0, p0);
			append_dev(p0, span0);
			append_dev(span0, t0);
			append_dev(span0, t1);
			append_dev(p0, t2);
			append_dev(p0, span1);
			append_dev(span1, t3);
			append_dev(span1, t4);
			append_dev(span1, t5);
			append_dev(div0, t6);
			append_dev(div0, p1);
			append_dev(p1, span2);
			append_dev(span2, t7);
			append_dev(span2, t8);
			append_dev(p1, t9);
			append_dev(p1, span3);
			append_dev(span3, t10);
			append_dev(div0, t11);
			if (if_block0) if_block0.m(div0, null);
			append_dev(div0, t12);
			append_dev(div0, p2);
			append_dev(p2, span4);
			append_dev(span4, t13);
			append_dev(span4, t14);
			append_dev(p2, t15);
			append_dev(p2, span5);
			append_dev(span5, t16);
			append_dev(div0, t17);
			if (if_block1) if_block1.m(div0, null);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*currentLanguage*/ 2 && t0_value !== (t0_value = (/*currentLanguage*/ ctx[1] === 'hu'
			? 'Időtartam'
			: 'Duration') + "")) set_data_dev(t0, t0_value);

			if (dirty & /*currentDays*/ 4) set_data_dev(t3, /*currentDays*/ ctx[2]);
			if (dirty & /*currentLanguage*/ 2 && t5_value !== (t5_value = (/*currentLanguage*/ ctx[1] === 'hu' ? 'nap' : 'days') + "")) set_data_dev(t5, t5_value);

			if (dirty & /*currentLanguage*/ 2 && t7_value !== (t7_value = (/*currentLanguage*/ ctx[1] === 'hu'
			? 'Parkolás díj'
			: 'Parking Total') + "")) set_data_dev(t7, t7_value);

			if (dirty & /*parkingTotal*/ 8 && t10_value !== (t10_value = /*formatCurrency*/ ctx[9](/*parkingTotal*/ ctx[3]) + "")) set_data_dev(t10, t10_value);

			if (/*formData*/ ctx[0].carWashPackage !== 'none' && /*carWashStandardPrice*/ ctx[4] > 0) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_1$7(ctx);
					if_block0.c();
					if_block0.m(div0, t12);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (dirty & /*currentLanguage*/ 2 && t13_value !== (t13_value = (/*currentLanguage*/ ctx[1] === 'hu'
			? 'Végösszeg'
			: 'Total') + "")) set_data_dev(t13, t13_value);

			if (dirty & /*totalPrice*/ 128 && t16_value !== (t16_value = /*formatCurrency*/ ctx[9](/*totalPrice*/ ctx[7]) + "")) set_data_dev(t16, t16_value);

			if (/*hasValidDates*/ ctx[8] && /*currentDays*/ ctx[2] <= 0) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block$7(ctx);
					if_block1.c();
					if_block1.m(div0, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$7.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$7($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('PriceCalculator', slots, []);

	let { formData = {
		// Default structure for safety
		startDate: null,
		endDate: null,
		startTime: null,
		endTime: null,
		carWashPackage: 'none'
	} } = $$props;

	let { calculateDays } = $$props;
	const content = {}; // Receive the content object from parent component

	// Get the currently selected language from the store, don't use a prop
	let currentLanguage;

	currentLang.subscribe(value => {
		$$invalidate(1, currentLanguage = value);
	});

	// --- Event Dispatcher ---
	const dispatch = createEventDispatcher();

	// --- Pricing Data (Hardcoded) ---
	const parkingPrices = [
		{ days: 1, normal: 7500, discount: 5500 },
		{ days: 2, normal: 8200, discount: 6200 },
		{ days: 3, normal: 9000, discount: 7000 },
		{ days: 4, normal: 9800, discount: 8000 },
		{ days: 5, normal: 10500, discount: 8600 },
		{ days: 6, normal: 11200, discount: 9500 },
		{ days: 7, normal: 12500, discount: 10500 },
		{ days: 8, normal: 14000, discount: 11000 },
		{ days: 9, normal: 15500, discount: 11500 },
		{ days: 10, normal: 16000, discount: 12000 },
		{ days: 11, normal: 17000, discount: 12400 },
		{ days: 12, normal: 17600, discount: 12900 },
		{ days: 13, normal: 18000, discount: 13500 },
		{ days: 14, normal: 18500, discount: 13900 },
		{ days: 15, normal: 19000, discount: 14300 },
		{ days: 16, normal: 19500, discount: 14700 },
		{ days: 17, normal: 20000, discount: 15000 },
		{ days: 18, normal: 20500, discount: 15400 },
		{ days: 19, normal: 21000, discount: 15800 },
		{ days: 20, normal: 21500, discount: 16200 },
		{ days: 21, normal: 22000, discount: 16600 },
		{ days: 22, normal: 22500, discount: 17000 },
		{ days: 23, normal: 23000, discount: 17400 },
		{ days: 24, normal: 23500, discount: 17800 },
		{ days: 25, normal: 24000, discount: 18200 },
		{ days: 26, normal: 24500, discount: 18600 },
		{ days: 27, normal: 25000, discount: 19000 },
		{ days: 28, normal: 25500, discount: 19500 },
		{ days: 29, normal: 26000, discount: 19500 },
		{ days: 30, normal: 26000, discount: 19500 }
	]; // Prices beyond 30 days use the 30-day price based on calculation logic

	const carWashPricing = {
		none: 0,
		smartInteriorExterior: 8900,
		premiumInteriorExterior: 11900
	};

	// --- Reactive Variables ---
	let currentDays = 0;

	let parkingTotal = 0;
	let carWashStandardPrice = 0;
	let carWashDiscountAmount = 0;
	let carWashDiscountedPrice = 0;
	let totalPrice = 0;
	let hasValidDates = false; // Tracks if date/time inputs have values

	// --- Dispatch Price Update ---
	function dispatchPriceUpdate() {
		// Ensure all values are numbers before dispatching
		const dataToDispatch = {
			parkingDays: currentDays,
			parkingTotal: parkingTotal || 0,
			carWashStandard: carWashStandardPrice || 0,
			carWashDiscount: carWashDiscountAmount || 0,
			carWashDiscounted: carWashDiscountedPrice || 0,
			totalPrice: totalPrice || 0,
			hasValidDates,
			isValidDuration: currentDays > 0, // Flag indicating calculated days > 0
			
		};

		dispatch('priceUpdated', dataToDispatch);
	}

	// --- Core Calculation Logic ---
	function calculatePrices() {
		// Calculate days using the function passed from the parent
		if (typeof calculateDays === 'function') {
			$$invalidate(2, currentDays = calculateDays());
		} else {
			$$invalidate(2, currentDays = 0);
			console.error("PriceCalculator: 'calculateDays' prop is not a function!");
		}

		// Check if essential date/time data is present
		$$invalidate(8, hasValidDates = !!(formData.startDate && formData.endDate && formData.startTime && formData.endTime));

		// Parking Total Calculation
		$$invalidate(3, parkingTotal = 0); // Reset

		if (currentDays > 0) {
			// Find the correct price tier, or use the last one if days exceed the defined tiers
			let priceTier = parkingPrices[Math.min(currentDays, parkingPrices.length) - 1];

			// Use the 'discount' price from the tier
			$$invalidate(3, parkingTotal = priceTier ? priceTier.discount : 0);
		} else {
			$$invalidate(3, parkingTotal = 0); // Explicitly zero if duration is not positive
		}

		// Car Wash Price Calculation
		const packageKey = formData.carWashPackage || 'none';

		$$invalidate(4, carWashStandardPrice = carWashPricing[packageKey] ?? 0); // Use nullish coalescing

		// Calculate discount only if a valid package is selected
		if (carWashStandardPrice > 0) {
			$$invalidate(5, carWashDiscountAmount = Math.round(carWashStandardPrice * 0.20)); // 20% discount
			$$invalidate(6, carWashDiscountedPrice = carWashStandardPrice - carWashDiscountAmount);
		} else {
			$$invalidate(5, carWashDiscountAmount = 0);
			$$invalidate(6, carWashDiscountedPrice = 0);
		}

		// Total Price Calculation
		$$invalidate(7, totalPrice = (parkingTotal || 0) + (carWashDiscountedPrice || 0));
	}

	// --- Lifecycle Hooks ---
	onMount(() => {
		// Perform initial calculation when component mounts
		calculatePrices();

		// Dispatch initial prices after the first calculation
		dispatchPriceUpdate();
	});

	// Use afterUpdate to ensure DOM is potentially updated *before* dispatching new prices.
	afterUpdate(() => {
		// The reactive block ($:) already calls calculatePrices.
		// We just need to dispatch the results after Svelte has processed updates.
		dispatchPriceUpdate();
	});

	// --- Formatting Function ---
	function formatCurrency(amount) {
		const numericAmount = typeof amount === 'number' ? amount : 0;

		// Format based on current language
		return new Intl.NumberFormat(currentLanguage === 'hu' ? 'hu-HU' : 'en-US',
		{
				style: 'currency',
				currency: 'HUF',
				minimumFractionDigits: 0,
				maximumFractionDigits: 0
			}).format(numericAmount);
	}

	$$self.$$.on_mount.push(function () {
		if (calculateDays === undefined && !('calculateDays' in $$props || $$self.$$.bound[$$self.$$.props['calculateDays']])) {
			console_1$4.warn("<PriceCalculator> was created without expected prop 'calculateDays'");
		}
	});

	const writable_props = ['formData', 'calculateDays'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$4.warn(`<PriceCalculator> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('formData' in $$props) $$invalidate(0, formData = $$props.formData);
		if ('calculateDays' in $$props) $$invalidate(10, calculateDays = $$props.calculateDays);
	};

	$$self.$capture_state = () => ({
		onMount,
		createEventDispatcher,
		afterUpdate,
		currentLang,
		formData,
		calculateDays,
		content,
		currentLanguage,
		dispatch,
		parkingPrices,
		carWashPricing,
		currentDays,
		parkingTotal,
		carWashStandardPrice,
		carWashDiscountAmount,
		carWashDiscountedPrice,
		totalPrice,
		hasValidDates,
		dispatchPriceUpdate,
		calculatePrices,
		formatCurrency
	});

	$$self.$inject_state = $$props => {
		if ('formData' in $$props) $$invalidate(0, formData = $$props.formData);
		if ('calculateDays' in $$props) $$invalidate(10, calculateDays = $$props.calculateDays);
		if ('currentLanguage' in $$props) $$invalidate(1, currentLanguage = $$props.currentLanguage);
		if ('currentDays' in $$props) $$invalidate(2, currentDays = $$props.currentDays);
		if ('parkingTotal' in $$props) $$invalidate(3, parkingTotal = $$props.parkingTotal);
		if ('carWashStandardPrice' in $$props) $$invalidate(4, carWashStandardPrice = $$props.carWashStandardPrice);
		if ('carWashDiscountAmount' in $$props) $$invalidate(5, carWashDiscountAmount = $$props.carWashDiscountAmount);
		if ('carWashDiscountedPrice' in $$props) $$invalidate(6, carWashDiscountedPrice = $$props.carWashDiscountedPrice);
		if ('totalPrice' in $$props) $$invalidate(7, totalPrice = $$props.totalPrice);
		if ('hasValidDates' in $$props) $$invalidate(8, hasValidDates = $$props.hasValidDates);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*formData, calculateDays*/ 1025) {
			// --- Reactivity ---
			// Recalculate whenever relevant formData or the language changes
			{
				// Check if formData and calculateDays exist before calculating
				if (formData && typeof calculateDays === 'function') {
					calculatePrices();
				}
			}
		}
	};

	return [
		formData,
		currentLanguage,
		currentDays,
		parkingTotal,
		carWashStandardPrice,
		carWashDiscountAmount,
		carWashDiscountedPrice,
		totalPrice,
		hasValidDates,
		formatCurrency,
		calculateDays,
		content
	];
}

class PriceCalculator extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$7, create_fragment$7, safe_not_equal, {
			formData: 0,
			calculateDays: 10,
			content: 11
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "PriceCalculator",
			options,
			id: create_fragment$7.name
		});
	}

	get formData() {
		throw new Error("<PriceCalculator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set formData(value) {
		throw new Error("<PriceCalculator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get calculateDays() {
		throw new Error("<PriceCalculator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set calculateDays(value) {
		throw new Error("<PriceCalculator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get content() {
		return this.$$.ctx[11];
	}

	set content(value) {
		throw new Error("<PriceCalculator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/AirportParkingForm.svelte generated by Svelte v3.59.2 */
const file$6 = "src/components/AirportParkingForm.svelte";

// (289:8) {#if formErrors.licensePlate}
function create_if_block_1$6(ctx) {
	let p;
	let t_value = /*formErrors*/ ctx[3].licensePlate + "";
	let t;

	const block = {
		c: function create() {
			p = element("p");
			t = text(t_value);
			attr_dev(p, "class", "error-message svelte-srk848");
			add_location(p, file$6, 289, 10, 8976);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*formErrors*/ 8 && t_value !== (t_value = /*formErrors*/ ctx[3].licensePlate + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$6.name,
		type: "if",
		source: "(289:8) {#if formErrors.licensePlate}",
		ctx
	});

	return block;
}

// (305:8) {#if formErrors.passengers}
function create_if_block$6(ctx) {
	let p;
	let t_value = /*formErrors*/ ctx[3].passengers + "";
	let t;

	const block = {
		c: function create() {
			p = element("p");
			t = text(t_value);
			attr_dev(p, "class", "error-message svelte-srk848");
			add_location(p, file$6, 305, 10, 9518);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*formErrors*/ 8 && t_value !== (t_value = /*formErrors*/ ctx[3].passengers + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$6.name,
		type: "if",
		source: "(305:8) {#if formErrors.passengers}",
		ctx
	});

	return block;
}

function create_fragment$6(ctx) {
	let form;
	let div12;
	let div0;
	let h30;
	let t0_value = /*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.airportParking.dateRange + "";
	let t0;
	let t1;
	let div3;
	let div1;
	let label0;
	let t2_value = /*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.airportParking.startDate + "";
	let t2;
	let t3;
	let input0;
	let t4;
	let div2;
	let label1;

	let t5_value = (/*currentLang*/ ctx[1] === 'hu'
	? 'Érkezési idő'
	: 'Arrival time') + "";

	let t5;
	let t6;
	let input1;
	let t7;
	let div6;
	let div4;
	let label2;
	let t8_value = /*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.airportParking.endDate + "";
	let t8;
	let t9;
	let input2;
	let input2_min_value;
	let t10;
	let div5;
	let label3;

	let t11_value = (/*currentLang*/ ctx[1] === 'hu'
	? 'Távozási idő'
	: 'Departure time') + "";

	let t11;
	let t12;
	let input3;
	let t13;
	let div9;
	let div7;
	let label4;
	let t14_value = /*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.airportParking.licensePlate + "";
	let t14;
	let t15;
	let input4;
	let input4_placeholder_value;
	let t16;
	let t17;
	let div8;
	let label5;
	let t18_value = /*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.airportParking.passengers + "";
	let t18;
	let t19;
	let input5;
	let input5_placeholder_value;
	let t20;
	let t21;
	let div11;
	let h31;
	let t22_value = /*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.airportParking.addCarWash + "";
	let t22;
	let t23;
	let div10;
	let label6;
	let t24_value = /*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.airportParking.carWashOptions.title + "";
	let t24;
	let t25;
	let select;
	let option0;
	let t26_value = /*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.airportParking.carWashOptions.none + "";
	let t26;
	let option1;
	let t27_value = /*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.airportParking.carWashOptions.smartInteriorExterior + "";
	let t27;
	let option2;
	let t28_value = /*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.airportParking.carWashOptions.premiumInteriorExterior + "";
	let t28;
	let t29;
	let pricecalculator;
	let t30;
	let personalinfoform;
	let updating_formData;
	let updating_formErrors;
	let t31;
	let div13;
	let button;

	let t32_value = (/*isSubmitting*/ ctx[4]
	? /*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.processing
	: /*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.submit) + "";

	let t32;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*formErrors*/ ctx[3].licensePlate && create_if_block_1$6(ctx);
	let if_block1 = /*formErrors*/ ctx[3].passengers && create_if_block$6(ctx);

	pricecalculator = new PriceCalculator({
			props: {
				formData: /*formData*/ ctx[2],
				calculateDays: /*calculateDays*/ ctx[7],
				content: /*content*/ ctx[0],
				currentLang: /*currentLang*/ ctx[1]
			},
			$$inline: true
		});

	pricecalculator.$on("priceUpdated", /*handlePriceUpdate*/ ctx[8]);

	function personalinfoform_formData_binding(value) {
		/*personalinfoform_formData_binding*/ ctx[17](value);
	}

	function personalinfoform_formErrors_binding(value) {
		/*personalinfoform_formErrors_binding*/ ctx[18](value);
	}

	let personalinfoform_props = {
		content: /*content*/ ctx[0],
		currentLang: /*currentLang*/ ctx[1]
	};

	if (/*formData*/ ctx[2] !== void 0) {
		personalinfoform_props.formData = /*formData*/ ctx[2];
	}

	if (/*formErrors*/ ctx[3] !== void 0) {
		personalinfoform_props.formErrors = /*formErrors*/ ctx[3];
	}

	personalinfoform = new PersonalInfoForm({
			props: personalinfoform_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(personalinfoform, 'formData', personalinfoform_formData_binding));
	binding_callbacks.push(() => bind(personalinfoform, 'formErrors', personalinfoform_formErrors_binding));

	const block = {
		c: function create() {
			form = element("form");
			div12 = element("div");
			div0 = element("div");
			h30 = element("h3");
			t0 = text(t0_value);
			t1 = space();
			div3 = element("div");
			div1 = element("div");
			label0 = element("label");
			t2 = text(t2_value);
			t3 = space();
			input0 = element("input");
			t4 = space();
			div2 = element("div");
			label1 = element("label");
			t5 = text(t5_value);
			t6 = space();
			input1 = element("input");
			t7 = space();
			div6 = element("div");
			div4 = element("div");
			label2 = element("label");
			t8 = text(t8_value);
			t9 = space();
			input2 = element("input");
			t10 = space();
			div5 = element("div");
			label3 = element("label");
			t11 = text(t11_value);
			t12 = space();
			input3 = element("input");
			t13 = space();
			div9 = element("div");
			div7 = element("div");
			label4 = element("label");
			t14 = text(t14_value);
			t15 = space();
			input4 = element("input");
			t16 = space();
			if (if_block0) if_block0.c();
			t17 = space();
			div8 = element("div");
			label5 = element("label");
			t18 = text(t18_value);
			t19 = space();
			input5 = element("input");
			t20 = space();
			if (if_block1) if_block1.c();
			t21 = space();
			div11 = element("div");
			h31 = element("h3");
			t22 = text(t22_value);
			t23 = space();
			div10 = element("div");
			label6 = element("label");
			t24 = text(t24_value);
			t25 = space();
			select = element("select");
			option0 = element("option");
			t26 = text(t26_value);
			option1 = element("option");
			t27 = text(t27_value);
			option2 = element("option");
			t28 = text(t28_value);
			t29 = space();
			create_component(pricecalculator.$$.fragment);
			t30 = space();
			create_component(personalinfoform.$$.fragment);
			t31 = space();
			div13 = element("div");
			button = element("button");
			t32 = text(t32_value);
			attr_dev(h30, "class", "svelte-srk848");
			add_location(h30, file$6, 227, 6, 7123);
			attr_dev(div0, "class", "form-row svelte-srk848");
			add_location(div0, file$6, 226, 4, 7094);
			attr_dev(label0, "for", "startDate");
			attr_dev(label0, "class", "svelte-srk848");
			add_location(label0, file$6, 232, 8, 7274);
			attr_dev(input0, "type", "date");
			attr_dev(input0, "id", "startDate");
			attr_dev(input0, "min", formatDate$1(/*today*/ ctx[5]));
			attr_dev(input0, "max", formatDate$1(/*maxDate*/ ctx[6]));
			input0.required = true;
			attr_dev(input0, "class", "svelte-srk848");
			add_location(input0, file$6, 233, 8, 7373);
			attr_dev(div1, "class", "form-group svelte-srk848");
			add_location(div1, file$6, 231, 6, 7241);
			attr_dev(label1, "for", "startTime");
			attr_dev(label1, "class", "svelte-srk848");
			add_location(label1, file$6, 244, 8, 7622);
			attr_dev(input1, "type", "time");
			attr_dev(input1, "id", "startTime");
			input1.required = true;
			attr_dev(input1, "class", "svelte-srk848");
			add_location(input1, file$6, 245, 8, 7718);
			attr_dev(div2, "class", "form-group svelte-srk848");
			add_location(div2, file$6, 243, 6, 7589);
			attr_dev(div3, "class", "form-row svelte-srk848");
			add_location(div3, file$6, 230, 4, 7212);
			attr_dev(label2, "for", "endDate");
			attr_dev(label2, "class", "svelte-srk848");
			add_location(label2, file$6, 256, 8, 7939);
			attr_dev(input2, "type", "date");
			attr_dev(input2, "id", "endDate");
			attr_dev(input2, "min", input2_min_value = /*formData*/ ctx[2].startDate);
			attr_dev(input2, "max", formatDate$1(/*maxDate*/ ctx[6]));
			input2.required = true;
			attr_dev(input2, "class", "svelte-srk848");
			add_location(input2, file$6, 257, 8, 8034);
			attr_dev(div4, "class", "form-group svelte-srk848");
			add_location(div4, file$6, 255, 6, 7906);
			attr_dev(label3, "for", "endTime");
			attr_dev(label3, "class", "svelte-srk848");
			add_location(label3, file$6, 268, 8, 8280);
			attr_dev(input3, "type", "time");
			attr_dev(input3, "id", "endTime");
			input3.required = true;
			attr_dev(input3, "class", "svelte-srk848");
			add_location(input3, file$6, 269, 8, 8376);
			attr_dev(div5, "class", "form-group svelte-srk848");
			add_location(div5, file$6, 267, 6, 8247);
			attr_dev(div6, "class", "form-row svelte-srk848");
			add_location(div6, file$6, 254, 4, 7877);
			attr_dev(label4, "for", "licensePlate");
			attr_dev(label4, "class", "svelte-srk848");
			add_location(label4, file$6, 280, 8, 8593);
			attr_dev(input4, "type", "text");
			attr_dev(input4, "id", "licensePlate");
			input4.required = true;

			attr_dev(input4, "placeholder", input4_placeholder_value = /*currentLang*/ ctx[1] === 'hu'
			? 'Adja meg rendszámát'
			: 'Enter your license plate');

			attr_dev(input4, "class", "svelte-srk848");
			add_location(input4, file$6, 281, 8, 8698);
			attr_dev(div7, "class", "form-group svelte-srk848");
			add_location(div7, file$6, 279, 6, 8560);
			attr_dev(label5, "for", "passengers");
			attr_dev(label5, "class", "svelte-srk848");
			add_location(label5, file$6, 294, 8, 9098);
			attr_dev(input5, "type", "number");
			attr_dev(input5, "id", "passengers");
			attr_dev(input5, "min", "1");
			attr_dev(input5, "max", "20");
			input5.required = true;

			attr_dev(input5, "placeholder", input5_placeholder_value = /*currentLang*/ ctx[1] === 'hu'
			? 'Adja meg az utasok számát'
			: 'Enter number of passengers');

			attr_dev(input5, "class", "svelte-srk848");
			add_location(input5, file$6, 295, 8, 9199);
			attr_dev(div8, "class", "form-group svelte-srk848");
			add_location(div8, file$6, 293, 6, 9065);
			attr_dev(div9, "class", "form-row svelte-srk848");
			add_location(div9, file$6, 278, 4, 8531);
			attr_dev(h31, "class", "svelte-srk848");
			add_location(h31, file$6, 311, 6, 9662);
			attr_dev(label6, "for", "carWashPackage");
			attr_dev(label6, "class", "svelte-srk848");
			add_location(label6, file$6, 314, 8, 9772);
			option0.__value = "none";
			option0.value = option0.__value;
			add_location(option0, file$6, 316, 10, 9963);
			option1.__value = "smartInteriorExterior";
			option1.value = option1.__value;
			add_location(option1, file$6, 317, 10, 10073);
			option2.__value = "premiumInteriorExterior";
			option2.value = option2.__value;
			add_location(option2, file$6, 318, 10, 10217);
			attr_dev(select, "id", "carWashPackage");
			attr_dev(select, "class", "svelte-srk848");
			if (/*formData*/ ctx[2].carWashPackage === void 0) add_render_callback(() => /*select_change_handler*/ ctx[16].call(select));
			add_location(select, file$6, 315, 8, 9887);
			attr_dev(div10, "class", "form-group svelte-srk848");
			add_location(div10, file$6, 313, 6, 9739);
			attr_dev(div11, "class", "form-row car-wash-addon svelte-srk848");
			add_location(div11, file$6, 310, 4, 9618);
			attr_dev(div12, "class", "form-section svelte-srk848");
			add_location(div12, file$6, 225, 2, 7063);
			attr_dev(button, "type", "submit");
			attr_dev(button, "class", "btn btn-primary svelte-srk848");
			button.disabled = /*isSubmitting*/ ctx[4];
			add_location(button, file$6, 342, 4, 10894);
			attr_dev(div13, "class", "form-submit svelte-srk848");
			add_location(div13, file$6, 341, 2, 10864);
			attr_dev(form, "class", "booking-form svelte-srk848");
			add_location(form, file$6, 224, 0, 6993);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, form, anchor);
			append_dev(form, div12);
			append_dev(div12, div0);
			append_dev(div0, h30);
			append_dev(h30, t0);
			append_dev(div12, t1);
			append_dev(div12, div3);
			append_dev(div3, div1);
			append_dev(div1, label0);
			append_dev(label0, t2);
			append_dev(div1, t3);
			append_dev(div1, input0);
			set_input_value(input0, /*formData*/ ctx[2].startDate);
			append_dev(div3, t4);
			append_dev(div3, div2);
			append_dev(div2, label1);
			append_dev(label1, t5);
			append_dev(div2, t6);
			append_dev(div2, input1);
			set_input_value(input1, /*formData*/ ctx[2].startTime);
			append_dev(div12, t7);
			append_dev(div12, div6);
			append_dev(div6, div4);
			append_dev(div4, label2);
			append_dev(label2, t8);
			append_dev(div4, t9);
			append_dev(div4, input2);
			set_input_value(input2, /*formData*/ ctx[2].endDate);
			append_dev(div6, t10);
			append_dev(div6, div5);
			append_dev(div5, label3);
			append_dev(label3, t11);
			append_dev(div5, t12);
			append_dev(div5, input3);
			set_input_value(input3, /*formData*/ ctx[2].endTime);
			append_dev(div12, t13);
			append_dev(div12, div9);
			append_dev(div9, div7);
			append_dev(div7, label4);
			append_dev(label4, t14);
			append_dev(div7, t15);
			append_dev(div7, input4);
			set_input_value(input4, /*formData*/ ctx[2].licensePlate);
			append_dev(div7, t16);
			if (if_block0) if_block0.m(div7, null);
			append_dev(div9, t17);
			append_dev(div9, div8);
			append_dev(div8, label5);
			append_dev(label5, t18);
			append_dev(div8, t19);
			append_dev(div8, input5);
			set_input_value(input5, /*formData*/ ctx[2].passengers);
			append_dev(div8, t20);
			if (if_block1) if_block1.m(div8, null);
			append_dev(div12, t21);
			append_dev(div12, div11);
			append_dev(div11, h31);
			append_dev(h31, t22);
			append_dev(div11, t23);
			append_dev(div11, div10);
			append_dev(div10, label6);
			append_dev(label6, t24);
			append_dev(div10, t25);
			append_dev(div10, select);
			append_dev(select, option0);
			append_dev(option0, t26);
			append_dev(select, option1);
			append_dev(option1, t27);
			append_dev(select, option2);
			append_dev(option2, t28);
			select_option(select, /*formData*/ ctx[2].carWashPackage, true);
			append_dev(div12, t29);
			mount_component(pricecalculator, div12, null);
			append_dev(form, t30);
			mount_component(personalinfoform, form, null);
			append_dev(form, t31);
			append_dev(form, div13);
			append_dev(div13, button);
			append_dev(button, t32);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(input0, "input", /*input0_input_handler*/ ctx[10]),
					listen_dev(input1, "input", /*input1_input_handler*/ ctx[11]),
					listen_dev(input2, "input", /*input2_input_handler*/ ctx[12]),
					listen_dev(input3, "input", /*input3_input_handler*/ ctx[13]),
					listen_dev(input4, "input", /*input4_input_handler*/ ctx[14]),
					listen_dev(input5, "input", /*input5_input_handler*/ ctx[15]),
					listen_dev(select, "change", /*select_change_handler*/ ctx[16]),
					listen_dev(form, "submit", prevent_default(/*handleSubmit*/ ctx[9]), false, true, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if ((!current || dirty & /*content, currentLang*/ 3) && t0_value !== (t0_value = /*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.airportParking.dateRange + "")) set_data_dev(t0, t0_value);
			if ((!current || dirty & /*content, currentLang*/ 3) && t2_value !== (t2_value = /*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.airportParking.startDate + "")) set_data_dev(t2, t2_value);

			if (dirty & /*formData*/ 4) {
				set_input_value(input0, /*formData*/ ctx[2].startDate);
			}

			if ((!current || dirty & /*currentLang*/ 2) && t5_value !== (t5_value = (/*currentLang*/ ctx[1] === 'hu'
			? 'Érkezési idő'
			: 'Arrival time') + "")) set_data_dev(t5, t5_value);

			if (dirty & /*formData*/ 4) {
				set_input_value(input1, /*formData*/ ctx[2].startTime);
			}

			if ((!current || dirty & /*content, currentLang*/ 3) && t8_value !== (t8_value = /*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.airportParking.endDate + "")) set_data_dev(t8, t8_value);

			if (!current || dirty & /*formData*/ 4 && input2_min_value !== (input2_min_value = /*formData*/ ctx[2].startDate)) {
				attr_dev(input2, "min", input2_min_value);
			}

			if (dirty & /*formData*/ 4) {
				set_input_value(input2, /*formData*/ ctx[2].endDate);
			}

			if ((!current || dirty & /*currentLang*/ 2) && t11_value !== (t11_value = (/*currentLang*/ ctx[1] === 'hu'
			? 'Távozási idő'
			: 'Departure time') + "")) set_data_dev(t11, t11_value);

			if (dirty & /*formData*/ 4) {
				set_input_value(input3, /*formData*/ ctx[2].endTime);
			}

			if ((!current || dirty & /*content, currentLang*/ 3) && t14_value !== (t14_value = /*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.airportParking.licensePlate + "")) set_data_dev(t14, t14_value);

			if (!current || dirty & /*currentLang*/ 2 && input4_placeholder_value !== (input4_placeholder_value = /*currentLang*/ ctx[1] === 'hu'
			? 'Adja meg rendszámát'
			: 'Enter your license plate')) {
				attr_dev(input4, "placeholder", input4_placeholder_value);
			}

			if (dirty & /*formData*/ 4 && input4.value !== /*formData*/ ctx[2].licensePlate) {
				set_input_value(input4, /*formData*/ ctx[2].licensePlate);
			}

			if (/*formErrors*/ ctx[3].licensePlate) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_1$6(ctx);
					if_block0.c();
					if_block0.m(div7, null);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if ((!current || dirty & /*content, currentLang*/ 3) && t18_value !== (t18_value = /*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.airportParking.passengers + "")) set_data_dev(t18, t18_value);

			if (!current || dirty & /*currentLang*/ 2 && input5_placeholder_value !== (input5_placeholder_value = /*currentLang*/ ctx[1] === 'hu'
			? 'Adja meg az utasok számát'
			: 'Enter number of passengers')) {
				attr_dev(input5, "placeholder", input5_placeholder_value);
			}

			if (dirty & /*formData*/ 4 && to_number(input5.value) !== /*formData*/ ctx[2].passengers) {
				set_input_value(input5, /*formData*/ ctx[2].passengers);
			}

			if (/*formErrors*/ ctx[3].passengers) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block$6(ctx);
					if_block1.c();
					if_block1.m(div8, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if ((!current || dirty & /*content, currentLang*/ 3) && t22_value !== (t22_value = /*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.airportParking.addCarWash + "")) set_data_dev(t22, t22_value);
			if ((!current || dirty & /*content, currentLang*/ 3) && t24_value !== (t24_value = /*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.airportParking.carWashOptions.title + "")) set_data_dev(t24, t24_value);
			if ((!current || dirty & /*content, currentLang*/ 3) && t26_value !== (t26_value = /*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.airportParking.carWashOptions.none + "")) set_data_dev(t26, t26_value);
			if ((!current || dirty & /*content, currentLang*/ 3) && t27_value !== (t27_value = /*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.airportParking.carWashOptions.smartInteriorExterior + "")) set_data_dev(t27, t27_value);
			if ((!current || dirty & /*content, currentLang*/ 3) && t28_value !== (t28_value = /*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.airportParking.carWashOptions.premiumInteriorExterior + "")) set_data_dev(t28, t28_value);

			if (dirty & /*formData*/ 4) {
				select_option(select, /*formData*/ ctx[2].carWashPackage);
			}

			const pricecalculator_changes = {};
			if (dirty & /*formData*/ 4) pricecalculator_changes.formData = /*formData*/ ctx[2];
			if (dirty & /*content*/ 1) pricecalculator_changes.content = /*content*/ ctx[0];
			if (dirty & /*currentLang*/ 2) pricecalculator_changes.currentLang = /*currentLang*/ ctx[1];
			pricecalculator.$set(pricecalculator_changes);
			const personalinfoform_changes = {};
			if (dirty & /*content*/ 1) personalinfoform_changes.content = /*content*/ ctx[0];
			if (dirty & /*currentLang*/ 2) personalinfoform_changes.currentLang = /*currentLang*/ ctx[1];

			if (!updating_formData && dirty & /*formData*/ 4) {
				updating_formData = true;
				personalinfoform_changes.formData = /*formData*/ ctx[2];
				add_flush_callback(() => updating_formData = false);
			}

			if (!updating_formErrors && dirty & /*formErrors*/ 8) {
				updating_formErrors = true;
				personalinfoform_changes.formErrors = /*formErrors*/ ctx[3];
				add_flush_callback(() => updating_formErrors = false);
			}

			personalinfoform.$set(personalinfoform_changes);

			if ((!current || dirty & /*isSubmitting, content, currentLang*/ 19) && t32_value !== (t32_value = (/*isSubmitting*/ ctx[4]
			? /*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.processing
			: /*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.submit) + "")) set_data_dev(t32, t32_value);

			if (!current || dirty & /*isSubmitting*/ 16) {
				prop_dev(button, "disabled", /*isSubmitting*/ ctx[4]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(pricecalculator.$$.fragment, local);
			transition_in(personalinfoform.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(pricecalculator.$$.fragment, local);
			transition_out(personalinfoform.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(form);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			destroy_component(pricecalculator);
			destroy_component(personalinfoform);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$6.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function formatDate$1(date) {
	const d = new Date(date);
	let month = '' + (d.getMonth() + 1);
	let day = '' + d.getDate();
	const year = d.getFullYear();
	if (month.length < 2) month = '0' + month;
	if (day.length < 2) day = '0' + day;
	return [year, month, day].join('-');
}

function parseDate(dateString) {
	const [year, month, day] = dateString.split('-').map(Number);
	return new Date(Date.UTC(year, month - 1, day));
}

function instance$6($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('AirportParkingForm', slots, []);
	let { content = {} } = $$props;
	let { currentLang = 'hu' } = $$props;

	// Initialize event dispatcher
	const dispatch = createEventDispatcher();

	// Calendar data
	const today = new Date();

	const maxDate = new Date();
	maxDate.setMonth(maxDate.getMonth() + 3); // Allow bookings 3 months in advance

	// Form data
	let formData = {
		// Airport parking specific
		startDate: formatDate$1(today),
		startTime: '12:00',
		endDate: formatDate$1(today),
		endTime: '12:00',
		licensePlate: '',
		passengers: '1',
		carWashPackage: 'none',
		// Personal info (will be bound from PersonalInfoForm)
		firstName: '',
		lastName: '',
		email: '',
		phone: ''
	};

	// Form validation
	let formErrors = {
		licensePlate: '',
		passengers: '',
		firstName: '',
		lastName: '',
		email: '',
		phone: ''
	};

	let isSubmitting = false;

	// Price calculation data - this will be updated by the PriceCalculator component
	let calculatedPrices = {
		parkingDays: 0,
		parkingTotal: 0,
		carWashStandard: 0,
		carWashDiscount: 0,
		carWashDiscounted: 0,
		totalPrice: 0
	};

	// Calculate days correctly considering arrival/departure times
	function calculateDays() {
		if (!formData.startDate || !formData.endDate || !formData.startTime || !formData.endTime) return 0;

		// Parse dates and times in a consistent manner (e.g., as UTC)
		const start = new Date(`${formData.startDate}T${formData.startTime}:00Z`);

		const end = new Date(`${formData.endDate}T${formData.endTime}:00Z`);

		// Handle edge cases and validation
		if (end <= start) {
			if (formData.startDate === formData.endDate && formData.startTime >= formData.endTime) {
				const todayStart = new Date(Date.UTC(today.getFullYear(), today.getMonth(), today.getDate(), 0, 0, 0));
				if (start >= todayStart) return 1;
				return 0;
			}

			if (parseDate(formData.endDate) < parseDate(formData.startDate)) {
				return 0;
			}
		}

		const diffMilliseconds = end - start;
		const diffHours = diffMilliseconds / (1000 * 60 * 60);
		const days = Math.ceil(diffHours / 24);

		// Ensure minimum 1 day if valid
		const todayStart = new Date(Date.UTC(today.getFullYear(), today.getMonth(), today.getDate(), 0, 0, 0));

		if (days <= 0 && end > start && start >= todayStart) {
			return 1;
		}

		return days > 0 ? days : 0;
	}

	// Form validation function
	function validateForm() {
		let isValid = true;

		// Reset specific errors
		$$invalidate(3, formErrors.licensePlate = '', formErrors);

		$$invalidate(3, formErrors.passengers = '', formErrors);

		// Validate service-specific fields
		if (!formData.licensePlate.trim()) {
			$$invalidate(3, formErrors.licensePlate = content[currentLang].bookingForm.airportParking.licensePlateRequired, formErrors);
			isValid = false;
		}

		// Validate passengers is a number and within range
		const numPassengers = parseInt(formData.passengers);

		if (isNaN(numPassengers) || numPassengers < 1 || numPassengers > 20) {
			$$invalidate(3, formErrors.passengers = content[currentLang].bookingForm.airportParking.passengersRequired, formErrors);
			isValid = false;
		}

		// Basic validation for date range
		const startDateTime = new Date(`${formData.startDate}T${formData.startTime}:00Z`);

		const endDateTime = new Date(`${formData.endDate}T${formData.endTime}:00Z`);
		const todayStart = new Date(Date.UTC(today.getFullYear(), today.getMonth(), today.getDate(), 0, 0, 0));

		// Ensure start date is not in the past
		if (startDateTime < todayStart) {
			isValid = false;
		}

		// Ensure end date/time is not before start date/time
		if (endDateTime < startDateTime) {
			isValid = false;
		}

		// Ensure at least one day is booked
		if (calculateDays() <= 0 && startDateTime < endDateTime) {
			isValid = false;
		}

		return isValid;
	}

	// This function will be called when the PriceCalculator updates prices
	function handlePriceUpdate(event) {
		calculatedPrices = event.detail;
	}

	// Handle form submission
	function handleSubmit() {
		if (!validateForm()) {
			// Scroll to the first error message if validation fails
			setTimeout(
				() => {
					const firstError = document.querySelector('.error-message');

					if (firstError) {
						firstError.scrollIntoView({ behavior: 'smooth', block: 'center' });
					}
				},
				50
			);

			return;
		}

		$$invalidate(4, isSubmitting = true);

		// Simulate API call
		setTimeout(
			() => {
				// Create booking details object to pass to the parent component
				const bookingDetails = {
					service: 'airportParking',
					name: `${formData.lastName} ${formData.firstName}`,
					contact: {
						email: formData.email,
						phone: formData.phone
					},
					date: `${formData.startDate} ${formData.startTime} - ${formData.endDate} ${formData.endTime}`,
					days: calculatedPrices.parkingDays,
					licensePlate: formData.licensePlate,
					passengers: formData.passengers
				};

				// For car wash package, if selected
				if (formData.carWashPackage !== 'none') {
					bookingDetails.carWashPackage = formData.carWashPackage;
					bookingDetails.carWashPackageName = content[currentLang].bookingForm.airportParking.carWashOptions[formData.carWashPackage];

					// Use the calculated prices from the PriceCalculator
					bookingDetails.priceBreakdown = {
						parkingTotal: calculatedPrices.parkingTotal,
						carWashStandard: calculatedPrices.carWashStandard,
						carWashDiscount: calculatedPrices.carWashDiscount,
						carWashDiscounted: calculatedPrices.carWashDiscounted
					};

					bookingDetails.totalPrice = calculatedPrices.totalPrice;
				} else {
					// Only parking, no car wash - still use calculated price
					bookingDetails.priceBreakdown = {
						parkingTotal: calculatedPrices.parkingTotal,
						carWashStandard: 0,
						carWashDiscount: 0,
						carWashDiscounted: 0
					};

					bookingDetails.totalPrice = calculatedPrices.totalPrice;
				}

				$$invalidate(4, isSubmitting = false);

				// Dispatch event to notify parent component
				dispatch('bookingComplete', bookingDetails);
			},
			1500
		);
	}

	const writable_props = ['content', 'currentLang'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<AirportParkingForm> was created with unknown prop '${key}'`);
	});

	function input0_input_handler() {
		formData.startDate = this.value;
		$$invalidate(2, formData);
	}

	function input1_input_handler() {
		formData.startTime = this.value;
		$$invalidate(2, formData);
	}

	function input2_input_handler() {
		formData.endDate = this.value;
		$$invalidate(2, formData);
	}

	function input3_input_handler() {
		formData.endTime = this.value;
		$$invalidate(2, formData);
	}

	function input4_input_handler() {
		formData.licensePlate = this.value;
		$$invalidate(2, formData);
	}

	function input5_input_handler() {
		formData.passengers = to_number(this.value);
		$$invalidate(2, formData);
	}

	function select_change_handler() {
		formData.carWashPackage = select_value(this);
		$$invalidate(2, formData);
	}

	function personalinfoform_formData_binding(value) {
		formData = value;
		$$invalidate(2, formData);
	}

	function personalinfoform_formErrors_binding(value) {
		formErrors = value;
		$$invalidate(3, formErrors);
	}

	$$self.$$set = $$props => {
		if ('content' in $$props) $$invalidate(0, content = $$props.content);
		if ('currentLang' in $$props) $$invalidate(1, currentLang = $$props.currentLang);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		PersonalInfoForm,
		PriceCalculator,
		content,
		currentLang,
		dispatch,
		today,
		maxDate,
		formData,
		formErrors,
		isSubmitting,
		calculatedPrices,
		formatDate: formatDate$1,
		parseDate,
		calculateDays,
		validateForm,
		handlePriceUpdate,
		handleSubmit
	});

	$$self.$inject_state = $$props => {
		if ('content' in $$props) $$invalidate(0, content = $$props.content);
		if ('currentLang' in $$props) $$invalidate(1, currentLang = $$props.currentLang);
		if ('formData' in $$props) $$invalidate(2, formData = $$props.formData);
		if ('formErrors' in $$props) $$invalidate(3, formErrors = $$props.formErrors);
		if ('isSubmitting' in $$props) $$invalidate(4, isSubmitting = $$props.isSubmitting);
		if ('calculatedPrices' in $$props) calculatedPrices = $$props.calculatedPrices;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		content,
		currentLang,
		formData,
		formErrors,
		isSubmitting,
		today,
		maxDate,
		calculateDays,
		handlePriceUpdate,
		handleSubmit,
		input0_input_handler,
		input1_input_handler,
		input2_input_handler,
		input3_input_handler,
		input4_input_handler,
		input5_input_handler,
		select_change_handler,
		personalinfoform_formData_binding,
		personalinfoform_formErrors_binding
	];
}

class AirportParkingForm extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$6, create_fragment$6, safe_not_equal, { content: 0, currentLang: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "AirportParkingForm",
			options,
			id: create_fragment$6.name
		});
	}

	get content() {
		throw new Error("<AirportParkingForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set content(value) {
		throw new Error("<AirportParkingForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get currentLang() {
		throw new Error("<AirportParkingForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set currentLang(value) {
		throw new Error("<AirportParkingForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/TimeSlotSelector.svelte generated by Svelte v3.59.2 */

const { console: console_1$3 } = globals;
const file$5 = "src/components/TimeSlotSelector.svelte";

function get_each_context$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[20] = list[i];
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[20] = list[i];
	return child_ctx;
}

// (270:2) {:else}
function create_else_block$5(ctx) {
	let t0;
	let div2;
	let div0;
	let h50;
	let t1_value = (/*content*/ ctx[1]?.[/*currentLang*/ ctx[2]]?.bookingForm?.timeSlots?.morning || (/*currentLang*/ ctx[2] === 'hu' ? 'Délelőtt' : 'Morning')) + "";
	let t1;
	let t2;
	let t3;
	let div1;
	let h51;

	let t4_value = (/*content*/ ctx[1]?.[/*currentLang*/ ctx[2]]?.bookingForm?.timeSlots?.afternoon || (/*currentLang*/ ctx[2] === 'hu'
	? 'Délután'
	: 'Afternoon')) + "";

	let t4;
	let t5;
	let t6;
	let div6;
	let div3;
	let span0;
	let t7;
	let span1;

	let t8_value = (/*content*/ ctx[1]?.[/*currentLang*/ ctx[2]]?.bookingForm?.legend?.available || (/*currentLang*/ ctx[2] === 'hu'
	? 'Elérhető'
	: 'Available')) + "";

	let t8;
	let t9;
	let div4;
	let span2;
	let t10;
	let span3;

	let t11_value = (/*content*/ ctx[1]?.[/*currentLang*/ ctx[2]]?.bookingForm?.legend?.unavailable || (/*currentLang*/ ctx[2] === 'hu'
	? 'Foglalt'
	: 'Unavailable')) + "";

	let t11;
	let t12;
	let div5;
	let span4;
	let t13;
	let span5;

	let t14_value = (/*content*/ ctx[1]?.[/*currentLang*/ ctx[2]]?.bookingForm?.legend?.selected || (/*currentLang*/ ctx[2] === 'hu'
	? 'Kiválasztott'
	: 'Selected')) + "";

	let t14;
	let if_block0 = /*errorFetching*/ ctx[8] && create_if_block_8$2(ctx);

	function select_block_type_1(ctx, dirty) {
		if (/*displayableMorningSlots*/ ctx[9].length === 0) return create_if_block_6$2;
		return create_else_block_3;
	}

	let current_block_type = select_block_type_1(ctx);
	let if_block1 = current_block_type(ctx);

	function select_block_type_3(ctx, dirty) {
		if (/*displayableAfternoonSlots*/ ctx[10].length === 0) return create_if_block_4$4;
		return create_else_block_1$1;
	}

	let current_block_type_1 = select_block_type_3(ctx);
	let if_block2 = current_block_type_1(ctx);

	const block = {
		c: function create() {
			if (if_block0) if_block0.c();
			t0 = space();
			div2 = element("div");
			div0 = element("div");
			h50 = element("h5");
			t1 = text(t1_value);
			t2 = space();
			if_block1.c();
			t3 = space();
			div1 = element("div");
			h51 = element("h5");
			t4 = text(t4_value);
			t5 = space();
			if_block2.c();
			t6 = space();
			div6 = element("div");
			div3 = element("div");
			span0 = element("span");
			t7 = space();
			span1 = element("span");
			t8 = text(t8_value);
			t9 = space();
			div4 = element("div");
			span2 = element("span");
			t10 = space();
			span3 = element("span");
			t11 = text(t11_value);
			t12 = space();
			div5 = element("div");
			span4 = element("span");
			t13 = space();
			span5 = element("span");
			t14 = text(t14_value);
			attr_dev(h50, "class", "svelte-xhyfm");
			add_location(h50, file$5, 277, 8, 10983);
			attr_dev(div0, "class", "time-slot-group svelte-xhyfm");
			add_location(div0, file$5, 276, 6, 10945);
			attr_dev(h51, "class", "svelte-xhyfm");
			add_location(h51, file$5, 304, 9, 12274);
			attr_dev(div1, "class", "time-slot-group svelte-xhyfm");
			add_location(div1, file$5, 303, 6, 12235);
			attr_dev(div2, "class", "time-slots-container svelte-xhyfm");
			add_location(div2, file$5, 275, 4, 10904);
			attr_dev(span0, "class", "legend-indicator available-indicator svelte-xhyfm");
			add_location(span0, file$5, 333, 8, 13605);
			add_location(span1, file$5, 334, 8, 13672);
			attr_dev(div3, "class", "legend-item svelte-xhyfm");
			add_location(div3, file$5, 332, 6, 13571);
			attr_dev(span2, "class", "legend-indicator unavailable-indicator svelte-xhyfm");
			add_location(span2, file$5, 337, 8, 13848);
			add_location(span3, file$5, 338, 8, 13917);
			attr_dev(div4, "class", "legend-item svelte-xhyfm");
			add_location(div4, file$5, 336, 6, 13814);
			attr_dev(span4, "class", "legend-indicator selected-indicator svelte-xhyfm");
			add_location(span4, file$5, 341, 8, 14096);
			add_location(span5, file$5, 342, 8, 14162);
			attr_dev(div5, "class", "legend-item svelte-xhyfm");
			add_location(div5, file$5, 340, 6, 14062);
			attr_dev(div6, "class", "legend svelte-xhyfm");
			add_location(div6, file$5, 331, 4, 13544);
		},
		m: function mount(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, div2, anchor);
			append_dev(div2, div0);
			append_dev(div0, h50);
			append_dev(h50, t1);
			append_dev(div0, t2);
			if_block1.m(div0, null);
			append_dev(div2, t3);
			append_dev(div2, div1);
			append_dev(div1, h51);
			append_dev(h51, t4);
			append_dev(div1, t5);
			if_block2.m(div1, null);
			insert_dev(target, t6, anchor);
			insert_dev(target, div6, anchor);
			append_dev(div6, div3);
			append_dev(div3, span0);
			append_dev(div3, t7);
			append_dev(div3, span1);
			append_dev(span1, t8);
			append_dev(div6, t9);
			append_dev(div6, div4);
			append_dev(div4, span2);
			append_dev(div4, t10);
			append_dev(div4, span3);
			append_dev(span3, t11);
			append_dev(div6, t12);
			append_dev(div6, div5);
			append_dev(div5, span4);
			append_dev(div5, t13);
			append_dev(div5, span5);
			append_dev(span5, t14);
		},
		p: function update(ctx, dirty) {
			if (/*errorFetching*/ ctx[8]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_8$2(ctx);
					if_block0.c();
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (dirty & /*content, currentLang*/ 6 && t1_value !== (t1_value = (/*content*/ ctx[1]?.[/*currentLang*/ ctx[2]]?.bookingForm?.timeSlots?.morning || (/*currentLang*/ ctx[2] === 'hu' ? 'Délelőtt' : 'Morning')) + "")) set_data_dev(t1, t1_value);

			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block1) {
				if_block1.p(ctx, dirty);
			} else {
				if_block1.d(1);
				if_block1 = current_block_type(ctx);

				if (if_block1) {
					if_block1.c();
					if_block1.m(div0, null);
				}
			}

			if (dirty & /*content, currentLang*/ 6 && t4_value !== (t4_value = (/*content*/ ctx[1]?.[/*currentLang*/ ctx[2]]?.bookingForm?.timeSlots?.afternoon || (/*currentLang*/ ctx[2] === 'hu'
			? 'Délután'
			: 'Afternoon')) + "")) set_data_dev(t4, t4_value);

			if (current_block_type_1 === (current_block_type_1 = select_block_type_3(ctx)) && if_block2) {
				if_block2.p(ctx, dirty);
			} else {
				if_block2.d(1);
				if_block2 = current_block_type_1(ctx);

				if (if_block2) {
					if_block2.c();
					if_block2.m(div1, null);
				}
			}

			if (dirty & /*content, currentLang*/ 6 && t8_value !== (t8_value = (/*content*/ ctx[1]?.[/*currentLang*/ ctx[2]]?.bookingForm?.legend?.available || (/*currentLang*/ ctx[2] === 'hu'
			? 'Elérhető'
			: 'Available')) + "")) set_data_dev(t8, t8_value);

			if (dirty & /*content, currentLang*/ 6 && t11_value !== (t11_value = (/*content*/ ctx[1]?.[/*currentLang*/ ctx[2]]?.bookingForm?.legend?.unavailable || (/*currentLang*/ ctx[2] === 'hu'
			? 'Foglalt'
			: 'Unavailable')) + "")) set_data_dev(t11, t11_value);

			if (dirty & /*content, currentLang*/ 6 && t14_value !== (t14_value = (/*content*/ ctx[1]?.[/*currentLang*/ ctx[2]]?.bookingForm?.legend?.selected || (/*currentLang*/ ctx[2] === 'hu'
			? 'Kiválasztott'
			: 'Selected')) + "")) set_data_dev(t14, t14_value);
		},
		d: function destroy(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(div2);
			if_block1.d();
			if_block2.d();
			if (detaching) detach_dev(t6);
			if (detaching) detach_dev(div6);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$5.name,
		type: "else",
		source: "(270:2) {:else}",
		ctx
	});

	return block;
}

// (263:58) 
function create_if_block_3$4(ctx) {
	let div;
	let span;
	let t0;
	let t1;
	let button;

	let t2_value = (/*currentLang*/ ctx[2] === 'hu'
	? 'Újra próbál'
	: 'Try again') + "";

	let t2;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div = element("div");
			span = element("span");
			t0 = text(/*errorFetching*/ ctx[8]);
			t1 = space();
			button = element("button");
			t2 = text(t2_value);
			add_location(span, file$5, 264, 7, 10571);
			attr_dev(button, "type", "button");
			attr_dev(button, "class", "retry-button svelte-xhyfm");
			add_location(button, file$5, 265, 7, 10607);
			attr_dev(div, "class", "error-indicator svelte-xhyfm");
			add_location(div, file$5, 263, 4, 10534);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, span);
			append_dev(span, t0);
			append_dev(div, t1);
			append_dev(div, button);
			append_dev(button, t2);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*fetchAvailableSlots*/ ctx[11], false, false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*errorFetching*/ 256) set_data_dev(t0, /*errorFetching*/ ctx[8]);

			if (dirty & /*currentLang*/ 4 && t2_value !== (t2_value = (/*currentLang*/ ctx[2] === 'hu'
			? 'Újra próbál'
			: 'Try again') + "")) set_data_dev(t2, t2_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3$4.name,
		type: "if",
		source: "(263:58) ",
		ctx
	});

	return block;
}

// (258:22) 
function create_if_block_2$5(ctx) {
	let div1;
	let div0;
	let t0;
	let span;

	let t1_value = (/*currentLang*/ ctx[2] === 'hu'
	? 'Időpontok betöltése...'
	: 'Loading available times...') + "";

	let t1;

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			t0 = space();
			span = element("span");
			t1 = text(t1_value);
			attr_dev(div0, "class", "loading-spinner svelte-xhyfm");
			add_location(div0, file$5, 259, 6, 10324);
			attr_dev(span, "class", "svelte-xhyfm");
			add_location(span, file$5, 260, 6, 10366);
			attr_dev(div1, "class", "loading-indicator svelte-xhyfm");
			add_location(div1, file$5, 258, 4, 10286);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			append_dev(div1, t0);
			append_dev(div1, span);
			append_dev(span, t1);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*currentLang*/ 4 && t1_value !== (t1_value = (/*currentLang*/ ctx[2] === 'hu'
			? 'Időpontok betöltése...'
			: 'Loading available times...') + "")) set_data_dev(t1, t1_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$5.name,
		type: "if",
		source: "(258:22) ",
		ctx
	});

	return block;
}

// (254:2) {#if !date}
function create_if_block_1$5(ctx) {
	let div;

	let t_value = (/*currentLang*/ ctx[2] === 'hu'
	? 'Kérjük, előbb válasszon dátumot'
	: 'Please select a date first') + "";

	let t;

	const block = {
		c: function create() {
			div = element("div");
			t = text(t_value);
			attr_dev(div, "class", "info-message svelte-xhyfm");
			add_location(div, file$5, 254, 4, 10125);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*currentLang*/ 4 && t_value !== (t_value = (/*currentLang*/ ctx[2] === 'hu'
			? 'Kérjük, előbb válasszon dátumot'
			: 'Please select a date first') + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$5.name,
		type: "if",
		source: "(254:2) {#if !date}",
		ctx
	});

	return block;
}

// (271:5) {#if errorFetching}
function create_if_block_8$2(ctx) {
	let div;
	let t;

	const block = {
		c: function create() {
			div = element("div");
			t = text(/*errorFetching*/ ctx[8]);
			attr_dev(div, "class", "warning-message svelte-xhyfm");
			add_location(div, file$5, 271, 8, 10816);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*errorFetching*/ 256) set_data_dev(t, /*errorFetching*/ ctx[8]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_8$2.name,
		type: "if",
		source: "(271:5) {#if errorFetching}",
		ctx
	});

	return block;
}

// (282:8) {:else}
function create_else_block_3(ctx) {
	let div;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let each_value_1 = /*displayableMorningSlots*/ ctx[9];
	validate_each_argument(each_value_1);
	const get_key = ctx => /*time*/ ctx[20];
	validate_each_keys(ctx, each_value_1, get_each_context_1, get_key);

	for (let i = 0; i < each_value_1.length; i += 1) {
		let child_ctx = get_each_context_1(ctx, each_value_1, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block_1(key, child_ctx));
	}

	const block = {
		c: function create() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr_dev(div, "class", "time-slots svelte-xhyfm");
			add_location(div, file$5, 282, 10, 11312);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(div, null);
				}
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*selectedTime, displayableMorningSlots, unavailableTimeSlots, currentLang, selectTimeSlot*/ 4677) {
				each_value_1 = /*displayableMorningSlots*/ ctx[9];
				validate_each_argument(each_value_1);
				validate_each_keys(ctx, each_value_1, get_each_context_1, get_key);
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_1, each_1_lookup, div, destroy_block, create_each_block_1, null, get_each_context_1);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_3.name,
		type: "else",
		source: "(282:8) {:else}",
		ctx
	});

	return block;
}

// (280:8) {#if displayableMorningSlots.length === 0}
function create_if_block_6$2(ctx) {
	let p;

	let t_value = (/*currentLang*/ ctx[2] === 'hu'
	? 'Nincs elérhető délelőtti időpont'
	: 'No morning slots available') + "";

	let t;

	const block = {
		c: function create() {
			p = element("p");
			t = text(t_value);
			attr_dev(p, "class", "no-slots-message svelte-xhyfm");
			add_location(p, file$5, 280, 10, 11163);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*currentLang*/ 4 && t_value !== (t_value = (/*currentLang*/ ctx[2] === 'hu'
			? 'Nincs elérhető délelőtti időpont'
			: 'No morning slots available') + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_6$2.name,
		type: "if",
		source: "(280:8) {#if displayableMorningSlots.length === 0}",
		ctx
	});

	return block;
}

// (295:16) {:else}
function create_else_block_4(ctx) {
	let span;

	const block = {
		c: function create() {
			span = element("span");
			attr_dev(span, "class", "status-indicator available-indicator svelte-xhyfm");
			add_location(span, file$5, 295, 18, 12059);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_4.name,
		type: "else",
		source: "(295:16) {:else}",
		ctx
	});

	return block;
}

// (293:16) {#if unavailableTimeSlots.includes(time)}
function create_if_block_7$2(ctx) {
	let span;

	const block = {
		c: function create() {
			span = element("span");
			attr_dev(span, "class", "status-indicator unavailable-indicator svelte-xhyfm");
			add_location(span, file$5, 293, 18, 11956);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_7$2.name,
		type: "if",
		source: "(293:16) {#if unavailableTimeSlots.includes(time)}",
		ctx
	});

	return block;
}

// (284:12) {#each displayableMorningSlots as time (time)}
function create_each_block_1(key_1, ctx) {
	let button;
	let t0_value = /*time*/ ctx[20] + "";
	let t0;
	let t1;
	let show_if;
	let t2;
	let button_class_value;
	let button_disabled_value;
	let button_aria_label_value;
	let mounted;
	let dispose;

	function select_block_type_2(ctx, dirty) {
		if (dirty & /*unavailableTimeSlots, displayableMorningSlots*/ 576) show_if = null;
		if (show_if == null) show_if = !!/*unavailableTimeSlots*/ ctx[6].includes(/*time*/ ctx[20]);
		if (show_if) return create_if_block_7$2;
		return create_else_block_4;
	}

	let current_block_type = select_block_type_2(ctx, -1);
	let if_block = current_block_type(ctx);

	function click_handler() {
		return /*click_handler*/ ctx[14](/*time*/ ctx[20]);
	}

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			button = element("button");
			t0 = text(t0_value);
			t1 = space();
			if_block.c();
			t2 = space();
			attr_dev(button, "type", "button");

			attr_dev(button, "class", button_class_value = "time-slot " + (/*selectedTime*/ ctx[0] === /*time*/ ctx[20]
			? 'selected'
			: '') + " " + (/*unavailableTimeSlots*/ ctx[6].includes(/*time*/ ctx[20])
			? 'unavailable'
			: '') + " svelte-xhyfm");

			button.disabled = button_disabled_value = /*unavailableTimeSlots*/ ctx[6].includes(/*time*/ ctx[20]);

			attr_dev(button, "aria-label", button_aria_label_value = "" + (/*time*/ ctx[20] + " " + (/*unavailableTimeSlots*/ ctx[6].includes(/*time*/ ctx[20])
			? /*currentLang*/ ctx[2] === 'hu'
				? '- nem elérhető'
				: '- unavailable'
			: '')));

			add_location(button, file$5, 284, 14, 11410);
			this.first = button;
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, t0);
			append_dev(button, t1);
			if_block.m(button, null);
			append_dev(button, t2);

			if (!mounted) {
				dispose = listen_dev(button, "click", click_handler, false, false, false, false);
				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*displayableMorningSlots*/ 512 && t0_value !== (t0_value = /*time*/ ctx[20] + "")) set_data_dev(t0, t0_value);

			if (current_block_type !== (current_block_type = select_block_type_2(ctx, dirty))) {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(button, t2);
				}
			}

			if (dirty & /*selectedTime, displayableMorningSlots, unavailableTimeSlots*/ 577 && button_class_value !== (button_class_value = "time-slot " + (/*selectedTime*/ ctx[0] === /*time*/ ctx[20]
			? 'selected'
			: '') + " " + (/*unavailableTimeSlots*/ ctx[6].includes(/*time*/ ctx[20])
			? 'unavailable'
			: '') + " svelte-xhyfm")) {
				attr_dev(button, "class", button_class_value);
			}

			if (dirty & /*unavailableTimeSlots, displayableMorningSlots*/ 576 && button_disabled_value !== (button_disabled_value = /*unavailableTimeSlots*/ ctx[6].includes(/*time*/ ctx[20]))) {
				prop_dev(button, "disabled", button_disabled_value);
			}

			if (dirty & /*displayableMorningSlots, unavailableTimeSlots, currentLang*/ 580 && button_aria_label_value !== (button_aria_label_value = "" + (/*time*/ ctx[20] + " " + (/*unavailableTimeSlots*/ ctx[6].includes(/*time*/ ctx[20])
			? /*currentLang*/ ctx[2] === 'hu'
				? '- nem elérhető'
				: '- unavailable'
			: '')))) {
				attr_dev(button, "aria-label", button_aria_label_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			if_block.d();
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1.name,
		type: "each",
		source: "(284:12) {#each displayableMorningSlots as time (time)}",
		ctx
	});

	return block;
}

// (309:8) {:else}
function create_else_block_1$1(ctx) {
	let div;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let each_value = /*displayableAfternoonSlots*/ ctx[10];
	validate_each_argument(each_value);
	const get_key = ctx => /*time*/ ctx[20];
	validate_each_keys(ctx, each_value, get_each_context$2, get_key);

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context$2(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block$2(key, child_ctx));
	}

	const block = {
		c: function create() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr_dev(div, "class", "time-slots svelte-xhyfm");
			add_location(div, file$5, 309, 10, 12609);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(div, null);
				}
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*selectedTime, displayableAfternoonSlots, unavailableTimeSlots, currentLang, selectTimeSlot*/ 5189) {
				each_value = /*displayableAfternoonSlots*/ ctx[10];
				validate_each_argument(each_value);
				validate_each_keys(ctx, each_value, get_each_context$2, get_key);
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div, destroy_block, create_each_block$2, null, get_each_context$2);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1$1.name,
		type: "else",
		source: "(309:8) {:else}",
		ctx
	});

	return block;
}

// (307:8) {#if displayableAfternoonSlots.length === 0}
function create_if_block_4$4(ctx) {
	let p;

	let t_value = (/*currentLang*/ ctx[2] === 'hu'
	? 'Nincs elérhető délutáni időpont'
	: 'No afternoon slots available') + "";

	let t;

	const block = {
		c: function create() {
			p = element("p");
			t = text(t_value);
			attr_dev(p, "class", "no-slots-message svelte-xhyfm");
			add_location(p, file$5, 307, 10, 12459);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*currentLang*/ 4 && t_value !== (t_value = (/*currentLang*/ ctx[2] === 'hu'
			? 'Nincs elérhető délutáni időpont'
			: 'No afternoon slots available') + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4$4.name,
		type: "if",
		source: "(307:8) {#if displayableAfternoonSlots.length === 0}",
		ctx
	});

	return block;
}

// (322:16) {:else}
function create_else_block_2$1(ctx) {
	let span;

	const block = {
		c: function create() {
			span = element("span");
			attr_dev(span, "class", "status-indicator available-indicator svelte-xhyfm");
			add_location(span, file$5, 322, 18, 13359);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_2$1.name,
		type: "else",
		source: "(322:16) {:else}",
		ctx
	});

	return block;
}

// (320:16) {#if unavailableTimeSlots.includes(time)}
function create_if_block_5$2(ctx) {
	let span;

	const block = {
		c: function create() {
			span = element("span");
			attr_dev(span, "class", "status-indicator unavailable-indicator svelte-xhyfm");
			add_location(span, file$5, 320, 18, 13256);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_5$2.name,
		type: "if",
		source: "(320:16) {#if unavailableTimeSlots.includes(time)}",
		ctx
	});

	return block;
}

// (311:13) {#each displayableAfternoonSlots as time (time)}
function create_each_block$2(key_1, ctx) {
	let button;
	let t0_value = /*time*/ ctx[20] + "";
	let t0;
	let t1;
	let show_if;
	let t2;
	let button_class_value;
	let button_disabled_value;
	let button_aria_label_value;
	let mounted;
	let dispose;

	function select_block_type_4(ctx, dirty) {
		if (dirty & /*unavailableTimeSlots, displayableAfternoonSlots*/ 1088) show_if = null;
		if (show_if == null) show_if = !!/*unavailableTimeSlots*/ ctx[6].includes(/*time*/ ctx[20]);
		if (show_if) return create_if_block_5$2;
		return create_else_block_2$1;
	}

	let current_block_type = select_block_type_4(ctx, -1);
	let if_block = current_block_type(ctx);

	function click_handler_1() {
		return /*click_handler_1*/ ctx[15](/*time*/ ctx[20]);
	}

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			button = element("button");
			t0 = text(t0_value);
			t1 = space();
			if_block.c();
			t2 = space();
			attr_dev(button, "type", "button");

			attr_dev(button, "class", button_class_value = "time-slot " + (/*selectedTime*/ ctx[0] === /*time*/ ctx[20]
			? 'selected'
			: '') + " " + (/*unavailableTimeSlots*/ ctx[6].includes(/*time*/ ctx[20])
			? 'unavailable'
			: '') + " svelte-xhyfm");

			button.disabled = button_disabled_value = /*unavailableTimeSlots*/ ctx[6].includes(/*time*/ ctx[20]);

			attr_dev(button, "aria-label", button_aria_label_value = "" + (/*time*/ ctx[20] + " " + (/*unavailableTimeSlots*/ ctx[6].includes(/*time*/ ctx[20])
			? /*currentLang*/ ctx[2] === 'hu'
				? '- nem elérhető'
				: '- unavailable'
			: '')));

			add_location(button, file$5, 311, 14, 12710);
			this.first = button;
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, t0);
			append_dev(button, t1);
			if_block.m(button, null);
			append_dev(button, t2);

			if (!mounted) {
				dispose = listen_dev(button, "click", click_handler_1, false, false, false, false);
				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*displayableAfternoonSlots*/ 1024 && t0_value !== (t0_value = /*time*/ ctx[20] + "")) set_data_dev(t0, t0_value);

			if (current_block_type !== (current_block_type = select_block_type_4(ctx, dirty))) {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(button, t2);
				}
			}

			if (dirty & /*selectedTime, displayableAfternoonSlots, unavailableTimeSlots*/ 1089 && button_class_value !== (button_class_value = "time-slot " + (/*selectedTime*/ ctx[0] === /*time*/ ctx[20]
			? 'selected'
			: '') + " " + (/*unavailableTimeSlots*/ ctx[6].includes(/*time*/ ctx[20])
			? 'unavailable'
			: '') + " svelte-xhyfm")) {
				attr_dev(button, "class", button_class_value);
			}

			if (dirty & /*unavailableTimeSlots, displayableAfternoonSlots*/ 1088 && button_disabled_value !== (button_disabled_value = /*unavailableTimeSlots*/ ctx[6].includes(/*time*/ ctx[20]))) {
				prop_dev(button, "disabled", button_disabled_value);
			}

			if (dirty & /*displayableAfternoonSlots, unavailableTimeSlots, currentLang*/ 1092 && button_aria_label_value !== (button_aria_label_value = "" + (/*time*/ ctx[20] + " " + (/*unavailableTimeSlots*/ ctx[6].includes(/*time*/ ctx[20])
			? /*currentLang*/ ctx[2] === 'hu'
				? '- nem elérhető'
				: '- unavailable'
			: '')))) {
				attr_dev(button, "aria-label", button_aria_label_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			if_block.d();
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$2.name,
		type: "each",
		source: "(311:13) {#each displayableAfternoonSlots as time (time)}",
		ctx
	});

	return block;
}

// (348:2) {#if errorMessage}
function create_if_block$5(ctx) {
	let p;
	let t;

	const block = {
		c: function create() {
			p = element("p");
			t = text(/*errorMessage*/ ctx[3]);
			attr_dev(p, "class", "error-message svelte-xhyfm");
			add_location(p, file$5, 348, 4, 14345);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*errorMessage*/ 8) set_data_dev(t, /*errorMessage*/ ctx[3]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$5.name,
		type: "if",
		source: "(348:2) {#if errorMessage}",
		ctx
	});

	return block;
}

function create_fragment$5(ctx) {
	let div;
	let h4;

	let t0_value = (/*content*/ ctx[1]?.[/*currentLang*/ ctx[2]]?.bookingForm?.[/*formType*/ ctx[4]]?.time || (/*currentLang*/ ctx[2] === 'hu'
	? 'Időpont kiválasztása'
	: 'Select a time')) + "";

	let t0;
	let t1;
	let t2;

	function select_block_type(ctx, dirty) {
		if (!/*date*/ ctx[5]) return create_if_block_1$5;
		if (/*isLoading*/ ctx[7]) return create_if_block_2$5;
		if (/*errorFetching*/ ctx[8] && !/*unavailableTimeSlots*/ ctx[6].length) return create_if_block_3$4;
		return create_else_block$5;
	}

	let current_block_type = select_block_type(ctx);
	let if_block0 = current_block_type(ctx);
	let if_block1 = /*errorMessage*/ ctx[3] && create_if_block$5(ctx);

	const block = {
		c: function create() {
			div = element("div");
			h4 = element("h4");
			t0 = text(t0_value);
			t1 = space();
			if_block0.c();
			t2 = space();
			if (if_block1) if_block1.c();
			attr_dev(h4, "class", "svelte-xhyfm");
			add_location(h4, file$5, 249, 2, 9964);
			attr_dev(div, "class", "form-row svelte-xhyfm");
			add_location(div, file$5, 248, 0, 9939);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, h4);
			append_dev(h4, t0);
			append_dev(div, t1);
			if_block0.m(div, null);
			append_dev(div, t2);
			if (if_block1) if_block1.m(div, null);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*content, currentLang, formType*/ 22 && t0_value !== (t0_value = (/*content*/ ctx[1]?.[/*currentLang*/ ctx[2]]?.bookingForm?.[/*formType*/ ctx[4]]?.time || (/*currentLang*/ ctx[2] === 'hu'
			? 'Időpont kiválasztása'
			: 'Select a time')) + "")) set_data_dev(t0, t0_value);

			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
				if_block0.p(ctx, dirty);
			} else {
				if_block0.d(1);
				if_block0 = current_block_type(ctx);

				if (if_block0) {
					if_block0.c();
					if_block0.m(div, t2);
				}
			}

			if (/*errorMessage*/ ctx[3]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block$5(ctx);
					if_block1.c();
					if_block1.m(div, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if_block0.d();
			if (if_block1) if_block1.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$5.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function getTodaysDateString() {
	const today = new Date();
	const year = today.getFullYear();
	const month = (today.getMonth() + 1).toString().padStart(2, '0');
	const day = today.getDate().toString().padStart(2, '0');
	return `${year}-${month}-${day}`;
}

// Simple string hash function (remains the same)
function simpleHash(str) {
	let hash = 0;

	for (let i = 0; i < str.length; i++) {
		const char = str.charCodeAt(i);
		hash = (hash << 5) - hash + char;
		hash = hash & hash;
	}

	return hash;
}

// Create a seeded random number generator (remains the same)
function createSeededRandom(seed) {
	return function () {
		const x = Math.sin(seed++) * 10000;
		return x - Math.floor(x);
	};
}

function instance$5($$self, $$props, $$invalidate) {
	let { $$slots: slots$1 = {}, $$scope } = $$props;
	validate_slots('TimeSlotSelector', slots$1, []);
	let { selectedTime = '' } = $$props;
	let { content = {} } = $$props;
	let { currentLang = 'hu' } = $$props;
	let { errorMessage = '' } = $$props;
	let { formType = '' } = $$props;
	let { date = '' } = $$props;

	// Define the dispatch function
	const dispatch = createEventDispatcher();

	// Business hours configuration (matches server-side configuration)
	const businessHours = {
		// Format: [opening hour, closing hour] in 24-hour format
		'carWash': [8, 18], // 8:00 - 18:00
		'autoService': [8, 17], // 8:00 - 17:00
		'tireService': [8, 17], // 8:00 - 17:00
		'airportParking': [0, 24], // 24/7 service
		
	};

	// Generate time slots based on business hours for the service type
	function generateTimeSlots(service) {
		const slots = { morning: [], afternoon: [] };
		const [openingHour, closingHour] = businessHours[service] || [8, 17]; // Default to 8-17

		// Handle 24h service edge case (0 to 24 means 0 to 23:xx)
		const endHour = closingHour === 24 ? 23 : closingHour - 1;

		for (let hour = openingHour; hour <= endHour; hour++) {
			const time00 = `${hour.toString().padStart(2, '0')}:00`;
			const time30 = `${hour.toString().padStart(2, '0')}:30`;

			if (hour < closingHour) {
				// Ensure we don't go past closing hour exactly
				if (hour < 12) {
					slots.morning.push(time00);

					// Add 30 min slot unless it's exactly the closing hour
					if (hour < closingHour - 1 || hour === closingHour - 1 && businessHours[service]?.[1] % 1 !== 0.5) {
						// Special check for 24h service to include 23:30
						if (closingHour === 24 || hour < closingHour - 1 || hour === closingHour - 1 && businessHours[service]?.[1] % 1 === 0) {
							slots.morning.push(time30);
						}
					}
				} else {
					slots.afternoon.push(time00);

					// Add 30 min slot unless it's exactly the closing hour
					if (closingHour === 24 || hour < closingHour - 1 || hour === closingHour - 1 && businessHours[service]?.[1] % 1 === 0) {
						slots.afternoon.push(time30);
					}
				}
			}
		}

		// Special case for 24hr service to include 23:30 if needed, handled above now
		// Ensure closingHour:00 is not added if businessHours ends on the hour like 17:00
		return slots;
	}

	// State for available/unavailable slots
	let allTimeSlots = { morning: [], afternoon: [] };

	let unavailableTimeSlots = [];
	let isLoading = false;
	let errorFetching = '';

	// NEW: State for slots filtered for display (hiding past slots for today)
	let displayableMorningSlots = [];

	let displayableAfternoonSlots = [];

	// This block focuses only on filtering based on the current time for today.
	// --- End Reactive block ---
	// Function to fetch available slots from the backend (remains the same)
	async function fetchAvailableSlots() {
		if (!date || !formType) return;
		$$invalidate(7, isLoading = true);
		$$invalidate(8, errorFetching = '');

		try {
			const serviceMap = {
				carWash: 'carWash',
				autoService: 'autoService',
				tireService: 'tireService'
			};

			const service = serviceMap[formType] || formType;
			console.log(`Workspaceing unavailable slots for: ${service} on ${date}`);
			const apiUrl = `https://zima-auto-backend.fly.dev/api/available-slots?date=${date}&service=${service}`;
			console.log('API URL:', apiUrl);

			const response = await fetch(apiUrl, {
				credentials: 'include',
				headers: {
					'Content-Type': 'application/json',
					'Accept': 'application/json'
				}
			});

			if (!response.ok) {
				console.error('API response not OK:', response.status, response.statusText);

				// Don't throw error here if you want mock data fallback
				// throw new Error(`API returned status ${response.status}`);
				$$invalidate(8, errorFetching = `API returned status ${response.status}. Using mock data.`); // Set error message

				// Use mock data on API failure
				$$invalidate(6, unavailableTimeSlots = generateMockUnavailableSlots(date, formType));

				console.log('Using mock unavailable time slots due to API error:', unavailableTimeSlots);
			} else {
				const data = await response.json();
				console.log('Received data from API:', data);

				if (data.success) {
					$$invalidate(6, unavailableTimeSlots = data.unavailableSlots || []);
					console.log('Received unavailable time slots:', unavailableTimeSlots);

					// Clear selection if it became unavailable
					if (selectedTime && unavailableTimeSlots.includes(selectedTime)) {
						$$invalidate(0, selectedTime = '');
						dispatch('timeSelected', '');
					}
				} else {
					console.error('API returned error:', data.message);
					$$invalidate(8, errorFetching = data.message || 'Failed to fetch available slots');
					$$invalidate(6, unavailableTimeSlots = generateMockUnavailableSlots(date, formType)); // Use mock data on logical API error
					console.log('Using mock unavailable time slots due to API logic error:', unavailableTimeSlots);
				}
			}
		} catch(err) {
			console.error('Error fetching available time slots:', err);
			$$invalidate(8, errorFetching = 'Could not connect to server. Using mock data instead.');

			// Use mock data on network/fetch error
			$$invalidate(6, unavailableTimeSlots = generateMockUnavailableSlots(date, formType));

			console.log('Using mock unavailable time slots due to fetch catch:', unavailableTimeSlots);

			// Clear selection if it became unavailable (based on mock data)
			if (selectedTime && unavailableTimeSlots.includes(selectedTime)) {
				$$invalidate(0, selectedTime = '');
				dispatch('timeSelected', '');
			}
		} finally {
			$$invalidate(7, isLoading = false);
		}
	}

	// Mock function to generate unavailable slots (remains the same)
	function generateMockUnavailableSlots(dateStr, service) {
		const seed = simpleHash(`${dateStr}-${service}`);
		const rng = createSeededRandom(seed);

		const unavailableSlotsCount = {
			'carWash': 5,
			'autoService': 10,
			'tireService': 8
		};

		const count = unavailableSlotsCount[service] || 7;

		// Important: Mock should operate on ALL potential slots, not just displayable ones
		const allGeneratedSlots = [
			...generateTimeSlots(service).morning,
			...generateTimeSlots(service).afternoon
		];

		const unavailable = [];

		for (let i = 0; i < count; i++) {
			if (allGeneratedSlots.length === 0) break;
			const index = Math.floor(rng() * allGeneratedSlots.length);
			unavailable.push(allGeneratedSlots[index]);
			allGeneratedSlots.splice(index, 1);
		}

		return unavailable;
	}

	// Function to update the selected time and dispatch an event (remains the same)
	function selectTimeSlot(time) {
		if (unavailableTimeSlots.includes(time)) return;
		$$invalidate(0, selectedTime = time);
		dispatch('timeSelected', time);
	}

	// Also fetch on mount (existing logic)
	onMount(() => {
		console.log('TimeSlotSelector mounted. Date:', date, 'Form type:', formType);

		if (date && formType) {
			fetchAvailableSlots();
		}
	}); // Initial calculation of displayable slots happens via the main reactive block ($:)

	const writable_props = ['selectedTime', 'content', 'currentLang', 'errorMessage', 'formType', 'date'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$3.warn(`<TimeSlotSelector> was created with unknown prop '${key}'`);
	});

	const click_handler = time => selectTimeSlot(time);
	const click_handler_1 = time => selectTimeSlot(time);

	$$self.$$set = $$props => {
		if ('selectedTime' in $$props) $$invalidate(0, selectedTime = $$props.selectedTime);
		if ('content' in $$props) $$invalidate(1, content = $$props.content);
		if ('currentLang' in $$props) $$invalidate(2, currentLang = $$props.currentLang);
		if ('errorMessage' in $$props) $$invalidate(3, errorMessage = $$props.errorMessage);
		if ('formType' in $$props) $$invalidate(4, formType = $$props.formType);
		if ('date' in $$props) $$invalidate(5, date = $$props.date);
	};

	$$self.$capture_state = () => ({
		selectedTime,
		content,
		currentLang,
		errorMessage,
		formType,
		date,
		createEventDispatcher,
		onMount,
		dispatch,
		businessHours,
		generateTimeSlots,
		allTimeSlots,
		unavailableTimeSlots,
		isLoading,
		errorFetching,
		displayableMorningSlots,
		displayableAfternoonSlots,
		getTodaysDateString,
		fetchAvailableSlots,
		generateMockUnavailableSlots,
		simpleHash,
		createSeededRandom,
		selectTimeSlot
	});

	$$self.$inject_state = $$props => {
		if ('selectedTime' in $$props) $$invalidate(0, selectedTime = $$props.selectedTime);
		if ('content' in $$props) $$invalidate(1, content = $$props.content);
		if ('currentLang' in $$props) $$invalidate(2, currentLang = $$props.currentLang);
		if ('errorMessage' in $$props) $$invalidate(3, errorMessage = $$props.errorMessage);
		if ('formType' in $$props) $$invalidate(4, formType = $$props.formType);
		if ('date' in $$props) $$invalidate(5, date = $$props.date);
		if ('allTimeSlots' in $$props) $$invalidate(13, allTimeSlots = $$props.allTimeSlots);
		if ('unavailableTimeSlots' in $$props) $$invalidate(6, unavailableTimeSlots = $$props.unavailableTimeSlots);
		if ('isLoading' in $$props) $$invalidate(7, isLoading = $$props.isLoading);
		if ('errorFetching' in $$props) $$invalidate(8, errorFetching = $$props.errorFetching);
		if ('displayableMorningSlots' in $$props) $$invalidate(9, displayableMorningSlots = $$props.displayableMorningSlots);
		if ('displayableAfternoonSlots' in $$props) $$invalidate(10, displayableAfternoonSlots = $$props.displayableAfternoonSlots);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*formType, date, allTimeSlots*/ 8240) {
			// --- End Helper ---
			// --- Reactive block for recalculating displayable slots ---
			{
				// Regenerate all slots based on business hours whenever formType changes
				$$invalidate(13, allTimeSlots = generateTimeSlots(formType));

				const todayString = getTodaysDateString();
				const isToday = date === todayString; // Check if selected date is today
				let filterHour = -1;
				let filterMinute = -1;

				if (isToday) {
					const now = new Date();
					filterHour = now.getHours();
					filterMinute = now.getMinutes();
					console.log(`Filtering past slots for today (${date}). Current time: ${filterHour}:${filterMinute.toString().padStart(2, '0')}`);
				} // console.log('Selected date is not today, showing all generated slots for date:', date);

				// Filter function: returns true if the slot should be displayed
				const filterSlot = time => {
					if (!isToday) return true; // Not today, show all generated slots
					const [hour, minute] = time.split(':').map(Number);

					// Keep the slot if its start time is >= current time
					return hour > filterHour || hour === filterHour && minute >= filterMinute;
				};

				// Apply filter to get the slots we actually want to display
				$$invalidate(9, displayableMorningSlots = allTimeSlots.morning.filter(filterSlot));

				$$invalidate(10, displayableAfternoonSlots = allTimeSlots.afternoon.filter(filterSlot));
			} // Note: Fetching available slots (isLoading, unavailableTimeSlots)
			// is handled by the separate `$: if (date)` block below.
		}

		if ($$self.$$.dirty & /*date, formType*/ 48) {
			// Fetch available slots when the date changes (existing logic)
			if (date && formType) {
				// Added formType check as it influences slots
				console.log('Date or FormType changed, fetching slots for date:', date, 'and type:', formType);

				fetchAvailableSlots();
			}
		}
	};

	return [
		selectedTime,
		content,
		currentLang,
		errorMessage,
		formType,
		date,
		unavailableTimeSlots,
		isLoading,
		errorFetching,
		displayableMorningSlots,
		displayableAfternoonSlots,
		fetchAvailableSlots,
		selectTimeSlot,
		allTimeSlots,
		click_handler,
		click_handler_1
	];
}

class TimeSlotSelector extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$5, create_fragment$5, safe_not_equal, {
			selectedTime: 0,
			content: 1,
			currentLang: 2,
			errorMessage: 3,
			formType: 4,
			date: 5
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "TimeSlotSelector",
			options,
			id: create_fragment$5.name
		});
	}

	get selectedTime() {
		throw new Error("<TimeSlotSelector>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set selectedTime(value) {
		throw new Error("<TimeSlotSelector>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get content() {
		throw new Error("<TimeSlotSelector>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set content(value) {
		throw new Error("<TimeSlotSelector>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get currentLang() {
		throw new Error("<TimeSlotSelector>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set currentLang(value) {
		throw new Error("<TimeSlotSelector>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get errorMessage() {
		throw new Error("<TimeSlotSelector>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set errorMessage(value) {
		throw new Error("<TimeSlotSelector>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get formType() {
		throw new Error("<TimeSlotSelector>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set formType(value) {
		throw new Error("<TimeSlotSelector>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get date() {
		throw new Error("<TimeSlotSelector>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set date(value) {
		throw new Error("<TimeSlotSelector>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/CarWashForm.svelte generated by Svelte v3.59.2 */
const file$4 = "src/components/CarWashForm.svelte";

// (135:8) {#if formErrors.bookingDate}
function create_if_block_2$4(ctx) {
	let p;
	let t_value = /*formErrors*/ ctx[3].bookingDate + "";
	let t;

	const block = {
		c: function create() {
			p = element("p");
			t = text(t_value);
			attr_dev(p, "class", "error-message svelte-16im2f1");
			add_location(p, file$4, 135, 10, 3954);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*formErrors*/ 8 && t_value !== (t_value = /*formErrors*/ ctx[3].bookingDate + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$4.name,
		type: "if",
		source: "(135:8) {#if formErrors.bookingDate}",
		ctx
	});

	return block;
}

// (186:8) {#if formErrors.acceptPrivacy}
function create_if_block_1$4(ctx) {
	let p;
	let t_value = /*formErrors*/ ctx[3].acceptPrivacy + "";
	let t;

	const block = {
		c: function create() {
			p = element("p");
			t = text(t_value);
			attr_dev(p, "class", "error-message svelte-16im2f1");
			add_location(p, file$4, 186, 10, 5540);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*formErrors*/ 8 && t_value !== (t_value = /*formErrors*/ ctx[3].acceptPrivacy + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$4.name,
		type: "if",
		source: "(186:8) {#if formErrors.acceptPrivacy}",
		ctx
	});

	return block;
}

// (197:8) {:else}
function create_else_block$4(ctx) {
	let t_value = /*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.submit + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*content, currentLang*/ 3 && t_value !== (t_value = /*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.submit + "")) set_data_dev(t, t_value);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$4.name,
		type: "else",
		source: "(197:8) {:else}",
		ctx
	});

	return block;
}

// (194:8) {#if isSubmitting}
function create_if_block$4(ctx) {
	let loadingspinner;
	let t0;
	let span;

	let t1_value = (/*currentLang*/ ctx[1] === 'hu'
	? 'Feldolgozás...'
	: 'Processing...') + "";

	let t1;
	let current;

	loadingspinner = new LoadingSpinner({
			props: { size: "1rem", color: "white" },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(loadingspinner.$$.fragment);
			t0 = space();
			span = element("span");
			t1 = text(t1_value);
			add_location(span, file$4, 195, 10, 5833);
		},
		m: function mount(target, anchor) {
			mount_component(loadingspinner, target, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, span, anchor);
			append_dev(span, t1);
			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty & /*currentLang*/ 2) && t1_value !== (t1_value = (/*currentLang*/ ctx[1] === 'hu'
			? 'Feldolgozás...'
			: 'Processing...') + "")) set_data_dev(t1, t1_value);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(loadingspinner.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(loadingspinner.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(loadingspinner, detaching);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$4.name,
		type: "if",
		source: "(194:8) {#if isSubmitting}",
		ctx
	});

	return block;
}

function create_fragment$4(ctx) {
	let form;
	let div1;
	let h30;

	let t0_value = (/*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.carWash.dateTime || (/*currentLang*/ ctx[1] === 'hu'
	? 'Időpont kiválasztása'
	: 'Select Date & Time')) + "";

	let t0;
	let t1;
	let div0;
	let label0;
	let t2_value = (/*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.carWash.date || (/*currentLang*/ ctx[1] === 'hu' ? 'Dátum' : 'Date')) + "";
	let t2;
	let t3;
	let input0;
	let t4;
	let t5;
	let timeslotselector;
	let t6;
	let personalinfoform;
	let updating_formData;
	let updating_formErrors;
	let t7;
	let div3;
	let h31;

	let t8_value = (/*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.carWash.notes || (/*currentLang*/ ctx[1] === 'hu'
	? 'További megjegyzések'
	: 'Additional Notes')) + "";

	let t8;
	let t9;
	let div2;
	let textarea;
	let textarea_placeholder_value;
	let t10;
	let div5;
	let div4;
	let label1;
	let input1;
	let t11;
	let span;

	let t12_value = (/*currentLang*/ ctx[1] === 'hu'
	? 'Elfogadom az '
	: 'I accept the ') + "";

	let t12;
	let t13;
	let a;

	let t14_value = (/*currentLang*/ ctx[1] === 'hu'
	? 'Adatvédelmi irányelveket'
	: 'Privacy Policy') + "";

	let t14;
	let t15;
	let t16;
	let div6;
	let button;
	let current_block_type_index;
	let if_block2;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*formErrors*/ ctx[3].bookingDate && create_if_block_2$4(ctx);

	timeslotselector = new TimeSlotSelector({
			props: {
				selectedTime: /*formData*/ ctx[2].bookingTime,
				content: /*content*/ ctx[0],
				currentLang: /*currentLang*/ ctx[1],
				errorMessage: /*formErrors*/ ctx[3].bookingTime,
				formType: "carWash",
				date: /*formData*/ ctx[2].bookingDate
			},
			$$inline: true
		});

	timeslotselector.$on("timeSelected", /*handleTimeSelected*/ ctx[7]);

	function personalinfoform_formData_binding(value) {
		/*personalinfoform_formData_binding*/ ctx[10](value);
	}

	function personalinfoform_formErrors_binding(value) {
		/*personalinfoform_formErrors_binding*/ ctx[11](value);
	}

	let personalinfoform_props = {
		content: /*content*/ ctx[0],
		currentLang: /*currentLang*/ ctx[1],
		isSubmitting: /*isSubmitting*/ ctx[4]
	};

	if (/*formData*/ ctx[2] !== void 0) {
		personalinfoform_props.formData = /*formData*/ ctx[2];
	}

	if (/*formErrors*/ ctx[3] !== void 0) {
		personalinfoform_props.formErrors = /*formErrors*/ ctx[3];
	}

	personalinfoform = new PersonalInfoForm({
			props: personalinfoform_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(personalinfoform, 'formData', personalinfoform_formData_binding));
	binding_callbacks.push(() => bind(personalinfoform, 'formErrors', personalinfoform_formErrors_binding));
	let if_block1 = /*formErrors*/ ctx[3].acceptPrivacy && create_if_block_1$4(ctx);
	const if_block_creators = [create_if_block$4, create_else_block$4];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*isSubmitting*/ ctx[4]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			form = element("form");
			div1 = element("div");
			h30 = element("h3");
			t0 = text(t0_value);
			t1 = space();
			div0 = element("div");
			label0 = element("label");
			t2 = text(t2_value);
			t3 = space();
			input0 = element("input");
			t4 = space();
			if (if_block0) if_block0.c();
			t5 = space();
			create_component(timeslotselector.$$.fragment);
			t6 = space();
			create_component(personalinfoform.$$.fragment);
			t7 = space();
			div3 = element("div");
			h31 = element("h3");
			t8 = text(t8_value);
			t9 = space();
			div2 = element("div");
			textarea = element("textarea");
			t10 = space();
			div5 = element("div");
			div4 = element("div");
			label1 = element("label");
			input1 = element("input");
			t11 = space();
			span = element("span");
			t12 = text(t12_value);
			t13 = space();
			a = element("a");
			t14 = text(t14_value);
			t15 = space();
			if (if_block1) if_block1.c();
			t16 = space();
			div6 = element("div");
			button = element("button");
			if_block2.c();
			attr_dev(h30, "class", "svelte-16im2f1");
			add_location(h30, file$4, 120, 6, 3322);
			attr_dev(label0, "for", "booking-date");
			attr_dev(label0, "class", "svelte-16im2f1");
			add_location(label0, file$4, 122, 8, 3504);
			attr_dev(input0, "id", "booking-date");
			attr_dev(input0, "type", "date");
			attr_dev(input0, "min", formatDate(/*today*/ ctx[5]));
			attr_dev(input0, "max", formatDate(/*maxDate*/ ctx[6]));
			input0.required = true;
			attr_dev(input0, "class", "svelte-16im2f1");
			toggle_class(input0, "error", /*formErrors*/ ctx[3].bookingDate);
			add_location(input0, file$4, 125, 8, 3659);
			attr_dev(div0, "class", "date-time-selector");
			add_location(div0, file$4, 121, 6, 3463);
			attr_dev(div1, "class", "form-section svelte-16im2f1");
			add_location(div1, file$4, 119, 4, 3289);
			attr_dev(h31, "class", "svelte-16im2f1");
			add_location(h31, file$4, 159, 6, 4548);
			attr_dev(textarea, "id", "notes");
			attr_dev(textarea, "rows", "4");

			attr_dev(textarea, "placeholder", textarea_placeholder_value = /*currentLang*/ ctx[1] === 'hu'
			? 'További megjegyzések (opcionális)'
			: 'Additional notes (optional)');

			attr_dev(textarea, "class", "svelte-16im2f1");
			add_location(textarea, file$4, 161, 8, 4717);
			attr_dev(div2, "class", "form-group svelte-16im2f1");
			add_location(div2, file$4, 160, 6, 4684);
			attr_dev(div3, "class", "form-section svelte-16im2f1");
			add_location(div3, file$4, 158, 4, 4515);
			attr_dev(input1, "type", "checkbox");
			input1.required = true;
			attr_dev(input1, "class", "svelte-16im2f1");
			add_location(input1, file$4, 173, 10, 5094);
			attr_dev(a, "href", "#privacy");
			attr_dev(a, "class", "privacy-link svelte-16im2f1");
			add_location(a, file$4, 180, 12, 5313);
			add_location(span, file$4, 178, 10, 5223);
			attr_dev(label1, "class", "checkbox-label svelte-16im2f1");
			add_location(label1, file$4, 172, 8, 5053);
			attr_dev(div4, "class", "form-group privacy-checkbox svelte-16im2f1");
			add_location(div4, file$4, 171, 6, 5003);
			attr_dev(div5, "class", "form-section svelte-16im2f1");
			add_location(div5, file$4, 170, 4, 4970);
			attr_dev(button, "type", "submit");
			attr_dev(button, "class", "submit-button svelte-16im2f1");
			button.disabled = /*isSubmitting*/ ctx[4];
			add_location(button, file$4, 192, 6, 5672);
			attr_dev(div6, "class", "form-actions svelte-16im2f1");
			add_location(div6, file$4, 191, 4, 5639);
			attr_dev(form, "class", "booking-form svelte-16im2f1");
			add_location(form, file$4, 118, 2, 3217);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, form, anchor);
			append_dev(form, div1);
			append_dev(div1, h30);
			append_dev(h30, t0);
			append_dev(div1, t1);
			append_dev(div1, div0);
			append_dev(div0, label0);
			append_dev(label0, t2);
			append_dev(div0, t3);
			append_dev(div0, input0);
			set_input_value(input0, /*formData*/ ctx[2].bookingDate);
			append_dev(div0, t4);
			if (if_block0) if_block0.m(div0, null);
			append_dev(form, t5);
			mount_component(timeslotselector, form, null);
			append_dev(form, t6);
			mount_component(personalinfoform, form, null);
			append_dev(form, t7);
			append_dev(form, div3);
			append_dev(div3, h31);
			append_dev(h31, t8);
			append_dev(div3, t9);
			append_dev(div3, div2);
			append_dev(div2, textarea);
			set_input_value(textarea, /*formData*/ ctx[2].notes);
			append_dev(form, t10);
			append_dev(form, div5);
			append_dev(div5, div4);
			append_dev(div4, label1);
			append_dev(label1, input1);
			input1.checked = /*formData*/ ctx[2].acceptPrivacy;
			append_dev(label1, t11);
			append_dev(label1, span);
			append_dev(span, t12);
			append_dev(span, t13);
			append_dev(span, a);
			append_dev(a, t14);
			append_dev(div4, t15);
			if (if_block1) if_block1.m(div4, null);
			append_dev(form, t16);
			append_dev(form, div6);
			append_dev(div6, button);
			if_blocks[current_block_type_index].m(button, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(input0, "input", /*input0_input_handler*/ ctx[9]),
					listen_dev(textarea, "input", /*textarea_input_handler*/ ctx[12]),
					listen_dev(input1, "change", /*input1_change_handler*/ ctx[13]),
					listen_dev(form, "submit", prevent_default(/*handleSubmit*/ ctx[8]), false, true, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if ((!current || dirty & /*content, currentLang*/ 3) && t0_value !== (t0_value = (/*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.carWash.dateTime || (/*currentLang*/ ctx[1] === 'hu'
			? 'Időpont kiválasztása'
			: 'Select Date & Time')) + "")) set_data_dev(t0, t0_value);

			if ((!current || dirty & /*content, currentLang*/ 3) && t2_value !== (t2_value = (/*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.carWash.date || (/*currentLang*/ ctx[1] === 'hu' ? 'Dátum' : 'Date')) + "")) set_data_dev(t2, t2_value);

			if (dirty & /*formData*/ 4) {
				set_input_value(input0, /*formData*/ ctx[2].bookingDate);
			}

			if (!current || dirty & /*formErrors*/ 8) {
				toggle_class(input0, "error", /*formErrors*/ ctx[3].bookingDate);
			}

			if (/*formErrors*/ ctx[3].bookingDate) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_2$4(ctx);
					if_block0.c();
					if_block0.m(div0, null);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			const timeslotselector_changes = {};
			if (dirty & /*formData*/ 4) timeslotselector_changes.selectedTime = /*formData*/ ctx[2].bookingTime;
			if (dirty & /*content*/ 1) timeslotselector_changes.content = /*content*/ ctx[0];
			if (dirty & /*currentLang*/ 2) timeslotselector_changes.currentLang = /*currentLang*/ ctx[1];
			if (dirty & /*formErrors*/ 8) timeslotselector_changes.errorMessage = /*formErrors*/ ctx[3].bookingTime;
			if (dirty & /*formData*/ 4) timeslotselector_changes.date = /*formData*/ ctx[2].bookingDate;
			timeslotselector.$set(timeslotselector_changes);
			const personalinfoform_changes = {};
			if (dirty & /*content*/ 1) personalinfoform_changes.content = /*content*/ ctx[0];
			if (dirty & /*currentLang*/ 2) personalinfoform_changes.currentLang = /*currentLang*/ ctx[1];
			if (dirty & /*isSubmitting*/ 16) personalinfoform_changes.isSubmitting = /*isSubmitting*/ ctx[4];

			if (!updating_formData && dirty & /*formData*/ 4) {
				updating_formData = true;
				personalinfoform_changes.formData = /*formData*/ ctx[2];
				add_flush_callback(() => updating_formData = false);
			}

			if (!updating_formErrors && dirty & /*formErrors*/ 8) {
				updating_formErrors = true;
				personalinfoform_changes.formErrors = /*formErrors*/ ctx[3];
				add_flush_callback(() => updating_formErrors = false);
			}

			personalinfoform.$set(personalinfoform_changes);

			if ((!current || dirty & /*content, currentLang*/ 3) && t8_value !== (t8_value = (/*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.carWash.notes || (/*currentLang*/ ctx[1] === 'hu'
			? 'További megjegyzések'
			: 'Additional Notes')) + "")) set_data_dev(t8, t8_value);

			if (!current || dirty & /*currentLang*/ 2 && textarea_placeholder_value !== (textarea_placeholder_value = /*currentLang*/ ctx[1] === 'hu'
			? 'További megjegyzések (opcionális)'
			: 'Additional notes (optional)')) {
				attr_dev(textarea, "placeholder", textarea_placeholder_value);
			}

			if (dirty & /*formData*/ 4) {
				set_input_value(textarea, /*formData*/ ctx[2].notes);
			}

			if (dirty & /*formData*/ 4) {
				input1.checked = /*formData*/ ctx[2].acceptPrivacy;
			}

			if ((!current || dirty & /*currentLang*/ 2) && t12_value !== (t12_value = (/*currentLang*/ ctx[1] === 'hu'
			? 'Elfogadom az '
			: 'I accept the ') + "")) set_data_dev(t12, t12_value);

			if ((!current || dirty & /*currentLang*/ 2) && t14_value !== (t14_value = (/*currentLang*/ ctx[1] === 'hu'
			? 'Adatvédelmi irányelveket'
			: 'Privacy Policy') + "")) set_data_dev(t14, t14_value);

			if (/*formErrors*/ ctx[3].acceptPrivacy) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_1$4(ctx);
					if_block1.c();
					if_block1.m(div4, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block2 = if_blocks[current_block_type_index];

				if (!if_block2) {
					if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block2.c();
				} else {
					if_block2.p(ctx, dirty);
				}

				transition_in(if_block2, 1);
				if_block2.m(button, null);
			}

			if (!current || dirty & /*isSubmitting*/ 16) {
				prop_dev(button, "disabled", /*isSubmitting*/ ctx[4]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(timeslotselector.$$.fragment, local);
			transition_in(personalinfoform.$$.fragment, local);
			transition_in(if_block2);
			current = true;
		},
		o: function outro(local) {
			transition_out(timeslotselector.$$.fragment, local);
			transition_out(personalinfoform.$$.fragment, local);
			transition_out(if_block2);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(form);
			if (if_block0) if_block0.d();
			destroy_component(timeslotselector);
			destroy_component(personalinfoform);
			if (if_block1) if_block1.d();
			if_blocks[current_block_type_index].d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function formatDate(date) {
	const d = new Date(date);
	let month = '' + (d.getMonth() + 1);
	let day = '' + d.getDate();
	const year = d.getFullYear();
	if (month.length < 2) month = '0' + month;
	if (day.length < 2) day = '0' + day;
	return [year, month, day].join('-');
}

function instance$4($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('CarWashForm', slots, []);
	let { content = {} } = $$props;
	let { currentLang = 'hu' } = $$props;

	// Initialize event dispatcher
	const dispatch = createEventDispatcher();

	// Calendar data
	const today = new Date();

	const maxDate = new Date();
	maxDate.setMonth(maxDate.getMonth() + 3); // Allow bookings 3 months in advance

	// Form data
	let formData = {
		// Car wash specific
		bookingDate: formatDate(today),
		bookingTime: '',
		// Personal info (will be bound from PersonalInfoForm)
		firstName: '',
		lastName: '',
		email: '',
		phone: '',
		notes: '',
		acceptPrivacy: false
	};

	// Form validation
	let formErrors = {
		bookingTime: '',
		firstName: '',
		lastName: '',
		email: '',
		phone: '',
		acceptPrivacy: ''
	};

	let isSubmitting = false;

	// Handle time selection from TimeSlotSelector
	function handleTimeSelected(event) {
		$$invalidate(2, formData.bookingTime = event.detail, formData);
		$$invalidate(3, formErrors.bookingTime = '', formErrors); // Clear error on selection
	}

	// Form validation function
	function validateForm() {
		let isValid = true;

		// Reset time slot error
		$$invalidate(3, formErrors.bookingTime = '', formErrors);

		// Validate time slot is selected
		if (!formData.bookingTime) {
			$$invalidate(3, formErrors.bookingTime = content[currentLang].bookingForm.selectTimeSlot, formErrors);
			isValid = false;
		}

		return isValid;
	}

	// Handle form submission
	function handleSubmit() {
		if (!validateForm()) {
			// Scroll to the first error message if validation fails
			setTimeout(
				() => {
					const firstError = document.querySelector('.error-message');

					if (firstError) {
						firstError.scrollIntoView({ behavior: 'smooth', block: 'center' });
					}
				},
				50
			);

			return;
		}

		$$invalidate(4, isSubmitting = true);

		// Simulate API call
		setTimeout(
			() => {
				// Create booking details object to pass to the parent component
				const bookingDetails = {
					service: 'carWash',
					name: `${formData.lastName} ${formData.firstName}`,
					contact: {
						email: formData.email,
						phone: formData.phone
					},
					date: formData.bookingDate,
					time: formData.bookingTime,
					notes: formData.notes
				};

				$$invalidate(4, isSubmitting = false);

				// Dispatch event to notify parent component
				dispatch('bookingComplete', bookingDetails);
			},
			1500
		);
	}

	const writable_props = ['content', 'currentLang'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CarWashForm> was created with unknown prop '${key}'`);
	});

	function input0_input_handler() {
		formData.bookingDate = this.value;
		$$invalidate(2, formData);
	}

	function personalinfoform_formData_binding(value) {
		formData = value;
		$$invalidate(2, formData);
	}

	function personalinfoform_formErrors_binding(value) {
		formErrors = value;
		$$invalidate(3, formErrors);
	}

	function textarea_input_handler() {
		formData.notes = this.value;
		$$invalidate(2, formData);
	}

	function input1_change_handler() {
		formData.acceptPrivacy = this.checked;
		$$invalidate(2, formData);
	}

	$$self.$$set = $$props => {
		if ('content' in $$props) $$invalidate(0, content = $$props.content);
		if ('currentLang' in $$props) $$invalidate(1, currentLang = $$props.currentLang);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		PersonalInfoForm,
		TimeSlotSelector,
		LoadingSpinner,
		content,
		currentLang,
		dispatch,
		today,
		maxDate,
		formData,
		formErrors,
		isSubmitting,
		formatDate,
		handleTimeSelected,
		validateForm,
		handleSubmit
	});

	$$self.$inject_state = $$props => {
		if ('content' in $$props) $$invalidate(0, content = $$props.content);
		if ('currentLang' in $$props) $$invalidate(1, currentLang = $$props.currentLang);
		if ('formData' in $$props) $$invalidate(2, formData = $$props.formData);
		if ('formErrors' in $$props) $$invalidate(3, formErrors = $$props.formErrors);
		if ('isSubmitting' in $$props) $$invalidate(4, isSubmitting = $$props.isSubmitting);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		content,
		currentLang,
		formData,
		formErrors,
		isSubmitting,
		today,
		maxDate,
		handleTimeSelected,
		handleSubmit,
		input0_input_handler,
		personalinfoform_formData_binding,
		personalinfoform_formErrors_binding,
		textarea_input_handler,
		input1_change_handler
	];
}

class CarWashForm extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4, create_fragment$4, safe_not_equal, { content: 0, currentLang: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "CarWashForm",
			options,
			id: create_fragment$4.name
		});
	}

	get content() {
		throw new Error("<CarWashForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set content(value) {
		throw new Error("<CarWashForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get currentLang() {
		throw new Error("<CarWashForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set currentLang(value) {
		throw new Error("<CarWashForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/AutoServiceForm.svelte generated by Svelte v3.59.2 */

const { console: console_1$2 } = globals;
const file$3 = "src/components/AutoServiceForm.svelte";

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[19] = list[i];
	return child_ctx;
}

// (123:8) {#each serviceTypes as type}
function create_each_block$1(ctx) {
	let label;
	let input;
	let input_value_value;
	let value_has_changed = false;
	let t0;
	let span;
	let t1_value = /*type*/ ctx[19].label + "";
	let t1;
	let t2;
	let binding_group;
	let mounted;
	let dispose;
	binding_group = init_binding_group(/*$$binding_groups*/ ctx[9][0]);

	const block = {
		c: function create() {
			label = element("label");
			input = element("input");
			t0 = space();
			span = element("span");
			t1 = text(t1_value);
			t2 = space();
			attr_dev(input, "type", "radio");
			attr_dev(input, "name", "serviceType");
			input.__value = input_value_value = /*type*/ ctx[19].value;
			input.value = input.__value;
			attr_dev(input, "class", "svelte-1uyvd5f");
			add_location(input, file$3, 124, 12, 4092);
			add_location(span, file$3, 130, 12, 4267);
			attr_dev(label, "class", "service-type-option svelte-1uyvd5f");
			add_location(label, file$3, 123, 10, 4044);
			binding_group.p(input);
		},
		m: function mount(target, anchor) {
			insert_dev(target, label, anchor);
			append_dev(label, input);
			input.checked = input.__value === /*formData*/ ctx[2].serviceType;
			append_dev(label, t0);
			append_dev(label, span);
			append_dev(span, t1);
			append_dev(label, t2);

			if (!mounted) {
				dispose = listen_dev(input, "change", /*input_change_handler*/ ctx[8]);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*serviceTypes*/ 32 && input_value_value !== (input_value_value = /*type*/ ctx[19].value)) {
				prop_dev(input, "__value", input_value_value);
				input.value = input.__value;
				value_has_changed = true;
			}

			if (value_has_changed || dirty & /*formData, serviceTypes*/ 36) {
				input.checked = input.__value === /*formData*/ ctx[2].serviceType;
			}

			if (dirty & /*serviceTypes*/ 32 && t1_value !== (t1_value = /*type*/ ctx[19].label + "")) set_data_dev(t1, t1_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(label);
			binding_group.r();
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$1.name,
		type: "each",
		source: "(123:8) {#each serviceTypes as type}",
		ctx
	});

	return block;
}

// (135:6) {#if errors.serviceType}
function create_if_block_4$3(ctx) {
	let p;
	let t_value = /*errors*/ ctx[3].serviceType + "";
	let t;

	const block = {
		c: function create() {
			p = element("p");
			t = text(t_value);
			attr_dev(p, "class", "error-message svelte-1uyvd5f");
			add_location(p, file$3, 135, 8, 4380);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*errors*/ 8 && t_value !== (t_value = /*errors*/ ctx[3].serviceType + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4$3.name,
		type: "if",
		source: "(135:6) {#if errors.serviceType}",
		ctx
	});

	return block;
}

// (153:8) {#if errors.date}
function create_if_block_3$3(ctx) {
	let p;
	let t_value = /*errors*/ ctx[3].date + "";
	let t;

	const block = {
		c: function create() {
			p = element("p");
			t = text(t_value);
			attr_dev(p, "class", "error-message svelte-1uyvd5f");
			add_location(p, file$3, 153, 10, 4981);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*errors*/ 8 && t_value !== (t_value = /*errors*/ ctx[3].date + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3$3.name,
		type: "if",
		source: "(153:8) {#if errors.date}",
		ctx
	});

	return block;
}

// (169:12) {#if errors.time}
function create_if_block_2$3(ctx) {
	let p;
	let t_value = /*errors*/ ctx[3].time + "";
	let t;

	const block = {
		c: function create() {
			p = element("p");
			t = text(t_value);
			attr_dev(p, "class", "error-message svelte-1uyvd5f");
			add_location(p, file$3, 169, 12, 5497);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*errors*/ 8 && t_value !== (t_value = /*errors*/ ctx[3].time + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$3.name,
		type: "if",
		source: "(169:12) {#if errors.time}",
		ctx
	});

	return block;
}

// (233:8) {#if errors.acceptPrivacy}
function create_if_block_1$3(ctx) {
	let p;
	let t_value = /*errors*/ ctx[3].acceptPrivacy + "";
	let t;

	const block = {
		c: function create() {
			p = element("p");
			t = text(t_value);
			attr_dev(p, "class", "error-message svelte-1uyvd5f");
			add_location(p, file$3, 233, 10, 7689);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*errors*/ 8 && t_value !== (t_value = /*errors*/ ctx[3].acceptPrivacy + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$3.name,
		type: "if",
		source: "(233:8) {#if errors.acceptPrivacy}",
		ctx
	});

	return block;
}

// (248:8) {:else}
function create_else_block$3(ctx) {
	let t_value = /*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.submit + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*content, currentLang*/ 3 && t_value !== (t_value = /*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.submit + "")) set_data_dev(t, t_value);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$3.name,
		type: "else",
		source: "(248:8) {:else}",
		ctx
	});

	return block;
}

// (245:8) {#if isSubmitting}
function create_if_block$3(ctx) {
	let loadingspinner;
	let t0;
	let span;

	let t1_value = (/*currentLang*/ ctx[1] === 'hu'
	? 'Feldolgozás...'
	: 'Processing...') + "";

	let t1;
	let current;

	loadingspinner = new LoadingSpinner({
			props: { size: "1rem", color: "white" },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(loadingspinner.$$.fragment);
			t0 = space();
			span = element("span");
			t1 = text(t1_value);
			add_location(span, file$3, 246, 10, 8011);
		},
		m: function mount(target, anchor) {
			mount_component(loadingspinner, target, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, span, anchor);
			append_dev(span, t1);
			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty & /*currentLang*/ 2) && t1_value !== (t1_value = (/*currentLang*/ ctx[1] === 'hu'
			? 'Feldolgozás...'
			: 'Processing...') + "")) set_data_dev(t1, t1_value);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(loadingspinner.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(loadingspinner.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(loadingspinner, detaching);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$3.name,
		type: "if",
		source: "(245:8) {#if isSubmitting}",
		ctx
	});

	return block;
}

function create_fragment$3(ctx) {
	let form;
	let div1;
	let h30;
	let t0_value = /*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.autoService.serviceType + "";
	let t0;
	let t1;
	let div0;
	let t2;
	let t3;
	let div3;
	let h31;
	let t4_value = (/*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.autoService.dateTime || 'Select Date & Time') + "";
	let t4;
	let t5;
	let div2;
	let label0;
	let t6_value = (/*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.carWash.date || 'Date') + "";
	let t6;
	let t7;
	let input0;
	let t8;
	let t9;
	let div4;
	let timeslotselector;
	let t10;
	let t11;
	let div5;
	let personalinfoform;
	let updating_formData;
	let updating_formErrors;
	let t12;
	let div8;
	let h32;
	let t13_value = (/*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.autoService.carDetails || 'Car Details') + "";
	let t13;
	let t14;
	let div6;
	let label1;
	let t15_value = (/*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.autoService.carModel || 'Car Model') + "";
	let t15;
	let t16;
	let input1;
	let input1_placeholder_value;
	let t17;
	let div7;
	let label2;
	let t18_value = (/*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.autoService.licensePlate || 'License Plate') + "";
	let t18;
	let t19;
	let input2;
	let input2_placeholder_value;
	let t20;
	let div10;
	let h33;
	let t21_value = (/*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.autoService.notes || 'Additional Notes') + "";
	let t21;
	let t22;
	let div9;
	let textarea;
	let textarea_placeholder_value;
	let t23;
	let div12;
	let div11;
	let label3;
	let input3;
	let t24;
	let span;

	let t25_value = (/*currentLang*/ ctx[1] === 'hu'
	? 'Elfogadom az '
	: 'I accept the ') + "";

	let t25;
	let t26;
	let a;

	let t27_value = (/*currentLang*/ ctx[1] === 'hu'
	? 'Adatvédelmi irányelveket'
	: 'Privacy Policy') + "";

	let t27;
	let t28;
	let t29;
	let div13;
	let button;
	let current_block_type_index;
	let if_block4;
	let current;
	let mounted;
	let dispose;
	let each_value = /*serviceTypes*/ ctx[5];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	}

	let if_block0 = /*errors*/ ctx[3].serviceType && create_if_block_4$3(ctx);
	let if_block1 = /*errors*/ ctx[3].date && create_if_block_3$3(ctx);

	timeslotselector = new TimeSlotSelector({
			props: {
				selectedTime: /*formData*/ ctx[2].time,
				content: /*content*/ ctx[0],
				currentLang: /*currentLang*/ ctx[1],
				formType: "autoService",
				date: /*formData*/ ctx[2].date
			},
			$$inline: true
		});

	timeslotselector.$on("timeSelected", /*handleTimeSelected*/ ctx[6]);
	let if_block2 = /*errors*/ ctx[3].time && create_if_block_2$3(ctx);

	function personalinfoform_formData_binding(value) {
		/*personalinfoform_formData_binding*/ ctx[11](value);
	}

	function personalinfoform_formErrors_binding(value) {
		/*personalinfoform_formErrors_binding*/ ctx[12](value);
	}

	let personalinfoform_props = {
		content: /*content*/ ctx[0],
		currentLang: /*currentLang*/ ctx[1],
		isSubmitting: /*isSubmitting*/ ctx[4]
	};

	if (/*formData*/ ctx[2] !== void 0) {
		personalinfoform_props.formData = /*formData*/ ctx[2];
	}

	if (/*errors*/ ctx[3] !== void 0) {
		personalinfoform_props.formErrors = /*errors*/ ctx[3];
	}

	personalinfoform = new PersonalInfoForm({
			props: personalinfoform_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(personalinfoform, 'formData', personalinfoform_formData_binding));
	binding_callbacks.push(() => bind(personalinfoform, 'formErrors', personalinfoform_formErrors_binding));
	let if_block3 = /*errors*/ ctx[3].acceptPrivacy && create_if_block_1$3(ctx);
	const if_block_creators = [create_if_block$3, create_else_block$3];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*isSubmitting*/ ctx[4]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block4 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			form = element("form");
			div1 = element("div");
			h30 = element("h3");
			t0 = text(t0_value);
			t1 = space();
			div0 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t2 = space();
			if (if_block0) if_block0.c();
			t3 = space();
			div3 = element("div");
			h31 = element("h3");
			t4 = text(t4_value);
			t5 = space();
			div2 = element("div");
			label0 = element("label");
			t6 = text(t6_value);
			t7 = space();
			input0 = element("input");
			t8 = space();
			if (if_block1) if_block1.c();
			t9 = space();
			div4 = element("div");
			create_component(timeslotselector.$$.fragment);
			t10 = space();
			if (if_block2) if_block2.c();
			t11 = space();
			div5 = element("div");
			create_component(personalinfoform.$$.fragment);
			t12 = space();
			div8 = element("div");
			h32 = element("h3");
			t13 = text(t13_value);
			t14 = space();
			div6 = element("div");
			label1 = element("label");
			t15 = text(t15_value);
			t16 = space();
			input1 = element("input");
			t17 = space();
			div7 = element("div");
			label2 = element("label");
			t18 = text(t18_value);
			t19 = space();
			input2 = element("input");
			t20 = space();
			div10 = element("div");
			h33 = element("h3");
			t21 = text(t21_value);
			t22 = space();
			div9 = element("div");
			textarea = element("textarea");
			t23 = space();
			div12 = element("div");
			div11 = element("div");
			label3 = element("label");
			input3 = element("input");
			t24 = space();
			span = element("span");
			t25 = text(t25_value);
			t26 = space();
			a = element("a");
			t27 = text(t27_value);
			t28 = space();
			if (if_block3) if_block3.c();
			t29 = space();
			div13 = element("div");
			button = element("button");
			if_block4.c();
			attr_dev(h30, "class", "svelte-1uyvd5f");
			add_location(h30, file$3, 120, 6, 3895);
			attr_dev(div0, "class", "service-types svelte-1uyvd5f");
			add_location(div0, file$3, 121, 6, 3969);
			attr_dev(div1, "class", "form-section svelte-1uyvd5f");
			add_location(div1, file$3, 119, 4, 3862);
			attr_dev(h31, "class", "svelte-1uyvd5f");
			add_location(h31, file$3, 140, 6, 4493);
			attr_dev(label0, "for", "booking-date");
			add_location(label0, file$3, 142, 8, 4629);
			attr_dev(input0, "id", "booking-date");
			attr_dev(input0, "type", "date");
			attr_dev(input0, "min", new Date().toISOString().split('T')[0]);
			attr_dev(input0, "class", "svelte-1uyvd5f");
			toggle_class(input0, "error", /*errors*/ ctx[3].date);
			add_location(input0, file$3, 145, 8, 4749);
			attr_dev(div2, "class", "date-time-selector svelte-1uyvd5f");
			add_location(div2, file$3, 141, 6, 4588);
			attr_dev(div3, "class", "form-section svelte-1uyvd5f");
			add_location(div3, file$3, 139, 4, 4460);
			attr_dev(div4, "class", "time-slot-container svelte-1uyvd5f");
			toggle_class(div4, "error", /*errors*/ ctx[3].time);
			add_location(div4, file$3, 159, 8, 5144);
			attr_dev(div5, "class", "form-section svelte-1uyvd5f");
			add_location(div5, file$3, 173, 4, 5580);
			attr_dev(h32, "class", "svelte-1uyvd5f");
			add_location(h32, file$3, 184, 6, 5841);
			attr_dev(label1, "for", "carModel");
			attr_dev(label1, "class", "svelte-1uyvd5f");
			add_location(label1, file$3, 186, 8, 5964);
			attr_dev(input1, "type", "text");
			attr_dev(input1, "id", "carModel");
			attr_dev(input1, "placeholder", input1_placeholder_value = /*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.autoService.carModelPlaceholder || 'e.g. Toyota Corolla 2018');
			attr_dev(input1, "class", "svelte-1uyvd5f");
			add_location(input1, file$3, 187, 8, 6073);
			attr_dev(div6, "class", "form-group svelte-1uyvd5f");
			add_location(div6, file$3, 185, 6, 5931);
			attr_dev(label2, "for", "licensePlate");
			attr_dev(label2, "class", "svelte-1uyvd5f");
			add_location(label2, file$3, 195, 8, 6349);
			attr_dev(input2, "type", "text");
			attr_dev(input2, "id", "licensePlate");

			attr_dev(input2, "placeholder", input2_placeholder_value = /*currentLang*/ ctx[1] === 'hu'
			? 'Adja meg rendszámát'
			: 'Enter your license plate');

			attr_dev(input2, "class", "svelte-1uyvd5f");
			add_location(input2, file$3, 196, 8, 6470);
			attr_dev(div7, "class", "form-group svelte-1uyvd5f");
			add_location(div7, file$3, 194, 6, 6316);
			attr_dev(div8, "class", "form-section svelte-1uyvd5f");
			add_location(div8, file$3, 183, 4, 5808);
			attr_dev(h33, "class", "svelte-1uyvd5f");
			add_location(h33, file$3, 206, 6, 6745);
			attr_dev(textarea, "id", "notes");
			attr_dev(textarea, "rows", "4");

			attr_dev(textarea, "placeholder", textarea_placeholder_value = /*currentLang*/ ctx[1] === 'hu'
			? 'További megjegyzések (opcionális)'
			: 'Additional notes (optional)');

			attr_dev(textarea, "class", "svelte-1uyvd5f");
			add_location(textarea, file$3, 208, 8, 6868);
			attr_dev(div9, "class", "form-group svelte-1uyvd5f");
			add_location(div9, file$3, 207, 6, 6835);
			attr_dev(div10, "class", "form-section svelte-1uyvd5f");
			add_location(div10, file$3, 205, 4, 6712);
			attr_dev(input3, "type", "checkbox");
			input3.required = true;
			attr_dev(input3, "class", "svelte-1uyvd5f");
			add_location(input3, file$3, 220, 10, 7247);
			attr_dev(a, "href", "#privacy");
			attr_dev(a, "class", "privacy-link svelte-1uyvd5f");
			add_location(a, file$3, 227, 12, 7466);
			add_location(span, file$3, 225, 10, 7376);
			attr_dev(label3, "class", "checkbox-label svelte-1uyvd5f");
			add_location(label3, file$3, 219, 8, 7206);
			attr_dev(div11, "class", "form-group privacy-checkbox svelte-1uyvd5f");
			add_location(div11, file$3, 218, 6, 7156);
			attr_dev(div12, "class", "form-section svelte-1uyvd5f");
			add_location(div12, file$3, 217, 4, 7123);
			attr_dev(button, "type", "submit");
			attr_dev(button, "class", "submit-button svelte-1uyvd5f");
			button.disabled = /*isSubmitting*/ ctx[4];
			add_location(button, file$3, 239, 6, 7819);
			attr_dev(div13, "class", "form-actions svelte-1uyvd5f");
			add_location(div13, file$3, 238, 4, 7786);
			attr_dev(form, "class", "booking-form svelte-1uyvd5f");
			add_location(form, file$3, 118, 2, 3790);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, form, anchor);
			append_dev(form, div1);
			append_dev(div1, h30);
			append_dev(h30, t0);
			append_dev(div1, t1);
			append_dev(div1, div0);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(div0, null);
				}
			}

			append_dev(div1, t2);
			if (if_block0) if_block0.m(div1, null);
			append_dev(form, t3);
			append_dev(form, div3);
			append_dev(div3, h31);
			append_dev(h31, t4);
			append_dev(div3, t5);
			append_dev(div3, div2);
			append_dev(div2, label0);
			append_dev(label0, t6);
			append_dev(div2, t7);
			append_dev(div2, input0);
			set_input_value(input0, /*formData*/ ctx[2].date);
			append_dev(div2, t8);
			if (if_block1) if_block1.m(div2, null);
			append_dev(form, t9);
			append_dev(form, div4);
			mount_component(timeslotselector, div4, null);
			append_dev(div4, t10);
			if (if_block2) if_block2.m(div4, null);
			append_dev(form, t11);
			append_dev(form, div5);
			mount_component(personalinfoform, div5, null);
			append_dev(form, t12);
			append_dev(form, div8);
			append_dev(div8, h32);
			append_dev(h32, t13);
			append_dev(div8, t14);
			append_dev(div8, div6);
			append_dev(div6, label1);
			append_dev(label1, t15);
			append_dev(div6, t16);
			append_dev(div6, input1);
			set_input_value(input1, /*formData*/ ctx[2].carModel);
			append_dev(div8, t17);
			append_dev(div8, div7);
			append_dev(div7, label2);
			append_dev(label2, t18);
			append_dev(div7, t19);
			append_dev(div7, input2);
			set_input_value(input2, /*formData*/ ctx[2].licensePlate);
			append_dev(form, t20);
			append_dev(form, div10);
			append_dev(div10, h33);
			append_dev(h33, t21);
			append_dev(div10, t22);
			append_dev(div10, div9);
			append_dev(div9, textarea);
			set_input_value(textarea, /*formData*/ ctx[2].notes);
			append_dev(form, t23);
			append_dev(form, div12);
			append_dev(div12, div11);
			append_dev(div11, label3);
			append_dev(label3, input3);
			input3.checked = /*formData*/ ctx[2].acceptPrivacy;
			append_dev(label3, t24);
			append_dev(label3, span);
			append_dev(span, t25);
			append_dev(span, t26);
			append_dev(span, a);
			append_dev(a, t27);
			append_dev(div11, t28);
			if (if_block3) if_block3.m(div11, null);
			append_dev(form, t29);
			append_dev(form, div13);
			append_dev(div13, button);
			if_blocks[current_block_type_index].m(button, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(input0, "input", /*input0_input_handler*/ ctx[10]),
					listen_dev(input1, "input", /*input1_input_handler*/ ctx[13]),
					listen_dev(input2, "input", /*input2_input_handler*/ ctx[14]),
					listen_dev(textarea, "input", /*textarea_input_handler*/ ctx[15]),
					listen_dev(input3, "change", /*input3_change_handler*/ ctx[16]),
					listen_dev(form, "submit", prevent_default(/*handleSubmit*/ ctx[7]), false, true, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if ((!current || dirty & /*content, currentLang*/ 3) && t0_value !== (t0_value = /*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.autoService.serviceType + "")) set_data_dev(t0, t0_value);

			if (dirty & /*serviceTypes, formData*/ 36) {
				each_value = /*serviceTypes*/ ctx[5];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div0, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (/*errors*/ ctx[3].serviceType) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_4$3(ctx);
					if_block0.c();
					if_block0.m(div1, null);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if ((!current || dirty & /*content, currentLang*/ 3) && t4_value !== (t4_value = (/*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.autoService.dateTime || 'Select Date & Time') + "")) set_data_dev(t4, t4_value);
			if ((!current || dirty & /*content, currentLang*/ 3) && t6_value !== (t6_value = (/*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.carWash.date || 'Date') + "")) set_data_dev(t6, t6_value);

			if (dirty & /*formData*/ 4) {
				set_input_value(input0, /*formData*/ ctx[2].date);
			}

			if (!current || dirty & /*errors*/ 8) {
				toggle_class(input0, "error", /*errors*/ ctx[3].date);
			}

			if (/*errors*/ ctx[3].date) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_3$3(ctx);
					if_block1.c();
					if_block1.m(div2, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			const timeslotselector_changes = {};
			if (dirty & /*formData*/ 4) timeslotselector_changes.selectedTime = /*formData*/ ctx[2].time;
			if (dirty & /*content*/ 1) timeslotselector_changes.content = /*content*/ ctx[0];
			if (dirty & /*currentLang*/ 2) timeslotselector_changes.currentLang = /*currentLang*/ ctx[1];
			if (dirty & /*formData*/ 4) timeslotselector_changes.date = /*formData*/ ctx[2].date;
			timeslotselector.$set(timeslotselector_changes);

			if (/*errors*/ ctx[3].time) {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block_2$3(ctx);
					if_block2.c();
					if_block2.m(div4, null);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			if (!current || dirty & /*errors*/ 8) {
				toggle_class(div4, "error", /*errors*/ ctx[3].time);
			}

			const personalinfoform_changes = {};
			if (dirty & /*content*/ 1) personalinfoform_changes.content = /*content*/ ctx[0];
			if (dirty & /*currentLang*/ 2) personalinfoform_changes.currentLang = /*currentLang*/ ctx[1];
			if (dirty & /*isSubmitting*/ 16) personalinfoform_changes.isSubmitting = /*isSubmitting*/ ctx[4];

			if (!updating_formData && dirty & /*formData*/ 4) {
				updating_formData = true;
				personalinfoform_changes.formData = /*formData*/ ctx[2];
				add_flush_callback(() => updating_formData = false);
			}

			if (!updating_formErrors && dirty & /*errors*/ 8) {
				updating_formErrors = true;
				personalinfoform_changes.formErrors = /*errors*/ ctx[3];
				add_flush_callback(() => updating_formErrors = false);
			}

			personalinfoform.$set(personalinfoform_changes);
			if ((!current || dirty & /*content, currentLang*/ 3) && t13_value !== (t13_value = (/*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.autoService.carDetails || 'Car Details') + "")) set_data_dev(t13, t13_value);
			if ((!current || dirty & /*content, currentLang*/ 3) && t15_value !== (t15_value = (/*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.autoService.carModel || 'Car Model') + "")) set_data_dev(t15, t15_value);

			if (!current || dirty & /*content, currentLang*/ 3 && input1_placeholder_value !== (input1_placeholder_value = /*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.autoService.carModelPlaceholder || 'e.g. Toyota Corolla 2018')) {
				attr_dev(input1, "placeholder", input1_placeholder_value);
			}

			if (dirty & /*formData*/ 4 && input1.value !== /*formData*/ ctx[2].carModel) {
				set_input_value(input1, /*formData*/ ctx[2].carModel);
			}

			if ((!current || dirty & /*content, currentLang*/ 3) && t18_value !== (t18_value = (/*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.autoService.licensePlate || 'License Plate') + "")) set_data_dev(t18, t18_value);

			if (!current || dirty & /*currentLang*/ 2 && input2_placeholder_value !== (input2_placeholder_value = /*currentLang*/ ctx[1] === 'hu'
			? 'Adja meg rendszámát'
			: 'Enter your license plate')) {
				attr_dev(input2, "placeholder", input2_placeholder_value);
			}

			if (dirty & /*formData*/ 4 && input2.value !== /*formData*/ ctx[2].licensePlate) {
				set_input_value(input2, /*formData*/ ctx[2].licensePlate);
			}

			if ((!current || dirty & /*content, currentLang*/ 3) && t21_value !== (t21_value = (/*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.autoService.notes || 'Additional Notes') + "")) set_data_dev(t21, t21_value);

			if (!current || dirty & /*currentLang*/ 2 && textarea_placeholder_value !== (textarea_placeholder_value = /*currentLang*/ ctx[1] === 'hu'
			? 'További megjegyzések (opcionális)'
			: 'Additional notes (optional)')) {
				attr_dev(textarea, "placeholder", textarea_placeholder_value);
			}

			if (dirty & /*formData*/ 4) {
				set_input_value(textarea, /*formData*/ ctx[2].notes);
			}

			if (dirty & /*formData*/ 4) {
				input3.checked = /*formData*/ ctx[2].acceptPrivacy;
			}

			if ((!current || dirty & /*currentLang*/ 2) && t25_value !== (t25_value = (/*currentLang*/ ctx[1] === 'hu'
			? 'Elfogadom az '
			: 'I accept the ') + "")) set_data_dev(t25, t25_value);

			if ((!current || dirty & /*currentLang*/ 2) && t27_value !== (t27_value = (/*currentLang*/ ctx[1] === 'hu'
			? 'Adatvédelmi irányelveket'
			: 'Privacy Policy') + "")) set_data_dev(t27, t27_value);

			if (/*errors*/ ctx[3].acceptPrivacy) {
				if (if_block3) {
					if_block3.p(ctx, dirty);
				} else {
					if_block3 = create_if_block_1$3(ctx);
					if_block3.c();
					if_block3.m(div11, null);
				}
			} else if (if_block3) {
				if_block3.d(1);
				if_block3 = null;
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block4 = if_blocks[current_block_type_index];

				if (!if_block4) {
					if_block4 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block4.c();
				} else {
					if_block4.p(ctx, dirty);
				}

				transition_in(if_block4, 1);
				if_block4.m(button, null);
			}

			if (!current || dirty & /*isSubmitting*/ 16) {
				prop_dev(button, "disabled", /*isSubmitting*/ ctx[4]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(timeslotselector.$$.fragment, local);
			transition_in(personalinfoform.$$.fragment, local);
			transition_in(if_block4);
			current = true;
		},
		o: function outro(local) {
			transition_out(timeslotselector.$$.fragment, local);
			transition_out(personalinfoform.$$.fragment, local);
			transition_out(if_block4);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(form);
			destroy_each(each_blocks, detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			destroy_component(timeslotselector);
			if (if_block2) if_block2.d();
			destroy_component(personalinfoform);
			if (if_block3) if_block3.d();
			if_blocks[current_block_type_index].d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3($$self, $$props, $$invalidate) {
	let serviceTypes;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('AutoServiceForm', slots, []);
	const dispatch = createEventDispatcher();
	let { content } = $$props;
	let { currentLang } = $$props;

	let formData = {
		serviceType: '',
		date: new Date().toISOString().split('T')[0],
		time: '',
		firstName: '',
		lastName: '',
		email: '',
		phone: '',
		carModel: '',
		licensePlate: '',
		notes: '',
		acceptPrivacy: false
	};

	let errors = {};
	let isSubmitting = false;

	function validateForm() {
		$$invalidate(3, errors = {});
		let isValid = true;

		if (!formData.serviceType) {
			$$invalidate(
				3,
				errors.serviceType = currentLang === 'hu'
				? 'Kérjük válasszon szolgáltatást'
				: 'Please select a service type',
				errors
			);

			isValid = false;
		}

		if (!formData.date) {
			$$invalidate(
				3,
				errors.date = currentLang === 'hu'
				? 'Kérjük válasszon dátumot'
				: 'Please select a date',
				errors
			);

			isValid = false;
		}

		if (!formData.time) {
			$$invalidate(
				3,
				errors.time = currentLang === 'hu'
				? 'Kérjük válasszon időpontot'
				: 'Please select a time',
				errors
			);

			isValid = false;
		}

		if (!formData.firstName) {
			$$invalidate(
				3,
				errors.firstName = currentLang === 'hu'
				? 'Kérjük adja meg a keresztnevét'
				: 'Please enter your first name',
				errors
			);

			isValid = false;
		}

		if (!formData.lastName) {
			$$invalidate(
				3,
				errors.lastName = currentLang === 'hu'
				? 'Kérjük adja meg a vezetéknevét'
				: 'Please enter your last name',
				errors
			);

			isValid = false;
		}

		if (!formData.phone) {
			$$invalidate(
				3,
				errors.phone = currentLang === 'hu'
				? 'Kérjük adja meg telefonszámát'
				: 'Please enter your phone number',
				errors
			);

			isValid = false;
		}

		if (!formData.email) {
			$$invalidate(
				3,
				errors.email = currentLang === 'hu'
				? 'Kérjük adja meg email címét'
				: 'Please enter your email address',
				errors
			);

			isValid = false;
		} else if (!(/^[^\s@]+@[^\s@]+\.[^\s@]+$/).test(formData.email)) {
			$$invalidate(
				3,
				errors.email = currentLang === 'hu'
				? 'Érvénytelen email cím'
				: 'Invalid email address',
				errors
			);

			isValid = false;
		}

		return isValid;
	}

	function handleTimeSelected(event) {
		$$invalidate(2, formData.time = event.detail, formData);
		$$invalidate(3, errors.time = '', errors); // Clear error when time is selected
	}

	async function handleSubmit() {
		if (!validateForm()) return;
		$$invalidate(4, isSubmitting = true);

		try {
			const bookingData = {
				service: 'autoService',
				serviceType: formData.serviceType,
				date: formData.date,
				time: formData.time,
				name: `${formData.lastName} ${formData.firstName}`,
				contact: {
					email: formData.email,
					phone: formData.phone
				},
				carModel: formData.carModel,
				licensePlate: formData.licensePlate,
				notes: formData.notes,
				// Add admin email for backend
				adminEmail: 'jarsunkaev@gmail.com'
			};

			dispatch('bookingComplete', bookingData);
		} catch(error) {
			console.error('Error submitting form:', error);
		} finally {
			$$invalidate(4, isSubmitting = false);
		}
	}

	$$self.$$.on_mount.push(function () {
		if (content === undefined && !('content' in $$props || $$self.$$.bound[$$self.$$.props['content']])) {
			console_1$2.warn("<AutoServiceForm> was created without expected prop 'content'");
		}

		if (currentLang === undefined && !('currentLang' in $$props || $$self.$$.bound[$$self.$$.props['currentLang']])) {
			console_1$2.warn("<AutoServiceForm> was created without expected prop 'currentLang'");
		}
	});

	const writable_props = ['content', 'currentLang'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$2.warn(`<AutoServiceForm> was created with unknown prop '${key}'`);
	});

	const $$binding_groups = [[]];

	function input_change_handler() {
		formData.serviceType = this.__value;
		$$invalidate(2, formData);
	}

	function input0_input_handler() {
		formData.date = this.value;
		$$invalidate(2, formData);
	}

	function personalinfoform_formData_binding(value) {
		formData = value;
		$$invalidate(2, formData);
	}

	function personalinfoform_formErrors_binding(value) {
		errors = value;
		$$invalidate(3, errors);
	}

	function input1_input_handler() {
		formData.carModel = this.value;
		$$invalidate(2, formData);
	}

	function input2_input_handler() {
		formData.licensePlate = this.value;
		$$invalidate(2, formData);
	}

	function textarea_input_handler() {
		formData.notes = this.value;
		$$invalidate(2, formData);
	}

	function input3_change_handler() {
		formData.acceptPrivacy = this.checked;
		$$invalidate(2, formData);
	}

	$$self.$$set = $$props => {
		if ('content' in $$props) $$invalidate(0, content = $$props.content);
		if ('currentLang' in $$props) $$invalidate(1, currentLang = $$props.currentLang);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		PersonalInfoForm,
		TimeSlotSelector,
		LoadingSpinner,
		dispatch,
		content,
		currentLang,
		formData,
		errors,
		isSubmitting,
		validateForm,
		handleTimeSelected,
		handleSubmit,
		serviceTypes
	});

	$$self.$inject_state = $$props => {
		if ('content' in $$props) $$invalidate(0, content = $$props.content);
		if ('currentLang' in $$props) $$invalidate(1, currentLang = $$props.currentLang);
		if ('formData' in $$props) $$invalidate(2, formData = $$props.formData);
		if ('errors' in $$props) $$invalidate(3, errors = $$props.errors);
		if ('isSubmitting' in $$props) $$invalidate(4, isSubmitting = $$props.isSubmitting);
		if ('serviceTypes' in $$props) $$invalidate(5, serviceTypes = $$props.serviceTypes);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*content, currentLang*/ 3) {
			// Create service types with reactive changes on language toggle
			$$invalidate(5, serviceTypes = [
				{
					value: 'maintenance',
					label: content[currentLang].bookingForm.autoService.serviceOptions.maintenance
				},
				{
					value: 'repair',
					label: content[currentLang].bookingForm.autoService.serviceOptions.repair
				},
				{
					value: 'diagnostic',
					label: content[currentLang].bookingForm.autoService.serviceOptions.diagnostic
				},
				{
					value: 'other',
					label: content[currentLang].bookingForm.autoService.serviceOptions.other
				}
			]);
		}
	};

	return [
		content,
		currentLang,
		formData,
		errors,
		isSubmitting,
		serviceTypes,
		handleTimeSelected,
		handleSubmit,
		input_change_handler,
		$$binding_groups,
		input0_input_handler,
		personalinfoform_formData_binding,
		personalinfoform_formErrors_binding,
		input1_input_handler,
		input2_input_handler,
		textarea_input_handler,
		input3_change_handler
	];
}

class AutoServiceForm extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3, create_fragment$3, safe_not_equal, { content: 0, currentLang: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "AutoServiceForm",
			options,
			id: create_fragment$3.name
		});
	}

	get content() {
		throw new Error("<AutoServiceForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set content(value) {
		throw new Error("<AutoServiceForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get currentLang() {
		throw new Error("<AutoServiceForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set currentLang(value) {
		throw new Error("<AutoServiceForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/TireServiceForm.svelte generated by Svelte v3.59.2 */

const { console: console_1$1 } = globals;
const file$2 = "src/components/TireServiceForm.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[20] = list[i];
	return child_ctx;
}

// (125:8) {#each serviceTypes as type}
function create_each_block(ctx) {
	let label;
	let input;
	let input_value_value;
	let value_has_changed = false;
	let t0;
	let span;
	let t1_value = /*type*/ ctx[20].label + "";
	let t1;
	let t2;
	let binding_group;
	let mounted;
	let dispose;
	binding_group = init_binding_group(/*$$binding_groups*/ ctx[9][0]);

	const block = {
		c: function create() {
			label = element("label");
			input = element("input");
			t0 = space();
			span = element("span");
			t1 = text(t1_value);
			t2 = space();
			attr_dev(input, "type", "radio");
			attr_dev(input, "name", "serviceType");
			input.__value = input_value_value = /*type*/ ctx[20].value;
			input.value = input.__value;
			attr_dev(input, "class", "svelte-5rok69");
			add_location(input, file$2, 126, 12, 4145);
			add_location(span, file$2, 132, 12, 4320);
			attr_dev(label, "class", "service-type-option svelte-5rok69");
			add_location(label, file$2, 125, 10, 4097);
			binding_group.p(input);
		},
		m: function mount(target, anchor) {
			insert_dev(target, label, anchor);
			append_dev(label, input);
			input.checked = input.__value === /*formData*/ ctx[2].serviceType;
			append_dev(label, t0);
			append_dev(label, span);
			append_dev(span, t1);
			append_dev(label, t2);

			if (!mounted) {
				dispose = listen_dev(input, "change", /*input_change_handler*/ ctx[8]);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*serviceTypes*/ 32 && input_value_value !== (input_value_value = /*type*/ ctx[20].value)) {
				prop_dev(input, "__value", input_value_value);
				input.value = input.__value;
				value_has_changed = true;
			}

			if (value_has_changed || dirty & /*formData, serviceTypes*/ 36) {
				input.checked = input.__value === /*formData*/ ctx[2].serviceType;
			}

			if (dirty & /*serviceTypes*/ 32 && t1_value !== (t1_value = /*type*/ ctx[20].label + "")) set_data_dev(t1, t1_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(label);
			binding_group.r();
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(125:8) {#each serviceTypes as type}",
		ctx
	});

	return block;
}

// (137:6) {#if errors.serviceType}
function create_if_block_4$2(ctx) {
	let p;
	let t_value = /*errors*/ ctx[3].serviceType + "";
	let t;

	const block = {
		c: function create() {
			p = element("p");
			t = text(t_value);
			attr_dev(p, "class", "error-message svelte-5rok69");
			add_location(p, file$2, 137, 8, 4433);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*errors*/ 8 && t_value !== (t_value = /*errors*/ ctx[3].serviceType + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4$2.name,
		type: "if",
		source: "(137:6) {#if errors.serviceType}",
		ctx
	});

	return block;
}

// (155:8) {#if errors.date}
function create_if_block_3$2(ctx) {
	let p;
	let t_value = /*errors*/ ctx[3].date + "";
	let t;

	const block = {
		c: function create() {
			p = element("p");
			t = text(t_value);
			attr_dev(p, "class", "error-message svelte-5rok69");
			add_location(p, file$2, 155, 10, 5034);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*errors*/ 8 && t_value !== (t_value = /*errors*/ ctx[3].date + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3$2.name,
		type: "if",
		source: "(155:8) {#if errors.date}",
		ctx
	});

	return block;
}

// (171:8) {#if errors.time}
function create_if_block_2$2(ctx) {
	let p;
	let t_value = /*errors*/ ctx[3].time + "";
	let t;

	const block = {
		c: function create() {
			p = element("p");
			t = text(t_value);
			attr_dev(p, "class", "error-message svelte-5rok69");
			add_location(p, file$2, 171, 8, 5506);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*errors*/ 8 && t_value !== (t_value = /*errors*/ ctx[3].time + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$2.name,
		type: "if",
		source: "(171:8) {#if errors.time}",
		ctx
	});

	return block;
}

// (241:8) {#if errors.acceptPrivacy}
function create_if_block_1$2(ctx) {
	let p;
	let t_value = /*errors*/ ctx[3].acceptPrivacy + "";
	let t;

	const block = {
		c: function create() {
			p = element("p");
			t = text(t_value);
			attr_dev(p, "class", "error-message svelte-5rok69");
			add_location(p, file$2, 241, 10, 8026);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*errors*/ 8 && t_value !== (t_value = /*errors*/ ctx[3].acceptPrivacy + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$2.name,
		type: "if",
		source: "(241:8) {#if errors.acceptPrivacy}",
		ctx
	});

	return block;
}

// (252:8) {:else}
function create_else_block$2(ctx) {
	let t_value = /*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.submit + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*content, currentLang*/ 3 && t_value !== (t_value = /*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.submit + "")) set_data_dev(t, t_value);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$2.name,
		type: "else",
		source: "(252:8) {:else}",
		ctx
	});

	return block;
}

// (249:8) {#if isSubmitting}
function create_if_block$2(ctx) {
	let loadingspinner;
	let t0;
	let span;

	let t1_value = (/*currentLang*/ ctx[1] === 'hu'
	? 'Feldolgozás...'
	: 'Processing...') + "";

	let t1;
	let current;

	loadingspinner = new LoadingSpinner({
			props: { size: "1rem", color: "white" },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(loadingspinner.$$.fragment);
			t0 = space();
			span = element("span");
			t1 = text(t1_value);
			add_location(span, file$2, 250, 10, 8317);
		},
		m: function mount(target, anchor) {
			mount_component(loadingspinner, target, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, span, anchor);
			append_dev(span, t1);
			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty & /*currentLang*/ 2) && t1_value !== (t1_value = (/*currentLang*/ ctx[1] === 'hu'
			? 'Feldolgozás...'
			: 'Processing...') + "")) set_data_dev(t1, t1_value);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(loadingspinner.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(loadingspinner.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(loadingspinner, detaching);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$2.name,
		type: "if",
		source: "(249:8) {#if isSubmitting}",
		ctx
	});

	return block;
}

function create_fragment$2(ctx) {
	let form;
	let div1;
	let h30;
	let t0_value = /*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.tireService.serviceType + "";
	let t0;
	let t1;
	let div0;
	let t2;
	let t3;
	let div3;
	let h31;
	let t4_value = (/*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.tireService.dateTime || 'Select Date & Time') + "";
	let t4;
	let t5;
	let div2;
	let label0;
	let t6_value = (/*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.carWash.date || 'Date') + "";
	let t6;
	let t7;
	let input0;
	let t8;
	let t9;
	let div4;
	let timeslotselector;
	let t10;
	let t11;
	let div5;
	let personalinfoform;
	let updating_formData;
	let updating_formErrors;
	let t12;
	let div9;
	let h32;
	let t13_value = (/*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.tireService.carDetails || 'Car Details') + "";
	let t13;
	let t14;
	let div6;
	let label1;
	let t15_value = (/*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.tireService.carModel || 'Car Model') + "";
	let t15;
	let t16;
	let input1;
	let input1_placeholder_value;
	let t17;
	let div7;
	let label2;
	let t18_value = (/*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.tireService.licensePlate || 'License Plate') + "";
	let t18;
	let t19;
	let input2;
	let input2_placeholder_value;
	let t20;
	let div8;
	let label3;
	let t21_value = (/*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.tireService.tireCount || 'Number of Tires') + "";
	let t21;
	let t22;
	let select;
	let option0;
	let option1;
	let t25;
	let div11;
	let h33;
	let t26_value = (/*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.tireService.notes || 'Additional Notes') + "";
	let t26;
	let t27;
	let div10;
	let textarea;
	let textarea_placeholder_value;
	let t28;
	let div13;
	let div12;
	let label4;
	let input3;
	let t29;
	let span;

	let t30_value = (/*currentLang*/ ctx[1] === 'hu'
	? 'Elfogadom az '
	: 'I accept the ') + "";

	let t30;
	let t31;
	let a;

	let t32_value = (/*currentLang*/ ctx[1] === 'hu'
	? 'Adatvédelmi irányelveket'
	: 'Privacy Policy') + "";

	let t32;
	let t33;
	let t34;
	let div14;
	let button;
	let current_block_type_index;
	let if_block4;
	let current;
	let mounted;
	let dispose;
	let each_value = /*serviceTypes*/ ctx[5];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	let if_block0 = /*errors*/ ctx[3].serviceType && create_if_block_4$2(ctx);
	let if_block1 = /*errors*/ ctx[3].date && create_if_block_3$2(ctx);

	timeslotselector = new TimeSlotSelector({
			props: {
				selectedTime: /*formData*/ ctx[2].time,
				content: /*content*/ ctx[0],
				currentLang: /*currentLang*/ ctx[1],
				formType: "tireService",
				date: /*formData*/ ctx[2].date
			},
			$$inline: true
		});

	timeslotselector.$on("timeSelected", /*handleTimeSelected*/ ctx[6]);
	let if_block2 = /*errors*/ ctx[3].time && create_if_block_2$2(ctx);

	function personalinfoform_formData_binding(value) {
		/*personalinfoform_formData_binding*/ ctx[11](value);
	}

	function personalinfoform_formErrors_binding(value) {
		/*personalinfoform_formErrors_binding*/ ctx[12](value);
	}

	let personalinfoform_props = {
		content: /*content*/ ctx[0],
		currentLang: /*currentLang*/ ctx[1],
		isSubmitting: /*isSubmitting*/ ctx[4]
	};

	if (/*formData*/ ctx[2] !== void 0) {
		personalinfoform_props.formData = /*formData*/ ctx[2];
	}

	if (/*errors*/ ctx[3] !== void 0) {
		personalinfoform_props.formErrors = /*errors*/ ctx[3];
	}

	personalinfoform = new PersonalInfoForm({
			props: personalinfoform_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(personalinfoform, 'formData', personalinfoform_formData_binding));
	binding_callbacks.push(() => bind(personalinfoform, 'formErrors', personalinfoform_formErrors_binding));
	let if_block3 = /*errors*/ ctx[3].acceptPrivacy && create_if_block_1$2(ctx);
	const if_block_creators = [create_if_block$2, create_else_block$2];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*isSubmitting*/ ctx[4]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block4 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			form = element("form");
			div1 = element("div");
			h30 = element("h3");
			t0 = text(t0_value);
			t1 = space();
			div0 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t2 = space();
			if (if_block0) if_block0.c();
			t3 = space();
			div3 = element("div");
			h31 = element("h3");
			t4 = text(t4_value);
			t5 = space();
			div2 = element("div");
			label0 = element("label");
			t6 = text(t6_value);
			t7 = space();
			input0 = element("input");
			t8 = space();
			if (if_block1) if_block1.c();
			t9 = space();
			div4 = element("div");
			create_component(timeslotselector.$$.fragment);
			t10 = space();
			if (if_block2) if_block2.c();
			t11 = space();
			div5 = element("div");
			create_component(personalinfoform.$$.fragment);
			t12 = space();
			div9 = element("div");
			h32 = element("h3");
			t13 = text(t13_value);
			t14 = space();
			div6 = element("div");
			label1 = element("label");
			t15 = text(t15_value);
			t16 = space();
			input1 = element("input");
			t17 = space();
			div7 = element("div");
			label2 = element("label");
			t18 = text(t18_value);
			t19 = space();
			input2 = element("input");
			t20 = space();
			div8 = element("div");
			label3 = element("label");
			t21 = text(t21_value);
			t22 = space();
			select = element("select");
			option0 = element("option");
			option0.textContent = "2";
			option1 = element("option");
			option1.textContent = "4";
			t25 = space();
			div11 = element("div");
			h33 = element("h3");
			t26 = text(t26_value);
			t27 = space();
			div10 = element("div");
			textarea = element("textarea");
			t28 = space();
			div13 = element("div");
			div12 = element("div");
			label4 = element("label");
			input3 = element("input");
			t29 = space();
			span = element("span");
			t30 = text(t30_value);
			t31 = space();
			a = element("a");
			t32 = text(t32_value);
			t33 = space();
			if (if_block3) if_block3.c();
			t34 = space();
			div14 = element("div");
			button = element("button");
			if_block4.c();
			attr_dev(h30, "class", "svelte-5rok69");
			add_location(h30, file$2, 122, 6, 3948);
			attr_dev(div0, "class", "service-types svelte-5rok69");
			add_location(div0, file$2, 123, 6, 4022);
			attr_dev(div1, "class", "form-section svelte-5rok69");
			add_location(div1, file$2, 121, 4, 3915);
			attr_dev(h31, "class", "svelte-5rok69");
			add_location(h31, file$2, 142, 6, 4546);
			attr_dev(label0, "for", "booking-date");
			add_location(label0, file$2, 144, 8, 4682);
			attr_dev(input0, "id", "booking-date");
			attr_dev(input0, "type", "date");
			attr_dev(input0, "min", new Date().toISOString().split('T')[0]);
			attr_dev(input0, "class", "svelte-5rok69");
			toggle_class(input0, "error", /*errors*/ ctx[3].date);
			add_location(input0, file$2, 147, 8, 4802);
			attr_dev(div2, "class", "date-time-selector svelte-5rok69");
			add_location(div2, file$2, 143, 6, 4641);
			attr_dev(div3, "class", "form-section svelte-5rok69");
			add_location(div3, file$2, 141, 4, 4513);
			attr_dev(div4, "class", "time-slot-container svelte-5rok69");
			toggle_class(div4, "error", /*errors*/ ctx[3].time);
			add_location(div4, file$2, 161, 4, 5193);
			attr_dev(div5, "class", "form-section svelte-5rok69");
			add_location(div5, file$2, 175, 4, 5581);
			attr_dev(h32, "class", "svelte-5rok69");
			add_location(h32, file$2, 186, 6, 5842);
			attr_dev(label1, "for", "carModel");
			attr_dev(label1, "class", "svelte-5rok69");
			add_location(label1, file$2, 188, 8, 5965);
			attr_dev(input1, "type", "text");
			attr_dev(input1, "id", "carModel");
			attr_dev(input1, "placeholder", input1_placeholder_value = /*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.tireService.carModelPlaceholder || 'e.g. Toyota Corolla 2018');
			attr_dev(input1, "class", "svelte-5rok69");
			add_location(input1, file$2, 189, 8, 6074);
			attr_dev(div6, "class", "form-group svelte-5rok69");
			add_location(div6, file$2, 187, 6, 5932);
			attr_dev(label2, "for", "licensePlate");
			attr_dev(label2, "class", "svelte-5rok69");
			add_location(label2, file$2, 197, 8, 6350);
			attr_dev(input2, "type", "text");
			attr_dev(input2, "id", "licensePlate");
			attr_dev(input2, "placeholder", input2_placeholder_value = /*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.tireService.licensePlatePlaceholder || 'e.g. ABC-123');
			attr_dev(input2, "class", "svelte-5rok69");
			add_location(input2, file$2, 198, 8, 6471);
			attr_dev(div7, "class", "form-group svelte-5rok69");
			add_location(div7, file$2, 196, 6, 6317);
			attr_dev(label3, "for", "tireCount");
			attr_dev(label3, "class", "svelte-5rok69");
			add_location(label3, file$2, 206, 8, 6747);
			option0.__value = "2";
			option0.value = option0.__value;
			add_location(option0, file$2, 208, 10, 6930);
			option1.__value = "4";
			option1.value = option1.__value;
			add_location(option1, file$2, 209, 10, 6969);
			attr_dev(select, "id", "tireCount");
			attr_dev(select, "class", "svelte-5rok69");
			if (/*formData*/ ctx[2].tireCount === void 0) add_render_callback(() => /*select_change_handler*/ ctx[15].call(select));
			add_location(select, file$2, 207, 8, 6864);
			attr_dev(div8, "class", "form-group svelte-5rok69");
			add_location(div8, file$2, 205, 6, 6714);
			attr_dev(div9, "class", "form-section svelte-5rok69");
			add_location(div9, file$2, 185, 4, 5809);
			attr_dev(h33, "class", "svelte-5rok69");
			add_location(h33, file$2, 215, 6, 7080);
			attr_dev(textarea, "placeholder", textarea_placeholder_value = /*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.tireService.notesPlaceholder || 'Any special requests or additional information');
			attr_dev(textarea, "rows", "4");
			attr_dev(textarea, "class", "svelte-5rok69");
			add_location(textarea, file$2, 217, 8, 7203);
			attr_dev(div10, "class", "form-group svelte-5rok69");
			add_location(div10, file$2, 216, 6, 7170);
			attr_dev(div11, "class", "form-section svelte-5rok69");
			add_location(div11, file$2, 214, 4, 7047);
			attr_dev(input3, "type", "checkbox");
			input3.required = true;
			attr_dev(input3, "class", "svelte-5rok69");
			add_location(input3, file$2, 228, 10, 7584);
			attr_dev(a, "href", "#privacy");
			attr_dev(a, "class", "privacy-link svelte-5rok69");
			add_location(a, file$2, 235, 12, 7803);
			add_location(span, file$2, 233, 10, 7713);
			attr_dev(label4, "class", "checkbox-label svelte-5rok69");
			add_location(label4, file$2, 227, 8, 7543);
			attr_dev(div12, "class", "form-group privacy-checkbox svelte-5rok69");
			add_location(div12, file$2, 226, 6, 7493);
			attr_dev(div13, "class", "form-section svelte-5rok69");
			add_location(div13, file$2, 225, 4, 7460);
			attr_dev(button, "type", "submit");
			attr_dev(button, "class", "submit-button svelte-5rok69");
			button.disabled = /*isSubmitting*/ ctx[4];
			add_location(button, file$2, 247, 6, 8156);
			attr_dev(div14, "class", "form-actions svelte-5rok69");
			add_location(div14, file$2, 246, 4, 8123);
			attr_dev(form, "class", "booking-form svelte-5rok69");
			add_location(form, file$2, 120, 2, 3843);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, form, anchor);
			append_dev(form, div1);
			append_dev(div1, h30);
			append_dev(h30, t0);
			append_dev(div1, t1);
			append_dev(div1, div0);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(div0, null);
				}
			}

			append_dev(div1, t2);
			if (if_block0) if_block0.m(div1, null);
			append_dev(form, t3);
			append_dev(form, div3);
			append_dev(div3, h31);
			append_dev(h31, t4);
			append_dev(div3, t5);
			append_dev(div3, div2);
			append_dev(div2, label0);
			append_dev(label0, t6);
			append_dev(div2, t7);
			append_dev(div2, input0);
			set_input_value(input0, /*formData*/ ctx[2].date);
			append_dev(div2, t8);
			if (if_block1) if_block1.m(div2, null);
			append_dev(form, t9);
			append_dev(form, div4);
			mount_component(timeslotselector, div4, null);
			append_dev(div4, t10);
			if (if_block2) if_block2.m(div4, null);
			append_dev(form, t11);
			append_dev(form, div5);
			mount_component(personalinfoform, div5, null);
			append_dev(form, t12);
			append_dev(form, div9);
			append_dev(div9, h32);
			append_dev(h32, t13);
			append_dev(div9, t14);
			append_dev(div9, div6);
			append_dev(div6, label1);
			append_dev(label1, t15);
			append_dev(div6, t16);
			append_dev(div6, input1);
			set_input_value(input1, /*formData*/ ctx[2].carModel);
			append_dev(div9, t17);
			append_dev(div9, div7);
			append_dev(div7, label2);
			append_dev(label2, t18);
			append_dev(div7, t19);
			append_dev(div7, input2);
			set_input_value(input2, /*formData*/ ctx[2].licensePlate);
			append_dev(div9, t20);
			append_dev(div9, div8);
			append_dev(div8, label3);
			append_dev(label3, t21);
			append_dev(div8, t22);
			append_dev(div8, select);
			append_dev(select, option0);
			append_dev(select, option1);
			select_option(select, /*formData*/ ctx[2].tireCount, true);
			append_dev(form, t25);
			append_dev(form, div11);
			append_dev(div11, h33);
			append_dev(h33, t26);
			append_dev(div11, t27);
			append_dev(div11, div10);
			append_dev(div10, textarea);
			set_input_value(textarea, /*formData*/ ctx[2].notes);
			append_dev(form, t28);
			append_dev(form, div13);
			append_dev(div13, div12);
			append_dev(div12, label4);
			append_dev(label4, input3);
			input3.checked = /*formData*/ ctx[2].acceptPrivacy;
			append_dev(label4, t29);
			append_dev(label4, span);
			append_dev(span, t30);
			append_dev(span, t31);
			append_dev(span, a);
			append_dev(a, t32);
			append_dev(div12, t33);
			if (if_block3) if_block3.m(div12, null);
			append_dev(form, t34);
			append_dev(form, div14);
			append_dev(div14, button);
			if_blocks[current_block_type_index].m(button, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(input0, "input", /*input0_input_handler*/ ctx[10]),
					listen_dev(input1, "input", /*input1_input_handler*/ ctx[13]),
					listen_dev(input2, "input", /*input2_input_handler*/ ctx[14]),
					listen_dev(select, "change", /*select_change_handler*/ ctx[15]),
					listen_dev(textarea, "input", /*textarea_input_handler*/ ctx[16]),
					listen_dev(input3, "change", /*input3_change_handler*/ ctx[17]),
					listen_dev(form, "submit", prevent_default(/*handleSubmit*/ ctx[7]), false, true, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if ((!current || dirty & /*content, currentLang*/ 3) && t0_value !== (t0_value = /*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.tireService.serviceType + "")) set_data_dev(t0, t0_value);

			if (dirty & /*serviceTypes, formData*/ 36) {
				each_value = /*serviceTypes*/ ctx[5];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div0, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (/*errors*/ ctx[3].serviceType) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_4$2(ctx);
					if_block0.c();
					if_block0.m(div1, null);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if ((!current || dirty & /*content, currentLang*/ 3) && t4_value !== (t4_value = (/*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.tireService.dateTime || 'Select Date & Time') + "")) set_data_dev(t4, t4_value);
			if ((!current || dirty & /*content, currentLang*/ 3) && t6_value !== (t6_value = (/*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.carWash.date || 'Date') + "")) set_data_dev(t6, t6_value);

			if (dirty & /*formData*/ 4) {
				set_input_value(input0, /*formData*/ ctx[2].date);
			}

			if (!current || dirty & /*errors*/ 8) {
				toggle_class(input0, "error", /*errors*/ ctx[3].date);
			}

			if (/*errors*/ ctx[3].date) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_3$2(ctx);
					if_block1.c();
					if_block1.m(div2, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			const timeslotselector_changes = {};
			if (dirty & /*formData*/ 4) timeslotselector_changes.selectedTime = /*formData*/ ctx[2].time;
			if (dirty & /*content*/ 1) timeslotselector_changes.content = /*content*/ ctx[0];
			if (dirty & /*currentLang*/ 2) timeslotselector_changes.currentLang = /*currentLang*/ ctx[1];
			if (dirty & /*formData*/ 4) timeslotselector_changes.date = /*formData*/ ctx[2].date;
			timeslotselector.$set(timeslotselector_changes);

			if (/*errors*/ ctx[3].time) {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block_2$2(ctx);
					if_block2.c();
					if_block2.m(div4, null);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			if (!current || dirty & /*errors*/ 8) {
				toggle_class(div4, "error", /*errors*/ ctx[3].time);
			}

			const personalinfoform_changes = {};
			if (dirty & /*content*/ 1) personalinfoform_changes.content = /*content*/ ctx[0];
			if (dirty & /*currentLang*/ 2) personalinfoform_changes.currentLang = /*currentLang*/ ctx[1];
			if (dirty & /*isSubmitting*/ 16) personalinfoform_changes.isSubmitting = /*isSubmitting*/ ctx[4];

			if (!updating_formData && dirty & /*formData*/ 4) {
				updating_formData = true;
				personalinfoform_changes.formData = /*formData*/ ctx[2];
				add_flush_callback(() => updating_formData = false);
			}

			if (!updating_formErrors && dirty & /*errors*/ 8) {
				updating_formErrors = true;
				personalinfoform_changes.formErrors = /*errors*/ ctx[3];
				add_flush_callback(() => updating_formErrors = false);
			}

			personalinfoform.$set(personalinfoform_changes);
			if ((!current || dirty & /*content, currentLang*/ 3) && t13_value !== (t13_value = (/*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.tireService.carDetails || 'Car Details') + "")) set_data_dev(t13, t13_value);
			if ((!current || dirty & /*content, currentLang*/ 3) && t15_value !== (t15_value = (/*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.tireService.carModel || 'Car Model') + "")) set_data_dev(t15, t15_value);

			if (!current || dirty & /*content, currentLang*/ 3 && input1_placeholder_value !== (input1_placeholder_value = /*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.tireService.carModelPlaceholder || 'e.g. Toyota Corolla 2018')) {
				attr_dev(input1, "placeholder", input1_placeholder_value);
			}

			if (dirty & /*formData*/ 4 && input1.value !== /*formData*/ ctx[2].carModel) {
				set_input_value(input1, /*formData*/ ctx[2].carModel);
			}

			if ((!current || dirty & /*content, currentLang*/ 3) && t18_value !== (t18_value = (/*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.tireService.licensePlate || 'License Plate') + "")) set_data_dev(t18, t18_value);

			if (!current || dirty & /*content, currentLang*/ 3 && input2_placeholder_value !== (input2_placeholder_value = /*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.tireService.licensePlatePlaceholder || 'e.g. ABC-123')) {
				attr_dev(input2, "placeholder", input2_placeholder_value);
			}

			if (dirty & /*formData*/ 4 && input2.value !== /*formData*/ ctx[2].licensePlate) {
				set_input_value(input2, /*formData*/ ctx[2].licensePlate);
			}

			if ((!current || dirty & /*content, currentLang*/ 3) && t21_value !== (t21_value = (/*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.tireService.tireCount || 'Number of Tires') + "")) set_data_dev(t21, t21_value);

			if (dirty & /*formData*/ 4) {
				select_option(select, /*formData*/ ctx[2].tireCount);
			}

			if ((!current || dirty & /*content, currentLang*/ 3) && t26_value !== (t26_value = (/*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.tireService.notes || 'Additional Notes') + "")) set_data_dev(t26, t26_value);

			if (!current || dirty & /*content, currentLang*/ 3 && textarea_placeholder_value !== (textarea_placeholder_value = /*content*/ ctx[0][/*currentLang*/ ctx[1]].bookingForm.tireService.notesPlaceholder || 'Any special requests or additional information')) {
				attr_dev(textarea, "placeholder", textarea_placeholder_value);
			}

			if (dirty & /*formData*/ 4) {
				set_input_value(textarea, /*formData*/ ctx[2].notes);
			}

			if (dirty & /*formData*/ 4) {
				input3.checked = /*formData*/ ctx[2].acceptPrivacy;
			}

			if ((!current || dirty & /*currentLang*/ 2) && t30_value !== (t30_value = (/*currentLang*/ ctx[1] === 'hu'
			? 'Elfogadom az '
			: 'I accept the ') + "")) set_data_dev(t30, t30_value);

			if ((!current || dirty & /*currentLang*/ 2) && t32_value !== (t32_value = (/*currentLang*/ ctx[1] === 'hu'
			? 'Adatvédelmi irányelveket'
			: 'Privacy Policy') + "")) set_data_dev(t32, t32_value);

			if (/*errors*/ ctx[3].acceptPrivacy) {
				if (if_block3) {
					if_block3.p(ctx, dirty);
				} else {
					if_block3 = create_if_block_1$2(ctx);
					if_block3.c();
					if_block3.m(div12, null);
				}
			} else if (if_block3) {
				if_block3.d(1);
				if_block3 = null;
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block4 = if_blocks[current_block_type_index];

				if (!if_block4) {
					if_block4 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block4.c();
				} else {
					if_block4.p(ctx, dirty);
				}

				transition_in(if_block4, 1);
				if_block4.m(button, null);
			}

			if (!current || dirty & /*isSubmitting*/ 16) {
				prop_dev(button, "disabled", /*isSubmitting*/ ctx[4]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(timeslotselector.$$.fragment, local);
			transition_in(personalinfoform.$$.fragment, local);
			transition_in(if_block4);
			current = true;
		},
		o: function outro(local) {
			transition_out(timeslotselector.$$.fragment, local);
			transition_out(personalinfoform.$$.fragment, local);
			transition_out(if_block4);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(form);
			destroy_each(each_blocks, detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			destroy_component(timeslotselector);
			if (if_block2) if_block2.d();
			destroy_component(personalinfoform);
			if (if_block3) if_block3.d();
			if_blocks[current_block_type_index].d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	let serviceTypes;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('TireServiceForm', slots, []);
	const dispatch = createEventDispatcher();
	let { content } = $$props;
	let { currentLang } = $$props;

	let formData = {
		serviceType: '',
		date: new Date().toISOString().split('T')[0],
		time: '',
		firstName: '',
		lastName: '',
		email: '',
		phone: '',
		carModel: '',
		licensePlate: '',
		tireCount: 4,
		notes: '',
		acceptPrivacy: false
	};

	let errors = {};
	let isSubmitting = false;

	function validateForm() {
		$$invalidate(3, errors = {});
		let isValid = true;

		if (!formData.serviceType) {
			$$invalidate(
				3,
				errors.serviceType = currentLang === 'hu'
				? 'Kérjük válasszon szolgáltatást'
				: 'Please select a service type',
				errors
			);

			isValid = false;
		}

		if (!formData.date) {
			$$invalidate(
				3,
				errors.date = currentLang === 'hu'
				? 'Kérjük válasszon dátumot'
				: 'Please select a date',
				errors
			);

			isValid = false;
		}

		if (!formData.time) {
			$$invalidate(
				3,
				errors.time = currentLang === 'hu'
				? 'Kérjük válasszon időpontot'
				: 'Please select a time',
				errors
			);

			isValid = false;
		}

		if (!formData.firstName) {
			$$invalidate(
				3,
				errors.firstName = currentLang === 'hu'
				? 'Kérjük adja meg a keresztnevét'
				: 'Please enter your first name',
				errors
			);

			isValid = false;
		}

		if (!formData.lastName) {
			$$invalidate(
				3,
				errors.lastName = currentLang === 'hu'
				? 'Kérjük adja meg a vezetéknevét'
				: 'Please enter your last name',
				errors
			);

			isValid = false;
		}

		if (!formData.phone) {
			$$invalidate(
				3,
				errors.phone = currentLang === 'hu'
				? 'Kérjük adja meg telefonszámát'
				: 'Please enter your phone number',
				errors
			);

			isValid = false;
		}

		if (!formData.email) {
			$$invalidate(
				3,
				errors.email = currentLang === 'hu'
				? 'Kérjük adja meg email címét'
				: 'Please enter your email address',
				errors
			);

			isValid = false;
		} else if (!(/^[^\s@]+@[^\s@]+\.[^\s@]+$/).test(formData.email)) {
			$$invalidate(
				3,
				errors.email = currentLang === 'hu'
				? 'Érvénytelen email cím'
				: 'Invalid email address',
				errors
			);

			isValid = false;
		}

		return isValid;
	}

	function handleTimeSelected(event) {
		$$invalidate(2, formData.time = event.detail, formData);
		$$invalidate(3, errors.time = '', errors); // Clear error when time is selected
	}

	async function handleSubmit() {
		if (!validateForm()) return;
		$$invalidate(4, isSubmitting = true);

		try {
			const bookingData = {
				service: 'tireService',
				serviceType: formData.serviceType,
				date: formData.date,
				time: formData.time,
				name: `${formData.lastName} ${formData.firstName}`,
				contact: {
					email: formData.email,
					phone: formData.phone
				},
				carModel: formData.carModel,
				licensePlate: formData.licensePlate,
				tireCount: formData.tireCount,
				notes: formData.notes,
				// Add admin email for backend
				adminEmail: 'jarsunkaev@gmail.com'
			};

			dispatch('bookingComplete', bookingData);
		} catch(error) {
			console.error('Error submitting form:', error);
		} finally {
			$$invalidate(4, isSubmitting = false);
		}
	}

	$$self.$$.on_mount.push(function () {
		if (content === undefined && !('content' in $$props || $$self.$$.bound[$$self.$$.props['content']])) {
			console_1$1.warn("<TireServiceForm> was created without expected prop 'content'");
		}

		if (currentLang === undefined && !('currentLang' in $$props || $$self.$$.bound[$$self.$$.props['currentLang']])) {
			console_1$1.warn("<TireServiceForm> was created without expected prop 'currentLang'");
		}
	});

	const writable_props = ['content', 'currentLang'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$1.warn(`<TireServiceForm> was created with unknown prop '${key}'`);
	});

	const $$binding_groups = [[]];

	function input_change_handler() {
		formData.serviceType = this.__value;
		$$invalidate(2, formData);
	}

	function input0_input_handler() {
		formData.date = this.value;
		$$invalidate(2, formData);
	}

	function personalinfoform_formData_binding(value) {
		formData = value;
		$$invalidate(2, formData);
	}

	function personalinfoform_formErrors_binding(value) {
		errors = value;
		$$invalidate(3, errors);
	}

	function input1_input_handler() {
		formData.carModel = this.value;
		$$invalidate(2, formData);
	}

	function input2_input_handler() {
		formData.licensePlate = this.value;
		$$invalidate(2, formData);
	}

	function select_change_handler() {
		formData.tireCount = select_value(this);
		$$invalidate(2, formData);
	}

	function textarea_input_handler() {
		formData.notes = this.value;
		$$invalidate(2, formData);
	}

	function input3_change_handler() {
		formData.acceptPrivacy = this.checked;
		$$invalidate(2, formData);
	}

	$$self.$$set = $$props => {
		if ('content' in $$props) $$invalidate(0, content = $$props.content);
		if ('currentLang' in $$props) $$invalidate(1, currentLang = $$props.currentLang);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		PersonalInfoForm,
		TimeSlotSelector,
		LoadingSpinner,
		dispatch,
		content,
		currentLang,
		formData,
		errors,
		isSubmitting,
		validateForm,
		handleTimeSelected,
		handleSubmit,
		serviceTypes
	});

	$$self.$inject_state = $$props => {
		if ('content' in $$props) $$invalidate(0, content = $$props.content);
		if ('currentLang' in $$props) $$invalidate(1, currentLang = $$props.currentLang);
		if ('formData' in $$props) $$invalidate(2, formData = $$props.formData);
		if ('errors' in $$props) $$invalidate(3, errors = $$props.errors);
		if ('isSubmitting' in $$props) $$invalidate(4, isSubmitting = $$props.isSubmitting);
		if ('serviceTypes' in $$props) $$invalidate(5, serviceTypes = $$props.serviceTypes);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*content, currentLang*/ 3) {
			// Create service types with reactive changes on language toggle
			$$invalidate(5, serviceTypes = [
				{
					value: 'change',
					label: content[currentLang].bookingForm.tireService.serviceOptions.change
				},
				{
					value: 'repair',
					label: content[currentLang].bookingForm.tireService.serviceOptions.repair
				},
				{
					value: 'balancing',
					label: content[currentLang].bookingForm.tireService.serviceOptions.balancing
				},
				{
					value: 'storage',
					label: content[currentLang].bookingForm.tireService.serviceOptions.storage
				}
			]);
		}
	};

	return [
		content,
		currentLang,
		formData,
		errors,
		isSubmitting,
		serviceTypes,
		handleTimeSelected,
		handleSubmit,
		input_change_handler,
		$$binding_groups,
		input0_input_handler,
		personalinfoform_formData_binding,
		personalinfoform_formErrors_binding,
		input1_input_handler,
		input2_input_handler,
		select_change_handler,
		textarea_input_handler,
		input3_change_handler
	];
}

class TireServiceForm extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, { content: 0, currentLang: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "TireServiceForm",
			options,
			id: create_fragment$2.name
		});
	}

	get content() {
		throw new Error("<TireServiceForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set content(value) {
		throw new Error("<TireServiceForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get currentLang() {
		throw new Error("<TireServiceForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set currentLang(value) {
		throw new Error("<TireServiceForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/BookingConfirmation.svelte generated by Svelte v3.59.2 */
const file$1 = "src/components/BookingConfirmation.svelte";

// (49:65) 
function create_if_block_22(ctx) {
	let t_value = /*content*/ ctx[1][/*currentLang*/ ctx[2]].services.tireService.title + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*content, currentLang*/ 6 && t_value !== (t_value = /*content*/ ctx[1][/*currentLang*/ ctx[2]].services.tireService.title + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_22.name,
		type: "if",
		source: "(49:65) ",
		ctx
	});

	return block;
}

// (47:65) 
function create_if_block_21(ctx) {
	let t_value = /*content*/ ctx[1][/*currentLang*/ ctx[2]].services.autoService.title + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*content, currentLang*/ 6 && t_value !== (t_value = /*content*/ ctx[1][/*currentLang*/ ctx[2]].services.autoService.title + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_21.name,
		type: "if",
		source: "(47:65) ",
		ctx
	});

	return block;
}

// (45:61) 
function create_if_block_20(ctx) {
	let t_value = /*content*/ ctx[1][/*currentLang*/ ctx[2]].services.carWash.title + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*content, currentLang*/ 6 && t_value !== (t_value = /*content*/ ctx[1][/*currentLang*/ ctx[2]].services.carWash.title + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_20.name,
		type: "if",
		source: "(45:61) ",
		ctx
	});

	return block;
}

// (43:14) {#if bookingDetails.service === 'airportParking'}
function create_if_block_19(ctx) {
	let t_value = /*content*/ ctx[1][/*currentLang*/ ctx[2]].services.airportParking.title + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*content, currentLang*/ 6 && t_value !== (t_value = /*content*/ ctx[1][/*currentLang*/ ctx[2]].services.airportParking.title + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_19.name,
		type: "if",
		source: "(43:14) {#if bookingDetails.service === 'airportParking'}",
		ctx
	});

	return block;
}

// (61:14) {:else}
function create_else_block_2(ctx) {
	let t_value = /*bookingDetails*/ ctx[0].date + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*bookingDetails*/ 1 && t_value !== (t_value = /*bookingDetails*/ ctx[0].date + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_2.name,
		type: "else",
		source: "(61:14) {:else}",
		ctx
	});

	return block;
}

// (58:14) {#if bookingDetails.service === 'airportParking'}
function create_if_block_18(ctx) {
	let t0_value = (/*currentLang*/ ctx[2] === 'hu' ? 'Érkezés' : 'Arrival') + "";
	let t0;
	let t1;
	let t2_value = /*bookingDetails*/ ctx[0].date.split(' - ')[0] + "";
	let t2;
	let br;
	let t3;

	let t4_value = (/*currentLang*/ ctx[2] === 'hu'
	? 'Távozás'
	: 'Departure') + "";

	let t4;
	let t5;
	let t6_value = /*bookingDetails*/ ctx[0].date.split(' - ')[1] + "";
	let t6;

	const block = {
		c: function create() {
			t0 = text(t0_value);
			t1 = text(": ");
			t2 = text(t2_value);
			br = element("br");
			t3 = space();
			t4 = text(t4_value);
			t5 = text(": ");
			t6 = text(t6_value);
			add_location(br, file$1, 58, 101, 2570);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, t1, anchor);
			insert_dev(target, t2, anchor);
			insert_dev(target, br, anchor);
			insert_dev(target, t3, anchor);
			insert_dev(target, t4, anchor);
			insert_dev(target, t5, anchor);
			insert_dev(target, t6, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*currentLang*/ 4 && t0_value !== (t0_value = (/*currentLang*/ ctx[2] === 'hu' ? 'Érkezés' : 'Arrival') + "")) set_data_dev(t0, t0_value);
			if (dirty & /*bookingDetails*/ 1 && t2_value !== (t2_value = /*bookingDetails*/ ctx[0].date.split(' - ')[0] + "")) set_data_dev(t2, t2_value);

			if (dirty & /*currentLang*/ 4 && t4_value !== (t4_value = (/*currentLang*/ ctx[2] === 'hu'
			? 'Távozás'
			: 'Departure') + "")) set_data_dev(t4, t4_value);

			if (dirty & /*bookingDetails*/ 1 && t6_value !== (t6_value = /*bookingDetails*/ ctx[0].date.split(' - ')[1] + "")) set_data_dev(t6, t6_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(t2);
			if (detaching) detach_dev(br);
			if (detaching) detach_dev(t3);
			if (detaching) detach_dev(t4);
			if (detaching) detach_dev(t5);
			if (detaching) detach_dev(t6);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_18.name,
		type: "if",
		source: "(58:14) {#if bookingDetails.service === 'airportParking'}",
		ctx
	});

	return block;
}

// (67:10) {#if bookingDetails.time}
function create_if_block_17(ctx) {
	let div;
	let span0;
	let t0_value = /*content*/ ctx[1][/*currentLang*/ ctx[2]].confirmation.time + "";
	let t0;
	let t1;
	let t2;
	let span1;
	let t3_value = /*bookingDetails*/ ctx[0].time + "";
	let t3;

	const block = {
		c: function create() {
			div = element("div");
			span0 = element("span");
			t0 = text(t0_value);
			t1 = text(":");
			t2 = space();
			span1 = element("span");
			t3 = text(t3_value);
			attr_dev(span0, "class", "detail-label svelte-10tkxda");
			add_location(span0, file$1, 68, 14, 2885);
			attr_dev(span1, "class", "detail-value svelte-10tkxda");
			add_location(span1, file$1, 69, 14, 2975);
			attr_dev(div, "class", "detail-item svelte-10tkxda");
			add_location(div, file$1, 67, 12, 2845);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, span0);
			append_dev(span0, t0);
			append_dev(span0, t1);
			append_dev(div, t2);
			append_dev(div, span1);
			append_dev(span1, t3);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*content, currentLang*/ 6 && t0_value !== (t0_value = /*content*/ ctx[1][/*currentLang*/ ctx[2]].confirmation.time + "")) set_data_dev(t0, t0_value);
			if (dirty & /*bookingDetails*/ 1 && t3_value !== (t3_value = /*bookingDetails*/ ctx[0].time + "")) set_data_dev(t3, t3_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_17.name,
		type: "if",
		source: "(67:10) {#if bookingDetails.time}",
		ctx
	});

	return block;
}

// (74:10) {#if bookingDetails.serviceType}
function create_if_block_8$1(ctx) {
	let div;
	let span0;

	let t0_value = (/*currentLang*/ ctx[2] === 'hu'
	? 'Szolgáltatás típusa'
	: 'Service type') + "";

	let t0;
	let t1;
	let t2;
	let span1;

	function select_block_type_2(ctx, dirty) {
		if (/*bookingDetails*/ ctx[0].service === 'autoService') return create_if_block_9;
		if (/*bookingDetails*/ ctx[0].service === 'tireService') return create_if_block_13;
	}

	let current_block_type = select_block_type_2(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	const block = {
		c: function create() {
			div = element("div");
			span0 = element("span");
			t0 = text(t0_value);
			t1 = text(":");
			t2 = space();
			span1 = element("span");
			if (if_block) if_block.c();
			attr_dev(span0, "class", "detail-label svelte-10tkxda");
			add_location(span0, file$1, 75, 14, 3162);
			attr_dev(span1, "class", "detail-value svelte-10tkxda");
			add_location(span1, file$1, 76, 14, 3275);
			attr_dev(div, "class", "detail-item svelte-10tkxda");
			add_location(div, file$1, 74, 12, 3122);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, span0);
			append_dev(span0, t0);
			append_dev(span0, t1);
			append_dev(div, t2);
			append_dev(div, span1);
			if (if_block) if_block.m(span1, null);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*currentLang*/ 4 && t0_value !== (t0_value = (/*currentLang*/ ctx[2] === 'hu'
			? 'Szolgáltatás típusa'
			: 'Service type') + "")) set_data_dev(t0, t0_value);

			if (current_block_type === (current_block_type = select_block_type_2(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(span1, null);
				}
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);

			if (if_block) {
				if_block.d();
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_8$1.name,
		type: "if",
		source: "(74:10) {#if bookingDetails.serviceType}",
		ctx
	});

	return block;
}

// (88:67) 
function create_if_block_13(ctx) {
	let if_block_anchor;

	function select_block_type_4(ctx, dirty) {
		if (/*bookingDetails*/ ctx[0].serviceType === 'change') return create_if_block_14;
		if (/*bookingDetails*/ ctx[0].serviceType === 'repair') return create_if_block_15;
		if (/*bookingDetails*/ ctx[0].serviceType === 'balancing') return create_if_block_16;
		return create_else_block_1;
	}

	let current_block_type = select_block_type_4(ctx);
	let if_block = current_block_type(ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type_4(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		d: function destroy(detaching) {
			if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_13.name,
		type: "if",
		source: "(88:67) ",
		ctx
	});

	return block;
}

// (78:16) {#if bookingDetails.service === 'autoService'}
function create_if_block_9(ctx) {
	let if_block_anchor;

	function select_block_type_3(ctx, dirty) {
		if (/*bookingDetails*/ ctx[0].serviceType === 'maintenance') return create_if_block_10;
		if (/*bookingDetails*/ ctx[0].serviceType === 'repair') return create_if_block_11;
		if (/*bookingDetails*/ ctx[0].serviceType === 'diagnostic') return create_if_block_12;
		return create_else_block$1;
	}

	let current_block_type = select_block_type_3(ctx);
	let if_block = current_block_type(ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type_3(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		d: function destroy(detaching) {
			if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_9.name,
		type: "if",
		source: "(78:16) {#if bookingDetails.service === 'autoService'}",
		ctx
	});

	return block;
}

// (95:18) {:else}
function create_else_block_1(ctx) {
	let t_value = /*content*/ ctx[1][/*currentLang*/ ctx[2]].bookingForm.tireService.serviceOptions.storage + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*content, currentLang*/ 6 && t_value !== (t_value = /*content*/ ctx[1][/*currentLang*/ ctx[2]].bookingForm.tireService.serviceOptions.storage + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1.name,
		type: "else",
		source: "(95:18) {:else}",
		ctx
	});

	return block;
}

// (93:71) 
function create_if_block_16(ctx) {
	let t_value = /*content*/ ctx[1][/*currentLang*/ ctx[2]].bookingForm.tireService.serviceOptions.balancing + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*content, currentLang*/ 6 && t_value !== (t_value = /*content*/ ctx[1][/*currentLang*/ ctx[2]].bookingForm.tireService.serviceOptions.balancing + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_16.name,
		type: "if",
		source: "(93:71) ",
		ctx
	});

	return block;
}

// (91:68) 
function create_if_block_15(ctx) {
	let t_value = /*content*/ ctx[1][/*currentLang*/ ctx[2]].bookingForm.tireService.serviceOptions.repair + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*content, currentLang*/ 6 && t_value !== (t_value = /*content*/ ctx[1][/*currentLang*/ ctx[2]].bookingForm.tireService.serviceOptions.repair + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_15.name,
		type: "if",
		source: "(91:68) ",
		ctx
	});

	return block;
}

// (89:18) {#if bookingDetails.serviceType === 'change'}
function create_if_block_14(ctx) {
	let t_value = /*content*/ ctx[1][/*currentLang*/ ctx[2]].bookingForm.tireService.serviceOptions.change + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*content, currentLang*/ 6 && t_value !== (t_value = /*content*/ ctx[1][/*currentLang*/ ctx[2]].bookingForm.tireService.serviceOptions.change + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_14.name,
		type: "if",
		source: "(89:18) {#if bookingDetails.serviceType === 'change'}",
		ctx
	});

	return block;
}

// (85:18) {:else}
function create_else_block$1(ctx) {
	let t_value = /*content*/ ctx[1][/*currentLang*/ ctx[2]].bookingForm.autoService.serviceOptions.other + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*content, currentLang*/ 6 && t_value !== (t_value = /*content*/ ctx[1][/*currentLang*/ ctx[2]].bookingForm.autoService.serviceOptions.other + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$1.name,
		type: "else",
		source: "(85:18) {:else}",
		ctx
	});

	return block;
}

// (83:72) 
function create_if_block_12(ctx) {
	let t_value = /*content*/ ctx[1][/*currentLang*/ ctx[2]].bookingForm.autoService.serviceOptions.diagnostic + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*content, currentLang*/ 6 && t_value !== (t_value = /*content*/ ctx[1][/*currentLang*/ ctx[2]].bookingForm.autoService.serviceOptions.diagnostic + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_12.name,
		type: "if",
		source: "(83:72) ",
		ctx
	});

	return block;
}

// (81:68) 
function create_if_block_11(ctx) {
	let t_value = /*content*/ ctx[1][/*currentLang*/ ctx[2]].bookingForm.autoService.serviceOptions.repair + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*content, currentLang*/ 6 && t_value !== (t_value = /*content*/ ctx[1][/*currentLang*/ ctx[2]].bookingForm.autoService.serviceOptions.repair + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_11.name,
		type: "if",
		source: "(81:68) ",
		ctx
	});

	return block;
}

// (79:18) {#if bookingDetails.serviceType === 'maintenance'}
function create_if_block_10(ctx) {
	let t_value = /*content*/ ctx[1][/*currentLang*/ ctx[2]].bookingForm.autoService.serviceOptions.maintenance + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*content, currentLang*/ 6 && t_value !== (t_value = /*content*/ ctx[1][/*currentLang*/ ctx[2]].bookingForm.autoService.serviceOptions.maintenance + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_10.name,
		type: "if",
		source: "(79:18) {#if bookingDetails.serviceType === 'maintenance'}",
		ctx
	});

	return block;
}

// (103:10) {#if bookingDetails.licensePlate}
function create_if_block_7$1(ctx) {
	let div;
	let span0;
	let t0_value = /*content*/ ctx[1][/*currentLang*/ ctx[2]].bookingForm.airportParking.licensePlate + "";
	let t0;
	let t1;
	let t2;
	let span1;
	let t3_value = /*bookingDetails*/ ctx[0].licensePlate + "";
	let t3;

	const block = {
		c: function create() {
			div = element("div");
			span0 = element("span");
			t0 = text(t0_value);
			t1 = text(":");
			t2 = space();
			span1 = element("span");
			t3 = text(t3_value);
			attr_dev(span0, "class", "detail-label svelte-10tkxda");
			add_location(span0, file$1, 104, 14, 4850);
			attr_dev(span1, "class", "detail-value svelte-10tkxda");
			add_location(span1, file$1, 105, 14, 4962);
			attr_dev(div, "class", "detail-item svelte-10tkxda");
			add_location(div, file$1, 103, 12, 4810);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, span0);
			append_dev(span0, t0);
			append_dev(span0, t1);
			append_dev(div, t2);
			append_dev(div, span1);
			append_dev(span1, t3);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*content, currentLang*/ 6 && t0_value !== (t0_value = /*content*/ ctx[1][/*currentLang*/ ctx[2]].bookingForm.airportParking.licensePlate + "")) set_data_dev(t0, t0_value);
			if (dirty & /*bookingDetails*/ 1 && t3_value !== (t3_value = /*bookingDetails*/ ctx[0].licensePlate + "")) set_data_dev(t3, t3_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_7$1.name,
		type: "if",
		source: "(103:10) {#if bookingDetails.licensePlate}",
		ctx
	});

	return block;
}

// (110:10) {#if bookingDetails.passengers}
function create_if_block_6$1(ctx) {
	let div;
	let span0;
	let t0_value = /*content*/ ctx[1][/*currentLang*/ ctx[2]].bookingForm.airportParking.passengers + "";
	let t0;
	let t1;
	let t2;
	let span1;
	let t3_value = /*bookingDetails*/ ctx[0].passengers + "";
	let t3;

	const block = {
		c: function create() {
			div = element("div");
			span0 = element("span");
			t0 = text(t0_value);
			t1 = text(":");
			t2 = space();
			span1 = element("span");
			t3 = text(t3_value);
			attr_dev(span0, "class", "detail-label svelte-10tkxda");
			add_location(span0, file$1, 111, 14, 5156);
			attr_dev(span1, "class", "detail-value svelte-10tkxda");
			add_location(span1, file$1, 112, 14, 5266);
			attr_dev(div, "class", "detail-item svelte-10tkxda");
			add_location(div, file$1, 110, 12, 5116);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, span0);
			append_dev(span0, t0);
			append_dev(span0, t1);
			append_dev(div, t2);
			append_dev(div, span1);
			append_dev(span1, t3);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*content, currentLang*/ 6 && t0_value !== (t0_value = /*content*/ ctx[1][/*currentLang*/ ctx[2]].bookingForm.airportParking.passengers + "")) set_data_dev(t0, t0_value);
			if (dirty & /*bookingDetails*/ 1 && t3_value !== (t3_value = /*bookingDetails*/ ctx[0].passengers + "")) set_data_dev(t3, t3_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_6$1.name,
		type: "if",
		source: "(110:10) {#if bookingDetails.passengers}",
		ctx
	});

	return block;
}

// (117:10) {#if bookingDetails.days}
function create_if_block_5$1(ctx) {
	let div;
	let span0;

	let t0_value = (/*currentLang*/ ctx[2] === 'hu'
	? 'Időtartam'
	: 'Duration') + "";

	let t0;
	let t1;
	let t2;
	let span1;
	let t3_value = /*bookingDetails*/ ctx[0].days + "";
	let t3;
	let t4;
	let t5_value = /*content*/ ctx[1][/*currentLang*/ ctx[2]].bookingForm.airportParking.days + "";
	let t5;

	const block = {
		c: function create() {
			div = element("div");
			span0 = element("span");
			t0 = text(t0_value);
			t1 = text(":");
			t2 = space();
			span1 = element("span");
			t3 = text(t3_value);
			t4 = space();
			t5 = text(t5_value);
			attr_dev(span0, "class", "detail-label svelte-10tkxda");
			add_location(span0, file$1, 118, 14, 5452);
			attr_dev(span1, "class", "detail-value svelte-10tkxda");
			add_location(span1, file$1, 119, 14, 5551);
			attr_dev(div, "class", "detail-item svelte-10tkxda");
			add_location(div, file$1, 117, 12, 5412);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, span0);
			append_dev(span0, t0);
			append_dev(span0, t1);
			append_dev(div, t2);
			append_dev(div, span1);
			append_dev(span1, t3);
			append_dev(span1, t4);
			append_dev(span1, t5);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*currentLang*/ 4 && t0_value !== (t0_value = (/*currentLang*/ ctx[2] === 'hu'
			? 'Időtartam'
			: 'Duration') + "")) set_data_dev(t0, t0_value);

			if (dirty & /*bookingDetails*/ 1 && t3_value !== (t3_value = /*bookingDetails*/ ctx[0].days + "")) set_data_dev(t3, t3_value);
			if (dirty & /*content, currentLang*/ 6 && t5_value !== (t5_value = /*content*/ ctx[1][/*currentLang*/ ctx[2]].bookingForm.airportParking.days + "")) set_data_dev(t5, t5_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_5$1.name,
		type: "if",
		source: "(117:10) {#if bookingDetails.days}",
		ctx
	});

	return block;
}

// (124:10) {#if bookingDetails.carWashPackage && bookingDetails.carWashPackage !== 'none'}
function create_if_block_4$1(ctx) {
	let div;
	let span0;
	let t0_value = /*content*/ ctx[1][/*currentLang*/ ctx[2]].bookingForm.airportParking.carWashOptions.title + "";
	let t0;
	let t1;
	let t2;
	let span1;
	let t3_value = /*bookingDetails*/ ctx[0].carWashPackageName + "";
	let t3;

	const block = {
		c: function create() {
			div = element("div");
			span0 = element("span");
			t0 = text(t0_value);
			t1 = text(":");
			t2 = space();
			span1 = element("span");
			t3 = text(t3_value);
			attr_dev(span0, "class", "detail-label svelte-10tkxda");
			add_location(span0, file$1, 125, 14, 5840);
			attr_dev(span1, "class", "detail-value svelte-10tkxda");
			add_location(span1, file$1, 126, 14, 5960);
			attr_dev(div, "class", "detail-item svelte-10tkxda");
			add_location(div, file$1, 124, 12, 5800);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, span0);
			append_dev(span0, t0);
			append_dev(span0, t1);
			append_dev(div, t2);
			append_dev(div, span1);
			append_dev(span1, t3);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*content, currentLang*/ 6 && t0_value !== (t0_value = /*content*/ ctx[1][/*currentLang*/ ctx[2]].bookingForm.airportParking.carWashOptions.title + "")) set_data_dev(t0, t0_value);
			if (dirty & /*bookingDetails*/ 1 && t3_value !== (t3_value = /*bookingDetails*/ ctx[0].carWashPackageName + "")) set_data_dev(t3, t3_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4$1.name,
		type: "if",
		source: "(124:10) {#if bookingDetails.carWashPackage && bookingDetails.carWashPackage !== 'none'}",
		ctx
	});

	return block;
}

// (133:10) {#if bookingDetails.priceBreakdown}
function create_if_block_2$1(ctx) {
	let div;
	let span0;
	let t0_value = /*content*/ ctx[1][/*currentLang*/ ctx[2]].bookingForm.airportParking.parkingTotal + "";
	let t0;
	let t1;
	let t2;
	let span1;
	let t3_value = formatCurrency(/*bookingDetails*/ ctx[0].priceBreakdown.parkingTotal) + "";
	let t3;
	let t4;
	let if_block_anchor;
	let if_block = /*bookingDetails*/ ctx[0].priceBreakdown.carWashStandard > 0 && create_if_block_3$1(ctx);

	const block = {
		c: function create() {
			div = element("div");
			span0 = element("span");
			t0 = text(t0_value);
			t1 = text(":");
			t2 = space();
			span1 = element("span");
			t3 = text(t3_value);
			t4 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			attr_dev(span0, "class", "detail-label svelte-10tkxda");
			add_location(span0, file$1, 134, 14, 6196);
			attr_dev(span1, "class", "detail-value svelte-10tkxda");
			add_location(span1, file$1, 135, 14, 6308);
			attr_dev(div, "class", "detail-item svelte-10tkxda");
			add_location(div, file$1, 133, 12, 6156);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, span0);
			append_dev(span0, t0);
			append_dev(span0, t1);
			append_dev(div, t2);
			append_dev(div, span1);
			append_dev(span1, t3);
			insert_dev(target, t4, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*content, currentLang*/ 6 && t0_value !== (t0_value = /*content*/ ctx[1][/*currentLang*/ ctx[2]].bookingForm.airportParking.parkingTotal + "")) set_data_dev(t0, t0_value);
			if (dirty & /*bookingDetails*/ 1 && t3_value !== (t3_value = formatCurrency(/*bookingDetails*/ ctx[0].priceBreakdown.parkingTotal) + "")) set_data_dev(t3, t3_value);

			if (/*bookingDetails*/ ctx[0].priceBreakdown.carWashStandard > 0) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_3$1(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (detaching) detach_dev(t4);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$1.name,
		type: "if",
		source: "(133:10) {#if bookingDetails.priceBreakdown}",
		ctx
	});

	return block;
}

// (138:12) {#if bookingDetails.priceBreakdown.carWashStandard > 0}
function create_if_block_3$1(ctx) {
	let div0;
	let span0;
	let t0_value = /*content*/ ctx[1][/*currentLang*/ ctx[2]].bookingForm.airportParking.carWashStandard + "";
	let t0;
	let t1;
	let t2;
	let span1;
	let t3_value = formatCurrency(/*bookingDetails*/ ctx[0].priceBreakdown.carWashStandard) + "";
	let t3;
	let t4;
	let div1;
	let span2;
	let t5_value = /*content*/ ctx[1][/*currentLang*/ ctx[2]].bookingForm.airportParking.carWashDiscount + "";
	let t5;
	let t6;
	let t7;
	let span3;
	let t8;
	let t9_value = formatCurrency(/*bookingDetails*/ ctx[0].priceBreakdown.carWashDiscount) + "";
	let t9;
	let t10;
	let div2;
	let span4;
	let t11_value = /*content*/ ctx[1][/*currentLang*/ ctx[2]].bookingForm.airportParking.carWashDiscounted + "";
	let t11;
	let t12;
	let t13;
	let span5;
	let t14_value = formatCurrency(/*bookingDetails*/ ctx[0].priceBreakdown.carWashDiscounted) + "";
	let t14;

	const block = {
		c: function create() {
			div0 = element("div");
			span0 = element("span");
			t0 = text(t0_value);
			t1 = text(":");
			t2 = space();
			span1 = element("span");
			t3 = text(t3_value);
			t4 = space();
			div1 = element("div");
			span2 = element("span");
			t5 = text(t5_value);
			t6 = text(":");
			t7 = space();
			span3 = element("span");
			t8 = text("- ");
			t9 = text(t9_value);
			t10 = space();
			div2 = element("div");
			span4 = element("span");
			t11 = text(t11_value);
			t12 = text(":");
			t13 = space();
			span5 = element("span");
			t14 = text(t14_value);
			attr_dev(span0, "class", "detail-label svelte-10tkxda");
			add_location(span0, file$1, 139, 16, 6546);
			attr_dev(span1, "class", "detail-value svelte-10tkxda");
			add_location(span1, file$1, 140, 16, 6663);
			attr_dev(div0, "class", "detail-item svelte-10tkxda");
			add_location(div0, file$1, 138, 14, 6504);
			attr_dev(span2, "class", "detail-label svelte-10tkxda");
			add_location(span2, file$1, 143, 16, 6838);
			attr_dev(span3, "class", "detail-value svelte-10tkxda");
			set_style(span3, "color", "#e53e3e");
			add_location(span3, file$1, 144, 16, 6955);
			attr_dev(div1, "class", "detail-item svelte-10tkxda");
			add_location(div1, file$1, 142, 14, 6796);
			attr_dev(span4, "class", "detail-label svelte-10tkxda");
			add_location(span4, file$1, 147, 16, 7156);
			attr_dev(span5, "class", "detail-value svelte-10tkxda");
			add_location(span5, file$1, 148, 16, 7275);
			attr_dev(div2, "class", "detail-item svelte-10tkxda");
			add_location(div2, file$1, 146, 14, 7114);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div0, anchor);
			append_dev(div0, span0);
			append_dev(span0, t0);
			append_dev(span0, t1);
			append_dev(div0, t2);
			append_dev(div0, span1);
			append_dev(span1, t3);
			insert_dev(target, t4, anchor);
			insert_dev(target, div1, anchor);
			append_dev(div1, span2);
			append_dev(span2, t5);
			append_dev(span2, t6);
			append_dev(div1, t7);
			append_dev(div1, span3);
			append_dev(span3, t8);
			append_dev(span3, t9);
			insert_dev(target, t10, anchor);
			insert_dev(target, div2, anchor);
			append_dev(div2, span4);
			append_dev(span4, t11);
			append_dev(span4, t12);
			append_dev(div2, t13);
			append_dev(div2, span5);
			append_dev(span5, t14);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*content, currentLang*/ 6 && t0_value !== (t0_value = /*content*/ ctx[1][/*currentLang*/ ctx[2]].bookingForm.airportParking.carWashStandard + "")) set_data_dev(t0, t0_value);
			if (dirty & /*bookingDetails*/ 1 && t3_value !== (t3_value = formatCurrency(/*bookingDetails*/ ctx[0].priceBreakdown.carWashStandard) + "")) set_data_dev(t3, t3_value);
			if (dirty & /*content, currentLang*/ 6 && t5_value !== (t5_value = /*content*/ ctx[1][/*currentLang*/ ctx[2]].bookingForm.airportParking.carWashDiscount + "")) set_data_dev(t5, t5_value);
			if (dirty & /*bookingDetails*/ 1 && t9_value !== (t9_value = formatCurrency(/*bookingDetails*/ ctx[0].priceBreakdown.carWashDiscount) + "")) set_data_dev(t9, t9_value);
			if (dirty & /*content, currentLang*/ 6 && t11_value !== (t11_value = /*content*/ ctx[1][/*currentLang*/ ctx[2]].bookingForm.airportParking.carWashDiscounted + "")) set_data_dev(t11, t11_value);
			if (dirty & /*bookingDetails*/ 1 && t14_value !== (t14_value = formatCurrency(/*bookingDetails*/ ctx[0].priceBreakdown.carWashDiscounted) + "")) set_data_dev(t14, t14_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div0);
			if (detaching) detach_dev(t4);
			if (detaching) detach_dev(div1);
			if (detaching) detach_dev(t10);
			if (detaching) detach_dev(div2);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3$1.name,
		type: "if",
		source: "(138:12) {#if bookingDetails.priceBreakdown.carWashStandard > 0}",
		ctx
	});

	return block;
}

// (154:10) {#if bookingDetails.totalPrice !== undefined}
function create_if_block_1$1(ctx) {
	let div;
	let span0;
	let t0_value = /*content*/ ctx[1][/*currentLang*/ ctx[2]].bookingForm.airportParking.totalPrice + "";
	let t0;
	let t1;
	let t2;
	let span1;
	let t3_value = formatCurrency(/*bookingDetails*/ ctx[0].totalPrice) + "";
	let t3;

	const block = {
		c: function create() {
			div = element("div");
			span0 = element("span");
			t0 = text(t0_value);
			t1 = text(":");
			t2 = space();
			span1 = element("span");
			t3 = text(t3_value);
			attr_dev(span0, "class", "detail-label svelte-10tkxda");
			add_location(span0, file$1, 155, 14, 7556);
			attr_dev(span1, "class", "detail-value total-price-value svelte-10tkxda");
			add_location(span1, file$1, 156, 14, 7666);
			attr_dev(div, "class", "detail-item total-price-item svelte-10tkxda");
			add_location(div, file$1, 154, 12, 7499);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, span0);
			append_dev(span0, t0);
			append_dev(span0, t1);
			append_dev(div, t2);
			append_dev(div, span1);
			append_dev(span1, t3);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*content, currentLang*/ 6 && t0_value !== (t0_value = /*content*/ ctx[1][/*currentLang*/ ctx[2]].bookingForm.airportParking.totalPrice + "")) set_data_dev(t0, t0_value);
			if (dirty & /*bookingDetails*/ 1 && t3_value !== (t3_value = formatCurrency(/*bookingDetails*/ ctx[0].totalPrice) + "")) set_data_dev(t3, t3_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$1.name,
		type: "if",
		source: "(154:10) {#if bookingDetails.totalPrice !== undefined}",
		ctx
	});

	return block;
}

// (170:14) {#if bookingDetails.contact.email}
function create_if_block$1(ctx) {
	let br;
	let t_value = /*bookingDetails*/ ctx[0].contact.email + "";
	let t;

	const block = {
		c: function create() {
			br = element("br");
			t = text(t_value);
			add_location(br, file$1, 170, 16, 8289);
		},
		m: function mount(target, anchor) {
			insert_dev(target, br, anchor);
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*bookingDetails*/ 1 && t_value !== (t_value = /*bookingDetails*/ ctx[0].contact.email + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(br);
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$1.name,
		type: "if",
		source: "(170:14) {#if bookingDetails.contact.email}",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let section;
	let div9;
	let div8;
	let div0;
	let svg;
	let path0;
	let path1;
	let t0;
	let h2;
	let t1_value = /*content*/ ctx[1][/*currentLang*/ ctx[2]].confirmation.title + "";
	let t1;
	let t2;
	let p0;
	let t3_value = /*content*/ ctx[1][/*currentLang*/ ctx[2]].confirmation.subtitle + "";
	let t3;
	let t4;
	let div6;
	let h3;
	let t5_value = /*content*/ ctx[1][/*currentLang*/ ctx[2]].confirmation.details + "";
	let t5;
	let t6;
	let div5;
	let div1;
	let span0;
	let t7_value = /*content*/ ctx[1][/*currentLang*/ ctx[2]].confirmation.service + "";
	let t7;
	let t8;
	let t9;
	let span1;
	let t10;
	let div2;
	let span2;
	let t11_value = /*content*/ ctx[1][/*currentLang*/ ctx[2]].confirmation.date + "";
	let t11;
	let t12;
	let t13;
	let span3;
	let t14;
	let t15;
	let t16;
	let t17;
	let t18;
	let t19;
	let t20;
	let t21;
	let t22;
	let div3;
	let span4;
	let t23_value = /*content*/ ctx[1][/*currentLang*/ ctx[2]].confirmation.name + "";
	let t23;
	let t24;
	let t25;
	let span5;
	let t26_value = /*bookingDetails*/ ctx[0].name + "";
	let t26;
	let t27;
	let div4;
	let span6;
	let t28_value = /*content*/ ctx[1][/*currentLang*/ ctx[2]].confirmation.contactInfo + "";
	let t28;
	let t29;
	let t30;
	let span7;
	let t31_value = /*bookingDetails*/ ctx[0].contact.phone + "";
	let t31;
	let t32;
	let t33;
	let p1;
	let t34_value = /*content*/ ctx[1][/*currentLang*/ ctx[2]].confirmation.emailSent + "";
	let t34;
	let t35;
	let div7;
	let button;
	let t36_value = /*content*/ ctx[1][/*currentLang*/ ctx[2]].confirmation.return + "";
	let t36;
	let section_transition;
	let current;
	let mounted;
	let dispose;

	function select_block_type(ctx, dirty) {
		if (/*bookingDetails*/ ctx[0].service === 'airportParking') return create_if_block_19;
		if (/*bookingDetails*/ ctx[0].service === 'carWash') return create_if_block_20;
		if (/*bookingDetails*/ ctx[0].service === 'autoService') return create_if_block_21;
		if (/*bookingDetails*/ ctx[0].service === 'tireService') return create_if_block_22;
	}

	let current_block_type = select_block_type(ctx);
	let if_block0 = current_block_type && current_block_type(ctx);

	function select_block_type_1(ctx, dirty) {
		if (/*bookingDetails*/ ctx[0].service === 'airportParking') return create_if_block_18;
		return create_else_block_2;
	}

	let current_block_type_1 = select_block_type_1(ctx);
	let if_block1 = current_block_type_1(ctx);
	let if_block2 = /*bookingDetails*/ ctx[0].time && create_if_block_17(ctx);
	let if_block3 = /*bookingDetails*/ ctx[0].serviceType && create_if_block_8$1(ctx);
	let if_block4 = /*bookingDetails*/ ctx[0].licensePlate && create_if_block_7$1(ctx);
	let if_block5 = /*bookingDetails*/ ctx[0].passengers && create_if_block_6$1(ctx);
	let if_block6 = /*bookingDetails*/ ctx[0].days && create_if_block_5$1(ctx);
	let if_block7 = /*bookingDetails*/ ctx[0].carWashPackage && /*bookingDetails*/ ctx[0].carWashPackage !== 'none' && create_if_block_4$1(ctx);
	let if_block8 = /*bookingDetails*/ ctx[0].priceBreakdown && create_if_block_2$1(ctx);
	let if_block9 = /*bookingDetails*/ ctx[0].totalPrice !== undefined && create_if_block_1$1(ctx);
	let if_block10 = /*bookingDetails*/ ctx[0].contact.email && create_if_block$1(ctx);

	const block = {
		c: function create() {
			section = element("section");
			div9 = element("div");
			div8 = element("div");
			div0 = element("div");
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			t0 = space();
			h2 = element("h2");
			t1 = text(t1_value);
			t2 = space();
			p0 = element("p");
			t3 = text(t3_value);
			t4 = space();
			div6 = element("div");
			h3 = element("h3");
			t5 = text(t5_value);
			t6 = space();
			div5 = element("div");
			div1 = element("div");
			span0 = element("span");
			t7 = text(t7_value);
			t8 = text(":");
			t9 = space();
			span1 = element("span");
			if (if_block0) if_block0.c();
			t10 = space();
			div2 = element("div");
			span2 = element("span");
			t11 = text(t11_value);
			t12 = text(":");
			t13 = space();
			span3 = element("span");
			if_block1.c();
			t14 = space();
			if (if_block2) if_block2.c();
			t15 = space();
			if (if_block3) if_block3.c();
			t16 = space();
			if (if_block4) if_block4.c();
			t17 = space();
			if (if_block5) if_block5.c();
			t18 = space();
			if (if_block6) if_block6.c();
			t19 = space();
			if (if_block7) if_block7.c();
			t20 = space();
			if (if_block8) if_block8.c();
			t21 = space();
			if (if_block9) if_block9.c();
			t22 = space();
			div3 = element("div");
			span4 = element("span");
			t23 = text(t23_value);
			t24 = text(":");
			t25 = space();
			span5 = element("span");
			t26 = text(t26_value);
			t27 = space();
			div4 = element("div");
			span6 = element("span");
			t28 = text(t28_value);
			t29 = text(":");
			t30 = space();
			span7 = element("span");
			t31 = text(t31_value);
			t32 = space();
			if (if_block10) if_block10.c();
			t33 = space();
			p1 = element("p");
			t34 = text(t34_value);
			t35 = space();
			div7 = element("div");
			button = element("button");
			t36 = text(t36_value);
			attr_dev(path0, "d", "M22 11.08V12a10 10 0 1 1-5.93-9.14");
			attr_dev(path0, "stroke", "currentColor");
			attr_dev(path0, "stroke-width", "2");
			attr_dev(path0, "stroke-linecap", "round");
			attr_dev(path0, "stroke-linejoin", "round");
			add_location(path0, file$1, 27, 10, 921);
			attr_dev(path1, "d", "M22 4 12 14.01l-3-3");
			attr_dev(path1, "stroke", "currentColor");
			attr_dev(path1, "stroke-width", "2");
			attr_dev(path1, "stroke-linecap", "round");
			attr_dev(path1, "stroke-linejoin", "round");
			add_location(path1, file$1, 28, 10, 1064);
			attr_dev(svg, "width", "64");
			attr_dev(svg, "height", "64");
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", "none");
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			add_location(svg, file$1, 26, 8, 815);
			attr_dev(div0, "class", "confirmation-icon svelte-10tkxda");
			add_location(div0, file$1, 25, 6, 775);
			attr_dev(h2, "class", "svelte-10tkxda");
			add_location(h2, file$1, 32, 6, 1217);
			attr_dev(p0, "class", "confirmation-subtitle svelte-10tkxda");
			add_location(p0, file$1, 33, 6, 1274);
			attr_dev(h3, "class", "svelte-10tkxda");
			add_location(h3, file$1, 36, 8, 1406);
			attr_dev(span0, "class", "detail-label svelte-10tkxda");
			add_location(span0, file$1, 40, 12, 1543);
			attr_dev(span1, "class", "detail-value svelte-10tkxda");
			add_location(span1, file$1, 41, 12, 1634);
			attr_dev(div1, "class", "detail-item svelte-10tkxda");
			add_location(div1, file$1, 39, 10, 1505);
			attr_dev(span2, "class", "detail-label svelte-10tkxda");
			add_location(span2, file$1, 55, 12, 2289);
			attr_dev(span3, "class", "detail-value svelte-10tkxda");
			add_location(span3, file$1, 56, 12, 2377);
			attr_dev(div2, "class", "detail-item svelte-10tkxda");
			add_location(div2, file$1, 54, 10, 2251);
			attr_dev(span4, "class", "detail-label svelte-10tkxda");
			add_location(span4, file$1, 161, 12, 7846);
			attr_dev(span5, "class", "detail-value svelte-10tkxda");
			add_location(span5, file$1, 162, 12, 7934);
			attr_dev(div3, "class", "detail-item svelte-10tkxda");
			add_location(div3, file$1, 160, 10, 7808);
			attr_dev(span6, "class", "detail-label svelte-10tkxda");
			add_location(span6, file$1, 166, 12, 8056);
			attr_dev(span7, "class", "detail-value svelte-10tkxda");
			add_location(span7, file$1, 167, 12, 8151);
			attr_dev(div4, "class", "detail-item svelte-10tkxda");
			add_location(div4, file$1, 165, 10, 8018);
			attr_dev(div5, "class", "details-grid svelte-10tkxda");
			add_location(div5, file$1, 38, 8, 1468);
			attr_dev(div6, "class", "confirmation-details svelte-10tkxda");
			add_location(div6, file$1, 35, 6, 1363);
			attr_dev(p1, "class", "email-notice svelte-10tkxda");
			add_location(p1, file$1, 177, 6, 8416);
			attr_dev(button, "class", "btn btn-primary svelte-10tkxda");
			add_location(button, file$1, 180, 8, 8540);
			attr_dev(div7, "class", "confirmation-actions svelte-10tkxda");
			add_location(div7, file$1, 179, 6, 8497);
			attr_dev(div8, "class", "confirmation-container svelte-10tkxda");
			add_location(div8, file$1, 24, 4, 732);
			attr_dev(div9, "class", "container");
			add_location(div9, file$1, 23, 2, 704);
			attr_dev(section, "class", "confirmation-section svelte-10tkxda");
			add_location(section, file$1, 22, 0, 627);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);
			append_dev(section, div9);
			append_dev(div9, div8);
			append_dev(div8, div0);
			append_dev(div0, svg);
			append_dev(svg, path0);
			append_dev(svg, path1);
			append_dev(div8, t0);
			append_dev(div8, h2);
			append_dev(h2, t1);
			append_dev(div8, t2);
			append_dev(div8, p0);
			append_dev(p0, t3);
			append_dev(div8, t4);
			append_dev(div8, div6);
			append_dev(div6, h3);
			append_dev(h3, t5);
			append_dev(div6, t6);
			append_dev(div6, div5);
			append_dev(div5, div1);
			append_dev(div1, span0);
			append_dev(span0, t7);
			append_dev(span0, t8);
			append_dev(div1, t9);
			append_dev(div1, span1);
			if (if_block0) if_block0.m(span1, null);
			append_dev(div5, t10);
			append_dev(div5, div2);
			append_dev(div2, span2);
			append_dev(span2, t11);
			append_dev(span2, t12);
			append_dev(div2, t13);
			append_dev(div2, span3);
			if_block1.m(span3, null);
			append_dev(div5, t14);
			if (if_block2) if_block2.m(div5, null);
			append_dev(div5, t15);
			if (if_block3) if_block3.m(div5, null);
			append_dev(div5, t16);
			if (if_block4) if_block4.m(div5, null);
			append_dev(div5, t17);
			if (if_block5) if_block5.m(div5, null);
			append_dev(div5, t18);
			if (if_block6) if_block6.m(div5, null);
			append_dev(div5, t19);
			if (if_block7) if_block7.m(div5, null);
			append_dev(div5, t20);
			if (if_block8) if_block8.m(div5, null);
			append_dev(div5, t21);
			if (if_block9) if_block9.m(div5, null);
			append_dev(div5, t22);
			append_dev(div5, div3);
			append_dev(div3, span4);
			append_dev(span4, t23);
			append_dev(span4, t24);
			append_dev(div3, t25);
			append_dev(div3, span5);
			append_dev(span5, t26);
			append_dev(div5, t27);
			append_dev(div5, div4);
			append_dev(div4, span6);
			append_dev(span6, t28);
			append_dev(span6, t29);
			append_dev(div4, t30);
			append_dev(div4, span7);
			append_dev(span7, t31);
			append_dev(span7, t32);
			if (if_block10) if_block10.m(span7, null);
			append_dev(div8, t33);
			append_dev(div8, p1);
			append_dev(p1, t34);
			append_dev(div8, t35);
			append_dev(div8, div7);
			append_dev(div7, button);
			append_dev(button, t36);
			current = true;

			if (!mounted) {
				dispose = listen_dev(
					button,
					"click",
					function () {
						if (is_function(/*resetBooking*/ ctx[3])) /*resetBooking*/ ctx[3].apply(this, arguments);
					},
					false,
					false,
					false,
					false
				);

				mounted = true;
			}
		},
		p: function update(new_ctx, [dirty]) {
			ctx = new_ctx;
			if ((!current || dirty & /*content, currentLang*/ 6) && t1_value !== (t1_value = /*content*/ ctx[1][/*currentLang*/ ctx[2]].confirmation.title + "")) set_data_dev(t1, t1_value);
			if ((!current || dirty & /*content, currentLang*/ 6) && t3_value !== (t3_value = /*content*/ ctx[1][/*currentLang*/ ctx[2]].confirmation.subtitle + "")) set_data_dev(t3, t3_value);
			if ((!current || dirty & /*content, currentLang*/ 6) && t5_value !== (t5_value = /*content*/ ctx[1][/*currentLang*/ ctx[2]].confirmation.details + "")) set_data_dev(t5, t5_value);
			if ((!current || dirty & /*content, currentLang*/ 6) && t7_value !== (t7_value = /*content*/ ctx[1][/*currentLang*/ ctx[2]].confirmation.service + "")) set_data_dev(t7, t7_value);

			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
				if_block0.p(ctx, dirty);
			} else {
				if (if_block0) if_block0.d(1);
				if_block0 = current_block_type && current_block_type(ctx);

				if (if_block0) {
					if_block0.c();
					if_block0.m(span1, null);
				}
			}

			if ((!current || dirty & /*content, currentLang*/ 6) && t11_value !== (t11_value = /*content*/ ctx[1][/*currentLang*/ ctx[2]].confirmation.date + "")) set_data_dev(t11, t11_value);

			if (current_block_type_1 === (current_block_type_1 = select_block_type_1(ctx)) && if_block1) {
				if_block1.p(ctx, dirty);
			} else {
				if_block1.d(1);
				if_block1 = current_block_type_1(ctx);

				if (if_block1) {
					if_block1.c();
					if_block1.m(span3, null);
				}
			}

			if (/*bookingDetails*/ ctx[0].time) {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block_17(ctx);
					if_block2.c();
					if_block2.m(div5, t15);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			if (/*bookingDetails*/ ctx[0].serviceType) {
				if (if_block3) {
					if_block3.p(ctx, dirty);
				} else {
					if_block3 = create_if_block_8$1(ctx);
					if_block3.c();
					if_block3.m(div5, t16);
				}
			} else if (if_block3) {
				if_block3.d(1);
				if_block3 = null;
			}

			if (/*bookingDetails*/ ctx[0].licensePlate) {
				if (if_block4) {
					if_block4.p(ctx, dirty);
				} else {
					if_block4 = create_if_block_7$1(ctx);
					if_block4.c();
					if_block4.m(div5, t17);
				}
			} else if (if_block4) {
				if_block4.d(1);
				if_block4 = null;
			}

			if (/*bookingDetails*/ ctx[0].passengers) {
				if (if_block5) {
					if_block5.p(ctx, dirty);
				} else {
					if_block5 = create_if_block_6$1(ctx);
					if_block5.c();
					if_block5.m(div5, t18);
				}
			} else if (if_block5) {
				if_block5.d(1);
				if_block5 = null;
			}

			if (/*bookingDetails*/ ctx[0].days) {
				if (if_block6) {
					if_block6.p(ctx, dirty);
				} else {
					if_block6 = create_if_block_5$1(ctx);
					if_block6.c();
					if_block6.m(div5, t19);
				}
			} else if (if_block6) {
				if_block6.d(1);
				if_block6 = null;
			}

			if (/*bookingDetails*/ ctx[0].carWashPackage && /*bookingDetails*/ ctx[0].carWashPackage !== 'none') {
				if (if_block7) {
					if_block7.p(ctx, dirty);
				} else {
					if_block7 = create_if_block_4$1(ctx);
					if_block7.c();
					if_block7.m(div5, t20);
				}
			} else if (if_block7) {
				if_block7.d(1);
				if_block7 = null;
			}

			if (/*bookingDetails*/ ctx[0].priceBreakdown) {
				if (if_block8) {
					if_block8.p(ctx, dirty);
				} else {
					if_block8 = create_if_block_2$1(ctx);
					if_block8.c();
					if_block8.m(div5, t21);
				}
			} else if (if_block8) {
				if_block8.d(1);
				if_block8 = null;
			}

			if (/*bookingDetails*/ ctx[0].totalPrice !== undefined) {
				if (if_block9) {
					if_block9.p(ctx, dirty);
				} else {
					if_block9 = create_if_block_1$1(ctx);
					if_block9.c();
					if_block9.m(div5, t22);
				}
			} else if (if_block9) {
				if_block9.d(1);
				if_block9 = null;
			}

			if ((!current || dirty & /*content, currentLang*/ 6) && t23_value !== (t23_value = /*content*/ ctx[1][/*currentLang*/ ctx[2]].confirmation.name + "")) set_data_dev(t23, t23_value);
			if ((!current || dirty & /*bookingDetails*/ 1) && t26_value !== (t26_value = /*bookingDetails*/ ctx[0].name + "")) set_data_dev(t26, t26_value);
			if ((!current || dirty & /*content, currentLang*/ 6) && t28_value !== (t28_value = /*content*/ ctx[1][/*currentLang*/ ctx[2]].confirmation.contactInfo + "")) set_data_dev(t28, t28_value);
			if ((!current || dirty & /*bookingDetails*/ 1) && t31_value !== (t31_value = /*bookingDetails*/ ctx[0].contact.phone + "")) set_data_dev(t31, t31_value);

			if (/*bookingDetails*/ ctx[0].contact.email) {
				if (if_block10) {
					if_block10.p(ctx, dirty);
				} else {
					if_block10 = create_if_block$1(ctx);
					if_block10.c();
					if_block10.m(span7, null);
				}
			} else if (if_block10) {
				if_block10.d(1);
				if_block10 = null;
			}

			if ((!current || dirty & /*content, currentLang*/ 6) && t34_value !== (t34_value = /*content*/ ctx[1][/*currentLang*/ ctx[2]].confirmation.emailSent + "")) set_data_dev(t34, t34_value);
			if ((!current || dirty & /*content, currentLang*/ 6) && t36_value !== (t36_value = /*content*/ ctx[1][/*currentLang*/ ctx[2]].confirmation.return + "")) set_data_dev(t36, t36_value);
		},
		i: function intro(local) {
			if (current) return;

			add_render_callback(() => {
				if (!current) return;
				if (!section_transition) section_transition = create_bidirectional_transition(section, fade, { duration: 300 }, true);
				section_transition.run(1);
			});

			current = true;
		},
		o: function outro(local) {
			if (!section_transition) section_transition = create_bidirectional_transition(section, fade, { duration: 300 }, false);
			section_transition.run(0);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);

			if (if_block0) {
				if_block0.d();
			}

			if_block1.d();
			if (if_block2) if_block2.d();
			if (if_block3) if_block3.d();
			if (if_block4) if_block4.d();
			if (if_block5) if_block5.d();
			if (if_block6) if_block6.d();
			if (if_block7) if_block7.d();
			if (if_block8) if_block8.d();
			if (if_block9) if_block9.d();
			if (if_block10) if_block10.d();
			if (detaching && section_transition) section_transition.end();
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function formatCurrency(amount) {
	// Ensure the amount is treated as a number before formatting
	const numericAmount = typeof amount === 'number'
	? amount
	: parseFloat(amount) || 0;

	return new Intl.NumberFormat('hu-HU',
	{
			style: 'currency',
			currency: 'HUF',
			minimumFractionDigits: 0,
			maximumFractionDigits: 0
		}).format(numericAmount);
}

function instance$1($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('BookingConfirmation', slots, []);
	let { bookingDetails = {} } = $$props;
	let { content = {} } = $$props;
	let { currentLang } = $$props;
	let { resetBooking } = $$props;

	$$self.$$.on_mount.push(function () {
		if (currentLang === undefined && !('currentLang' in $$props || $$self.$$.bound[$$self.$$.props['currentLang']])) {
			console.warn("<BookingConfirmation> was created without expected prop 'currentLang'");
		}

		if (resetBooking === undefined && !('resetBooking' in $$props || $$self.$$.bound[$$self.$$.props['resetBooking']])) {
			console.warn("<BookingConfirmation> was created without expected prop 'resetBooking'");
		}
	});

	const writable_props = ['bookingDetails', 'content', 'currentLang', 'resetBooking'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<BookingConfirmation> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('bookingDetails' in $$props) $$invalidate(0, bookingDetails = $$props.bookingDetails);
		if ('content' in $$props) $$invalidate(1, content = $$props.content);
		if ('currentLang' in $$props) $$invalidate(2, currentLang = $$props.currentLang);
		if ('resetBooking' in $$props) $$invalidate(3, resetBooking = $$props.resetBooking);
	};

	$$self.$capture_state = () => ({
		fade,
		bookingDetails,
		content,
		currentLang,
		resetBooking,
		formatCurrency
	});

	$$self.$inject_state = $$props => {
		if ('bookingDetails' in $$props) $$invalidate(0, bookingDetails = $$props.bookingDetails);
		if ('content' in $$props) $$invalidate(1, content = $$props.content);
		if ('currentLang' in $$props) $$invalidate(2, currentLang = $$props.currentLang);
		if ('resetBooking' in $$props) $$invalidate(3, resetBooking = $$props.resetBooking);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [bookingDetails, content, currentLang, resetBooking];
}

class BookingConfirmation extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1, create_fragment$1, safe_not_equal, {
			bookingDetails: 0,
			content: 1,
			currentLang: 2,
			resetBooking: 3
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "BookingConfirmation",
			options,
			id: create_fragment$1.name
		});
	}

	get bookingDetails() {
		throw new Error("<BookingConfirmation>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set bookingDetails(value) {
		throw new Error("<BookingConfirmation>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get content() {
		throw new Error("<BookingConfirmation>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set content(value) {
		throw new Error("<BookingConfirmation>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get currentLang() {
		throw new Error("<BookingConfirmation>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set currentLang(value) {
		throw new Error("<BookingConfirmation>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get resetBooking() {
		throw new Error("<BookingConfirmation>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set resetBooking(value) {
		throw new Error("<BookingConfirmation>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

// src/lib/i18n/booking-content.js
// Translations content for the booking page and its components

const content = {
  hu: {
    title: 'FOGLALÁS',
    subtitle: 'Foglaljon időpontot szolgáltatásainkra gyorsan és egyszerűen',
    serviceSelection: {
      title: 'VÁLASSZON SZOLGÁLTATÁST',
      description: 'Válassza ki a kívánt szolgáltatást az alábbi opciók közül'
    },
    services: {
      airportParking: {
        title: 'REPTÉRI PARKOLÁS',
        description: 'Biztonságos parkolás a repülőtér közelében, 24/7 felügyelettel'
      },
      carWash: {
        title: 'AUTÓMOSÓ',
        description: 'Professzionális autómosó szolgáltatások'
      },
      autoService: {
        title: 'AUTÓSZERVIZ',
        description: 'Teljes körű autószerviz és karbantartás'
      },
      tireService: {
        title: 'GUMISZERVIZ',
        description: 'Gumiabroncs csere, javítás és tárolás'
      }
    },
    bookingForm: {
      airportParking: {
        title: 'REPTÉRI PARKOLÁS FOGLALÁS',
        dateRange: 'Parkolási időszak',
        startDate: 'Érkezési dátum',
        startTime: 'Érkezési idő',
        endDate: 'Távozási dátum',
        endTime: 'Távozási idő',
        licensePlate: 'Rendszám',
        licensePlateRequired: 'A rendszám megadása kötelező',
        totalPrice: 'Teljes összeg',
        days: 'nap',
        passengers: 'Utasok száma',
        passengersRequired: 'Az utasok számának megadása kötelező',
        addCarWash: 'Szeretne kedvezményes autómosást a parkolással?',
        carWashOptions: {
          title: 'Autómosó csomag',
          none: 'Nem kérek',
          smartInteriorExterior: 'SMART - Belső és Külső (8900 Ft)',
          premiumInteriorExterior: 'PRÉMIUM - Belső és Külső (12000 Ft)'
        },
        parkingTotal: 'Parkolás díj',
        carWashStandard: 'Autómosó díj (alap)',
        carWashDiscount: 'Autómosó kedvezmény (20%)',
        carWashDiscounted: 'Autómosó díj (kedvezményes)'
      },
      carWash: {
        title: 'AUTÓMOSÓ IDŐPONTFOGLALÁS',
        date: 'Válasszon dátumot',
        time: 'Válasszon időpontot'
      },
      autoService: {
        title: 'AUTÓSZERVIZ IDŐPONTFOGLALÁS',
        dateTime: 'Időpont kiválasztása',
        date: 'Válasszon dátumot',
        time: 'Válasszon időpontot',
        serviceType: 'Szerviz típusa',
        serviceOptions: {
          maintenance: 'Általános karbantartás',
          repair: 'Javítás',
          diagnostic: 'Diagnosztika',
          other: 'Egyéb'
        },
        carDetails: 'Jármű adatok',
        carModel: 'Autó típusa',
        carModelPlaceholder: 'pl. Toyota Corolla 2018',
        licensePlate: 'Rendszám',
        licensePlatePlaceholder: 'pl. ABC-123',
        notes: 'További megjegyzések',
        notesPlaceholder: 'Írja le a problémát vagy egyéb kéréseit',
        description: 'Probléma leírása (opcionális)'
      },
      tireService: {
        title: 'GUMISZERVIZ IDŐPONTFOGLALÁS',
        dateTime: 'Időpont kiválasztása',
        date: 'Válasszon dátumot',
        time: 'Válasszon időpontot',
        serviceType: 'Szolgáltatás típusa',
        serviceOptions: {
          change: 'Gumiabroncs csere',
          repair: 'Javítás',
          balancing: 'Kerékkiegyensúlyozás',
          storage: 'Gumitárolás'
        },
        carDetails: 'Jármű adatok',
        carModel: 'Autó típusa',
        carModelPlaceholder: 'pl. Toyota Corolla 2018',
        licensePlate: 'Rendszám',
        licensePlatePlaceholder: 'pl. ABC-123',
        tireCount: 'Gumiabroncsok száma',
        notes: 'További megjegyzések',
        notesPlaceholder: 'Írja le a problémát vagy egyéb kéréseit'
      },
      personalInfo: {
        title: 'SZEMÉLYES ADATOK',
        firstName: 'Keresztnév',
        firstNameRequired: 'Keresztnév megadása kötelező',
        lastName: 'Vezetéknév',
        lastNameRequired: 'Vezetéknév megadása kötelező',
        email: 'Email cím',
        emailInvalid: 'Érvénytelen email cím',
        phone: 'Telefonszám',
        phoneRequired: 'Telefonszám megadása kötelező',
        phoneInvalid: 'Érvénytelen telefonszám',
        privacyPolicy: 'Elfogadom az Adatvédelmi irányelveket',
        privacyPolicyRequired: 'Az Adatvédelmi irányelvek elfogadása kötelező',
        privacyPolicyLink: 'Adatvédelmi irányelvek'
      },
      submit: 'FOGLALÁS MEGERŐSÍTÉSE',
      processing: 'Feldolgozás...',
      timeSlots: {
        morning: 'Délelőtt',
        afternoon: 'Délután'
      },
      selectTimeSlot: 'Válasszon időpontot'
    },
    confirmation: {
      title: 'FOGLALÁS MEGERŐSÍTVE',
      subtitle: 'Köszönjük a foglalását!',
      details: 'Foglalás részletei',
      service: 'Szolgáltatás',
      date: 'Dátum',
      time: 'Időpont',
      name: 'Név',
      contactInfo: 'Elérhetőség',
      emailSent: 'A foglalás részleteit elküldtük az email címére.',
      return: 'Vissza a főoldalra'
    }
  },
  en: {
    title: 'BOOKING',
    subtitle: 'Book our services quickly and easily',
    serviceSelection: {
      title: 'SELECT A SERVICE',
      description: 'Choose the service you need from the options below'
    },
    services: {
      airportParking: {
        title: 'AIRPORT PARKING',
        description: 'Secure parking near the airport with 24/7 surveillance'
      },
      carWash: {
        title: 'CAR WASH',
        description: 'Professional car washing services'
      },
      autoService: {
        title: 'AUTO SERVICE',
        description: 'Complete auto service and maintenance'
      },
      tireService: {
        title: 'TIRE SERVICE',
        description: 'Tire replacement, repair, and storage'
      }
    },
    bookingForm: {
      airportParking: {
        title: 'AIRPORT PARKING BOOKING',
        dateRange: 'Parking period',
        startDate: 'Arrival date',
        startTime: 'Arrival time',
        endDate: 'Departure date',
        endTime: 'Departure time',
        licensePlate: 'License plate',
        licensePlateRequired: 'License plate is required',
        totalPrice: 'Total price',
        days: 'days',
        passengers: 'Number of passengers',
        passengersRequired: 'Number of passengers is required',
        addCarWash: 'Would you like a discounted car wash with your parking?',
        carWashOptions: {
          title: 'Car wash package',
          none: 'No, thanks',
          smartInteriorExterior: 'SMART - Interior and Exterior (8900 HUF)',
          premiumInteriorExterior: 'PREMIUM - Interior and Exterior (12000 HUF)'
        },
        parkingTotal: 'Parking fee',
        carWashStandard: 'Car wash fee (standard)',
        carWashDiscount: 'Car wash discount (20%)',
        carWashDiscounted: 'Car wash fee (discounted)'
      },
      carWash: {
        title: 'CAR WASH APPOINTMENT',
        date: 'Select a date',
        time: 'Select a time'
      },
      autoService: {
        title: 'AUTO SERVICE APPOINTMENT',
        dateTime: 'Select Date & Time',
        date: 'Select a date',
        time: 'Select a time',
        serviceType: 'Service type',
        serviceOptions: {
          maintenance: 'General maintenance',
          repair: 'Repair',
          diagnostic: 'Diagnostics',
          other: 'Other'
        },
        carDetails: 'Vehicle Details',
        carModel: 'Car model',
        carModelPlaceholder: 'e.g. Toyota Corolla 2018',
        licensePlate: 'License plate',
        licensePlatePlaceholder: 'e.g. ABC-123',
        notes: 'Additional notes',
        notesPlaceholder: 'Describe the issue or any special requests',
        description: 'Problem description (optional)'
      },
      tireService: {
        title: 'TIRE SERVICE APPOINTMENT',
        dateTime: 'Select Date & Time',
        date: 'Select a date',
        time: 'Select a time',
        serviceType: 'Service type',
        serviceOptions: {
          change: 'Tire replacement',
          repair: 'Repair',
          balancing: 'Wheel balancing',
          storage: 'Tire storage'
        },
        carDetails: 'Vehicle Details',
        carModel: 'Car model',
        carModelPlaceholder: 'e.g. Toyota Corolla 2018',
        licensePlate: 'License plate',
        licensePlatePlaceholder: 'e.g. ABC-123',
        tireCount: 'Number of tires',
        notes: 'Additional notes',
        notesPlaceholder: 'Any special requests or additional information'
      },
      personalInfo: {
        title: 'PERSONAL INFORMATION',
        firstName: 'First name',
        firstNameRequired: 'First name is required',
        lastName: 'Last name',
        lastNameRequired: 'Last name is required',
        email: 'Email address',
        emailInvalid: 'Invalid email address',
        phone: 'Phone number',
        phoneRequired: 'Phone number is required',
        phoneInvalid: 'Invalid phone number',
        privacyPolicy: 'I accept the Privacy Policy',
        privacyPolicyRequired: 'You must accept the Privacy Policy',
        privacyPolicyLink: 'Privacy Policy'
      },
      submit: 'CONFIRM BOOKING',
      processing: 'Processing...',
      timeSlots: {
        morning: 'Morning',
        afternoon: 'Afternoon'
      },
      selectTimeSlot: 'Please select a time slot'
    },
    confirmation: {
      title: 'BOOKING CONFIRMED',
      subtitle: 'Thank you for your booking!',
      details: 'Booking details',
      service: 'Service',
      date: 'Date',
      time: 'Time',
      name: 'Name',
      contactInfo: 'Contact information',
      emailSent: 'Booking details have been sent to your email address.',
      return: 'Return to homepage'
    }
  }
};

/* src/pages/Booking.svelte generated by Svelte v3.59.2 */

const { console: console_1 } = globals;

const file = "src/pages/Booking.svelte";

// (256:0) {:else}
function create_else_block(ctx) {
	let bookingconfirmation;
	let current;

	bookingconfirmation = new BookingConfirmation({
			props: {
				bookingDetails: /*bookingDetails*/ ctx[3],
				content,
				currentLang: /*lang*/ ctx[6],
				resetBooking: /*resetBooking*/ ctx[10]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(bookingconfirmation.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(bookingconfirmation, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const bookingconfirmation_changes = {};
			if (dirty & /*bookingDetails*/ 8) bookingconfirmation_changes.bookingDetails = /*bookingDetails*/ ctx[3];
			if (dirty & /*lang*/ 64) bookingconfirmation_changes.currentLang = /*lang*/ ctx[6];
			bookingconfirmation.$set(bookingconfirmation_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(bookingconfirmation.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(bookingconfirmation.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(bookingconfirmation, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(256:0) {:else}",
		ctx
	});

	return block;
}

// (192:0) {#if !showConfirmation}
function create_if_block(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_1, create_if_block_2];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*currentStep*/ ctx[0] === 1) return 0;
		if (/*currentStep*/ ctx[0] === 2) return 1;
		return -1;
	}

	if (~(current_block_type_index = select_block_type_1(ctx))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(target, anchor);
			}

			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				} else {
					if_block = null;
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d(detaching);
			}

			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(192:0) {#if !showConfirmation}",
		ctx
	});

	return block;
}

// (199:30) 
function create_if_block_2(ctx) {
	let section;
	let div2;
	let div0;
	let button;
	let svg;
	let path;
	let t0;
	let t1_value = (/*lang*/ ctx[6] === 'hu' ? 'Vissza' : 'Back') + "";
	let t1;
	let t2;
	let h2;
	let t3_value = (content[/*lang*/ ctx[6]].bookingForm[/*selectedService*/ ctx[1]]?.title || '') + "";
	let t3;
	let t4;
	let div1;
	let current_block_type_index;
	let if_block0;
	let t5;
	let current_block_type_index_1;
	let if_block1;
	let current;
	let mounted;
	let dispose;
	const if_block_creators = [create_if_block_7, create_if_block_8];
	const if_blocks = [];

	function select_block_type_2(ctx, dirty) {
		if (/*submitError*/ ctx[5]) return 0;
		if (/*isSubmitting*/ ctx[4]) return 1;
		return -1;
	}

	if (~(current_block_type_index = select_block_type_2(ctx))) {
		if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	const if_block_creators_1 = [create_if_block_3, create_if_block_4, create_if_block_5, create_if_block_6];
	const if_blocks_1 = [];

	function select_block_type_3(ctx, dirty) {
		if (/*selectedService*/ ctx[1] === 'airportParking') return 0;
		if (/*selectedService*/ ctx[1] === 'carWash') return 1;
		if (/*selectedService*/ ctx[1] === 'autoService') return 2;
		if (/*selectedService*/ ctx[1] === 'tireService') return 3;
		return -1;
	}

	if (~(current_block_type_index_1 = select_block_type_3(ctx))) {
		if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
	}

	const block = {
		c: function create() {
			section = element("section");
			div2 = element("div");
			div0 = element("div");
			button = element("button");
			svg = svg_element("svg");
			path = svg_element("path");
			t0 = space();
			t1 = text(t1_value);
			t2 = space();
			h2 = element("h2");
			t3 = text(t3_value);
			t4 = space();
			div1 = element("div");
			if (if_block0) if_block0.c();
			t5 = space();
			if (if_block1) if_block1.c();
			attr_dev(path, "d", "M19 12H5M5 12L12 19M5 12L12 5");
			attr_dev(path, "stroke", "currentColor");
			attr_dev(path, "stroke-width", "2");
			attr_dev(path, "stroke-linecap", "round");
			attr_dev(path, "stroke-linejoin", "round");
			add_location(path, file, 204, 14, 8283);
			attr_dev(svg, "width", "16");
			attr_dev(svg, "height", "16");
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", "none");
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", "svelte-1z2ak2");
			add_location(svg, file, 203, 12, 8173);
			attr_dev(button, "class", "back-button svelte-1z2ak2");
			button.disabled = /*isSubmitting*/ ctx[4];
			add_location(button, file, 202, 10, 8090);
			attr_dev(h2, "class", "form-title svelte-1z2ak2");
			add_location(h2, file, 209, 10, 8510);
			attr_dev(div0, "class", "booking-header svelte-1z2ak2");
			add_location(div0, file, 201, 8, 8051);
			attr_dev(div1, "class", "booking-form-container svelte-1z2ak2");
			add_location(div1, file, 214, 8, 8645);
			attr_dev(div2, "class", "container");
			add_location(div2, file, 200, 6, 8019);
			attr_dev(section, "class", "booking-form-section svelte-1z2ak2");
			add_location(section, file, 199, 4, 7974);
		},
		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);
			append_dev(section, div2);
			append_dev(div2, div0);
			append_dev(div0, button);
			append_dev(button, svg);
			append_dev(svg, path);
			append_dev(button, t0);
			append_dev(button, t1);
			append_dev(div0, t2);
			append_dev(div0, h2);
			append_dev(h2, t3);
			append_dev(div2, t4);
			append_dev(div2, div1);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(div1, null);
			}

			append_dev(div1, t5);

			if (~current_block_type_index_1) {
				if_blocks_1[current_block_type_index_1].m(div1, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen_dev(button, "click", /*goBack*/ ctx[8], false, false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty & /*lang*/ 64) && t1_value !== (t1_value = (/*lang*/ ctx[6] === 'hu' ? 'Vissza' : 'Back') + "")) set_data_dev(t1, t1_value);

			if (!current || dirty & /*isSubmitting*/ 16) {
				prop_dev(button, "disabled", /*isSubmitting*/ ctx[4]);
			}

			if ((!current || dirty & /*lang, selectedService*/ 66) && t3_value !== (t3_value = (content[/*lang*/ ctx[6]].bookingForm[/*selectedService*/ ctx[1]]?.title || '') + "")) set_data_dev(t3, t3_value);
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_2(ctx);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block0) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block0 = if_blocks[current_block_type_index];

					if (!if_block0) {
						if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block0.c();
					} else {
						if_block0.p(ctx, dirty);
					}

					transition_in(if_block0, 1);
					if_block0.m(div1, t5);
				} else {
					if_block0 = null;
				}
			}

			let previous_block_index_1 = current_block_type_index_1;
			current_block_type_index_1 = select_block_type_3(ctx);

			if (current_block_type_index_1 === previous_block_index_1) {
				if (~current_block_type_index_1) {
					if_blocks_1[current_block_type_index_1].p(ctx, dirty);
				}
			} else {
				if (if_block1) {
					group_outros();

					transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
						if_blocks_1[previous_block_index_1] = null;
					});

					check_outros();
				}

				if (~current_block_type_index_1) {
					if_block1 = if_blocks_1[current_block_type_index_1];

					if (!if_block1) {
						if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
						if_block1.c();
					} else {
						if_block1.p(ctx, dirty);
					}

					transition_in(if_block1, 1);
					if_block1.m(div1, null);
				} else {
					if_block1 = null;
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d();
			}

			if (~current_block_type_index_1) {
				if_blocks_1[current_block_type_index_1].d();
			}

			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(199:30) ",
		ctx
	});

	return block;
}

// (193:2) {#if currentStep === 1}
function create_if_block_1(ctx) {
	let serviceselection;
	let current;

	serviceselection = new ServiceSelection({
			props: {
				content,
				currentLang: /*lang*/ ctx[6],
				onSelectService: /*selectService*/ ctx[7]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(serviceselection.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(serviceselection, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const serviceselection_changes = {};
			if (dirty & /*lang*/ 64) serviceselection_changes.currentLang = /*lang*/ ctx[6];
			serviceselection.$set(serviceselection_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(serviceselection.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(serviceselection.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(serviceselection, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(193:2) {#if currentStep === 1}",
		ctx
	});

	return block;
}

// (218:33) 
function create_if_block_8(ctx) {
	let div;
	let loadingspinner;
	let t0;
	let p;

	let t1_value = (/*lang*/ ctx[6] === 'hu'
	? 'Foglalás feldolgozása, kérjük várjon...'
	: 'Processing booking, please wait...') + "";

	let t1;
	let current;

	loadingspinner = new LoadingSpinner({
			props: { size: "2rem", color: "var(--primary)" },
			$$inline: true
		});

	const block = {
		c: function create() {
			div = element("div");
			create_component(loadingspinner.$$.fragment);
			t0 = space();
			p = element("p");
			t1 = text(t1_value);
			attr_dev(p, "class", "submitting-message svelte-1z2ak2");
			add_location(p, file, 220, 14, 8926);
			attr_dev(div, "class", "submitting-overlay svelte-1z2ak2");
			add_location(div, file, 218, 12, 8811);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(loadingspinner, div, null);
			append_dev(div, t0);
			append_dev(div, p);
			append_dev(p, t1);
			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty & /*lang*/ 64) && t1_value !== (t1_value = (/*lang*/ ctx[6] === 'hu'
			? 'Foglalás feldolgozása, kérjük várjon...'
			: 'Processing booking, please wait...') + "")) set_data_dev(t1, t1_value);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(loadingspinner.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(loadingspinner.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(loadingspinner);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_8.name,
		type: "if",
		source: "(218:33) ",
		ctx
	});

	return block;
}

// (216:10) {#if submitError}
function create_if_block_7(ctx) {
	let p;
	let t;

	const block = {
		c: function create() {
			p = element("p");
			t = text(/*submitError*/ ctx[5]);
			attr_dev(p, "class", "error-message svelte-1z2ak2");
			add_location(p, file, 216, 12, 8722);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*submitError*/ 32) set_data_dev(t, /*submitError*/ ctx[5]);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_7.name,
		type: "if",
		source: "(216:10) {#if submitError}",
		ctx
	});

	return block;
}

// (245:54) 
function create_if_block_6(ctx) {
	let tireserviceform;
	let current;

	tireserviceform = new TireServiceForm({
			props: { content, currentLang: /*lang*/ ctx[6] },
			$$inline: true
		});

	tireserviceform.$on("bookingComplete", /*handleBookingComplete*/ ctx[9]);

	const block = {
		c: function create() {
			create_component(tireserviceform.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(tireserviceform, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const tireserviceform_changes = {};
			if (dirty & /*lang*/ 64) tireserviceform_changes.currentLang = /*lang*/ ctx[6];
			tireserviceform.$set(tireserviceform_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(tireserviceform.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(tireserviceform.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(tireserviceform, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_6.name,
		type: "if",
		source: "(245:54) ",
		ctx
	});

	return block;
}

// (239:54) 
function create_if_block_5(ctx) {
	let autoserviceform;
	let current;

	autoserviceform = new AutoServiceForm({
			props: { content, currentLang: /*lang*/ ctx[6] },
			$$inline: true
		});

	autoserviceform.$on("bookingComplete", /*handleBookingComplete*/ ctx[9]);

	const block = {
		c: function create() {
			create_component(autoserviceform.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(autoserviceform, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const autoserviceform_changes = {};
			if (dirty & /*lang*/ 64) autoserviceform_changes.currentLang = /*lang*/ ctx[6];
			autoserviceform.$set(autoserviceform_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(autoserviceform.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(autoserviceform.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(autoserviceform, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_5.name,
		type: "if",
		source: "(239:54) ",
		ctx
	});

	return block;
}

// (233:50) 
function create_if_block_4(ctx) {
	let carwashform;
	let current;

	carwashform = new CarWashForm({
			props: { content, currentLang: /*lang*/ ctx[6] },
			$$inline: true
		});

	carwashform.$on("bookingComplete", /*handleBookingComplete*/ ctx[9]);

	const block = {
		c: function create() {
			create_component(carwashform.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(carwashform, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const carwashform_changes = {};
			if (dirty & /*lang*/ 64) carwashform_changes.currentLang = /*lang*/ ctx[6];
			carwashform.$set(carwashform_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(carwashform.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(carwashform.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(carwashform, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4.name,
		type: "if",
		source: "(233:50) ",
		ctx
	});

	return block;
}

// (227:10) {#if selectedService === 'airportParking'}
function create_if_block_3(ctx) {
	let airportparkingform;
	let current;

	airportparkingform = new AirportParkingForm({
			props: { content, currentLang: /*lang*/ ctx[6] },
			$$inline: true
		});

	airportparkingform.$on("bookingComplete", /*handleBookingComplete*/ ctx[9]);

	const block = {
		c: function create() {
			create_component(airportparkingform.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(airportparkingform, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const airportparkingform_changes = {};
			if (dirty & /*lang*/ 64) airportparkingform_changes.currentLang = /*lang*/ ctx[6];
			airportparkingform.$set(airportparkingform_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(airportparkingform.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(airportparkingform.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(airportparkingform, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3.name,
		type: "if",
		source: "(227:10) {#if selectedService === 'airportParking'}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let section;
	let div;
	let h1;
	let t0_value = content[/*lang*/ ctx[6]].title + "";
	let t0;
	let t1;
	let p;
	let t2_value = content[/*lang*/ ctx[6]].subtitle + "";
	let t2;
	let t3;
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block, create_else_block];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (!/*showConfirmation*/ ctx[2]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			section = element("section");
			div = element("div");
			h1 = element("h1");
			t0 = text(t0_value);
			t1 = space();
			p = element("p");
			t2 = text(t2_value);
			t3 = space();
			if_block.c();
			if_block_anchor = empty();
			attr_dev(h1, "class", "svelte-1z2ak2");
			add_location(h1, file, 186, 4, 7693);
			attr_dev(p, "class", "svelte-1z2ak2");
			add_location(p, file, 187, 4, 7728);
			attr_dev(div, "class", "container");
			add_location(div, file, 185, 2, 7665);
			attr_dev(section, "class", "booking-hero svelte-1z2ak2");
			add_location(section, file, 184, 0, 7632);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);
			append_dev(section, div);
			append_dev(div, h1);
			append_dev(h1, t0);
			append_dev(div, t1);
			append_dev(div, p);
			append_dev(p, t2);
			insert_dev(target, t3, anchor);
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if ((!current || dirty & /*lang*/ 64) && t0_value !== (t0_value = content[/*lang*/ ctx[6]].title + "")) set_data_dev(t0, t0_value);
			if ((!current || dirty & /*lang*/ 64) && t2_value !== (t2_value = content[/*lang*/ ctx[6]].subtitle + "")) set_data_dev(t2, t2_value);
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);
			if (detaching) detach_dev(t3);
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

const backendApiUrl = 'https://zima-auto-backend.fly.dev/api/send-booking-emails';

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Booking', slots, []);
	let currentStep = 1;
	let selectedService = null;
	let showConfirmation = false;
	let bookingDetails = {}; // Stores data for confirmation display
	let isSubmitting = false; // Indicates if backend submission is in progress
	let submitError = null; // Stores error message from backend submission
	let submitSuccess = false; // Indicates successful backend submission
	let lang = 'hu'; // Local state for current language

	// Subscribe to language changes
	currentLang.subscribe(value => {
		$$invalidate(6, lang = value);
	});

	// Handle service selection (Step 1 -> Step 2)
	function selectService(service) {
		$$invalidate(1, selectedService = service);
		$$invalidate(0, currentStep = 2);

		// Reset submission state and messages when moving to form
		$$invalidate(5, submitError = null);

		submitSuccess = false;
		$$invalidate(4, isSubmitting = false); // Ensure submitting state is false when starting a new form

		// Scroll to the form section for better UX
		setTimeout(
			() => {
				const bookingFormSection = document.querySelector('.booking-form-section');

				if (bookingFormSection) {
					// Scroll to the top of the form section, offset slightly
					window.scrollTo({
						top: bookingFormSection.offsetTop - 100,
						behavior: 'smooth'
					});
				}
			},
			50
		); // Small delay to allow DOM to update
	}

	// Go back to service selection (Step 2 -> Step 1)
	function goBack() {
		$$invalidate(0, currentStep = 1);
		$$invalidate(1, selectedService = null); // Reset selected service when going back

		// Clear submission state and messages
		$$invalidate(5, submitError = null);

		submitSuccess = false;
		$$invalidate(4, isSubmitting = false); // Ensure submitting state is false when going back

		// Scroll back to service selection section
		setTimeout(
			() => {
				const serviceSelectionSection = document.querySelector('.service-selection-section');

				if (serviceSelectionSection) {
					window.scrollTo({
						top: serviceSelectionSection.offsetTop - 100,
						behavior: 'smooth'
					});
				}
			},
			50
		); // Small delay
	}

	// Handle form submission result from individual service forms
	// This function receives the validated form data from the child components
	async function handleBookingComplete(event) {
		const formData = event.detail; // Data dispatched from the child form component
		console.log('Booking.svelte received bookingComplete event with data:', formData);
		$$invalidate(4, isSubmitting = true); // Start submission process
		$$invalidate(5, submitError = null); // Clear previous errors
		submitSuccess = false; // Reset success state
		$$invalidate(2, showConfirmation = false); // Hide confirmation while submitting

		try {
			// Prepare data structure expected by the backend email endpoint
			// Map fields from the received formData to the backend's expected structure
			const emailData = {
				service: formData.service, // Service type (e.g., 'carWash', 'airportParking')
				customerName: formData.name, // Full name
				// Access email/phone from the nested contact object
				customerEmail: formData.contact?.email,
				customerPhone: formData.contact?.phone,
				date: formData.date, // Date (YYYY-MM-DD or date range string for parking)
				time: formData.time || '', // Time (HH:MM or empty for parking)
				// Fields specific to Airport Parking (may be undefined for other services)
				days: formData.days || null,
				licensePlate: formData.licensePlate || '', // License plate
				carWashPackage: formData.carWashPackage || 'none', // Car wash package for parking
				priceBreakdown: formData.priceBreakdown || null, // Price details for parking
				totalPrice: formData.totalPrice || null, // Total price
				// Fields specific to Auto/Tire Service (may be undefined for other services)
				serviceType: formData.serviceType || '', // Specific type of auto/tire service
				carModel: formData.carModel || '', // Car model
				notes: formData.notes || '', // Additional notes
				tireCount: formData.tireCount || null, // Number of tires for tire service
				// Always include admin email (ensure this is correct)
				adminEmail: 'jarsunkaev@gmail.com'
			};

			console.log('Booking.svelte sending data to backend API:', emailData);

			// Send data to your backend API endpoint
			const response = await fetch(backendApiUrl, {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify(emailData)
			});

			// Parse the JSON response from the backend
			const result = await response.json();

			if (response.ok) {
				// Backend reported success (status code 2xx)
				console.log('Backend booking process reported successful:', result);

				$$invalidate(3, bookingDetails = formData); // Store the original form data for the confirmation page
				submitSuccess = true; // Set success state
				$$invalidate(5, submitError = null); // Clear any previous error
				$$invalidate(2, showConfirmation = true); // Show the confirmation page
			} else {
				// Backend reported an error (status code not 2xx)
				console.error('Backend booking process reported failure:', response.status, result.message);

				// Display the error message from the backend if available, otherwise a generic one
				$$invalidate(5, submitError = result.message || (lang === 'hu'
				? 'Hiba történt a foglalás feldolgozása során.'
				: 'An error occurred during booking processing.'));

				submitSuccess = false; // Ensure success state is false
			}
		} catch(error) {
			// An error occurred during the fetch request itself (e.g., network error)
			console.error('Error submitting booking request to backend:', error);

			$$invalidate(5, submitError = lang === 'hu'
			? 'Hiba történt a szerverhez való kapcsolódás során.'
			: 'An error occurred while connecting to the server.');

			submitSuccess = false; // Ensure success state is false
		} finally {
			// This block always runs after try/catch
			$$invalidate(4, isSubmitting = false); // End submission process

			// If submission was successful, scroll to top to show confirmation
			if (submitSuccess) {
				window.scrollTo({ top: 0, behavior: 'smooth' });
			}
		}
	}

	// Reset booking process to the initial state (Step 1)
	function resetBooking() {
		$$invalidate(1, selectedService = null);
		$$invalidate(0, currentStep = 1);
		$$invalidate(2, showConfirmation = false);
		$$invalidate(5, submitError = null);
		submitSuccess = false;
		$$invalidate(4, isSubmitting = false); // Ensure submitting state is false
		$$invalidate(3, bookingDetails = {}); // Clear previous booking details
		window.scrollTo({ top: 0, behavior: 'smooth' }); // Scroll to top
	}

	// Scroll to top on mount
	onMount(() => {
		window.scrollTo({ top: 0, behavior: 'smooth' });
	});

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<Booking> was created with unknown prop '${key}'`);
	});

	$$self.$capture_state = () => ({
		onMount,
		currentLang,
		LoadingSpinner,
		ServiceSelection,
		AirportParkingForm,
		CarWashForm,
		AutoServiceForm,
		TireServiceForm,
		BookingConfirmation,
		content,
		currentStep,
		selectedService,
		showConfirmation,
		bookingDetails,
		isSubmitting,
		submitError,
		submitSuccess,
		lang,
		backendApiUrl,
		selectService,
		goBack,
		handleBookingComplete,
		resetBooking
	});

	$$self.$inject_state = $$props => {
		if ('currentStep' in $$props) $$invalidate(0, currentStep = $$props.currentStep);
		if ('selectedService' in $$props) $$invalidate(1, selectedService = $$props.selectedService);
		if ('showConfirmation' in $$props) $$invalidate(2, showConfirmation = $$props.showConfirmation);
		if ('bookingDetails' in $$props) $$invalidate(3, bookingDetails = $$props.bookingDetails);
		if ('isSubmitting' in $$props) $$invalidate(4, isSubmitting = $$props.isSubmitting);
		if ('submitError' in $$props) $$invalidate(5, submitError = $$props.submitError);
		if ('submitSuccess' in $$props) submitSuccess = $$props.submitSuccess;
		if ('lang' in $$props) $$invalidate(6, lang = $$props.lang);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		currentStep,
		selectedService,
		showConfirmation,
		bookingDetails,
		isSubmitting,
		submitError,
		lang,
		selectService,
		goBack,
		handleBookingComplete,
		resetBooking
	];
}

class Booking extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Booking",
			options,
			id: create_fragment.name
		});
	}
}

export { Booking as default };
//# sourceMappingURL=Booking-09324cac.js.map
